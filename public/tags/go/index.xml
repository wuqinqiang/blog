<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on 是不是很酷</title>
    <link>https://www.syst.top/tags/go/</link>
    <description>Recent content in go on 是不是很酷</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Tue, 10 Jan 2023 18:23:51 +0800</lastBuildDate><atom:link href="https://www.syst.top/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>发现conc并发库一个有趣的问题</title>
      <link>https://www.syst.top/posts/go/conc/</link>
      <pubDate>Tue, 10 Jan 2023 18:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/conc/</guid>
      <description>上周看到一个新库conc，
 better structured concurrency for go
 这个库的目标是，
 更难出现goroutine泄漏 优雅处理panic 使并发的代码更易读  我们一条条细说。
Make it harder to leak goroutines goroutine泄漏还是很常见的。
日常我们使用go的时候直接go func开启一个goroutine，写上对应的逻辑，g会进入到某个p的本地队列，最终由p绑定的m执行这个goroutine。
你能保证一个goroutine在某个时刻一定会结束它的生命周期吗？
搜了下著名开源项目etcd，goroutine leak还真不少。
看其中一个简单的泄漏bug。
done是一个无缓冲的chan，一开始接收动作在最下面，因为中间还有一些没展开的代码可能会导致程序不会执行到&amp;lt;-done，然后goroutine就会发生泄漏，解决方法就是通过defer保证一定会执行&amp;lt;-done。
那么conc是如何做的？
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/sourcegraph/conc&amp;#34; ) func main() { var wg conc.WaitGroup wg.Go(func() { fmt.Println(&amp;#34;g1&amp;#34;) }) wg.Go(func() { fmt.Println(&amp;#34;g2&amp;#34;) }) wg.Wait() } ps:这个结构是不是超级熟悉。
conc的理念是程序中的每一个goroutine由一个owner创建，归属于owner。一个owner确保它拥有的所有goroutine正常退出，这里的owner也就是conc.WaitGroup。
但是这真的能像他说的那样Make it harder to leak goroutines吗？
goroutine的泄漏问题取决于用户对goroutine能正确退出的逻辑保证，和你如何封装没关系吧？
在我看来conc和标准库的sync.WaitGroup一样，等待所有goroutine执行完毕，可以检测到这个行为。
要是goroutine里面含有泄漏的bug，该泄漏还得泄漏，Wait该等待还得老实等待。
Handle panics gracefully 如果直接使用go func,那么可能每一个goroutine都得写上recover，所以一般我们在使用goroutine的时候，都是自己封装一个GoSafe函数。这样就可以在里面统一捕获panic，然后打包调用栈一些信息，进一步处理。
conc里面因为每个goroutine有owner概念，所以是由owner捕获goroutine的panic。</description>
    </item>
    
    <item>
      <title>evio原理解析～有彩蛋</title>
      <link>https://www.syst.top/posts/go/evio/</link>
      <pubDate>Fri, 06 Jan 2023 19:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/evio/</guid>
      <description>之前分析过go自带的netpoll，以及自建的网络框架gnet。
当然这类框架还有:evio、gev、nbio、cloudwego/netpoll(字节的)。
为什么会出现这么多自建框架?
我觉得逃不过三点，
  自带的netpoll满足不了一些特殊场景。
  其他实现设计存在局限性，存在优化空间。
  程序员都喜欢自己造轮子。
  另外，这类框架都是基于syscall epoll实现的事件驱动框架。主要区别我觉得在于，
 对连接conn的管理 对读写数据管理  带着这些问题，我打算把这些框架都看一遍。学习里面优秀的设计以及对比他们的不同点，可以的话，做个整体的性能测试。
这几个框架中，evio是最早的开源实现，开源于2017年。
有意思的是，看到几篇文章说evio存在当loopWrite在内核缓冲区满，无法一次写入时，会出现写入数据丢失的bug。
仔细阅读了代码，evio并不存在这个bug。也不存在是作者后来修复了这个bug，而是evio本身不存在这个bug。
下面会说明。
原理解析 根据代码画了个简易架构图说明evio架构。
简单解释一下，evio启动的时候可以指定loops个数，即多少个epoll实例。同时可以启动多个监听地址，比如图中监听了两个端口。
程序会把每个Listener fd加入到每个epoll并注册这些fd的读事件。每个epoll会开启一个goroutine等待事件到来。
当客户端发起对应端口连接，程序会根据策略选择一个epoll，并把conn fd 也加入到此epoll并注册读写事件。
当一个conn fd读事件ready，那么对应的epoll会被唤醒，然后执行相应的操作。
以上就是整理的流程，接下来我们来深入一些细节。
在此之前，根据上面所描述的，需要先提几个问题，
 当一个新的客户端连接到来时，会发生什么？ 读写数据是如何流动的？ 同一个epoll里多个fd读写事件ready，程序是如何处理的？  看完下面，再回来回答这三个问题。
代码细节 运行一个简单demo，
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/tidwall/evio&amp;#34; &amp;#34;log&amp;#34; ) func main() { var events evio.Events events.NumLoops = 3 events.Serving = func(srv evio.Server) (action evio.Action) { log.</description>
    </item>
    
    <item>
      <title>easycar更新日记</title>
      <link>https://www.syst.top/posts/go/easycar2/</link>
      <pubDate>Sun, 06 Nov 2022 10:11:22 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/easycar2/</guid>
      <description>开篇 又拖更了一个多月，在思考人生的意义。
上一次介绍了新开发的一个分布式的事务框架easycar，这篇就当是对easycar的更新日记了。
服务注册与发现
由于easycar底层基于gRPC, 通过自定义Resolver接口还是很容易实现的。
负载均衡
客户端负载均衡，目前支持
  round-robin
  random
  power of 2 random choice
  consistent hash
  ip-hash
  least-load
  架构图
上次提到，参与的一组分布式事务可能部分操作存在先后顺序的问题。
我举了个例子，我们需要保证必须先执行account扣减余额和stock扣减库存服务成功后，才能创建订单order的服务。同时account和stock服务并不需要保证他们的执行顺序。下图，
以这个例子，那么实际在easycar中整个流程，
成功
失败
在easycar中，client负责和easycar(TC)端交互。主要负责注册分支，触发执行分布式事务以及查看状态等。
它并不会和RM产生联系。也就是说它不会负责去请求RM的第一阶段，这是和其他平台不同的一点。
TC全程接管和更新RM状态。
分支状态
项目地址:
Easycar: https://github.com/wuqinqiang/easycar
Client-go: https://github.com/easycar/client-go
Examples： https://github.com/easycar/examples</description>
    </item>
    
    <item>
      <title>一个用go实现的分布式事务框架</title>
      <link>https://www.syst.top/posts/go/easycar/</link>
      <pubDate>Mon, 12 Sep 2022 18:11:22 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/easycar/</guid>
      <description>开篇 对分布式事务一直感兴趣，之前一直被其他事情(懒)耽搁了，最近终于动手了。
easycar是什么 easycar 是一个用go实现的支持两阶段提交协议的分布式事务框架。目前还只支持TCC,SAGA 模式，其他模式待开发。
在介绍easycar 之前，先简单介绍几个角色。
Transaction Coordinator(TC) 负责全局事务的管理，所有参与分布式事务的分支都会注册到coordinator，回给每个分布式事务分配一个唯一id，
当然还包括驱动全局 begin / commit /abort(我喜欢称rollback)。
Transaction Manager (TM) 有些时候也叫 Transaction Client，当然不同的实现也许都会换个名字，但是职责都大差不差。
一般通过TM对每个参与的RM发起一阶段的请求，如果一阶段的RM全部成功，那么TM会向TC发起commit请求，否则发起rollback。
Resource Manager(RM) 用户维度的角色，管理本地事务处理的资源。其实你可以这么理解，假设你的订单服务部分接口参与了分布式事务，无论是第一阶段TM调用接口，还是TC第二阶段调用接口，你的订单服务都会去负责本地的事务修改。
那么 easycar 上述角色有什么不同吗？
有的。既然TC负责的就是全局事务的管理，那么我把职责都给了它。即由TC像每个参与的RM发起一阶段的请求，然后再根据一阶段的结果，发起二阶段的请求。由TC接管整个分布式事务的生命周期。
是的，我弱化了上面TM的能力。在我眼里，TM本质上就是一个客户端。客户端只需要做一些数据封装，简便化操作即可。所以即使没有客户端，其他语言的用户也可以直接通过http请求easycar服务接口。
所以理论上，大部分模式下，不需要客户端也是可以直接使用easycar服务的。
支持协议和事务模式同时混用 参与分布式事务的服务往往由不同的多个部门维护，或者部分新老项目交错，可能无法保证服务的协议是一致的。
另外，不同的服务所采用的事务模式具体是由：业务场景以及构造的成本来决定的。所以参与分布式事务之间所使用的事务模式不一定是统一的。
在这些基础上，easycar支持协议混用(目前支持http和原生的grpc服务)，支持部分事务模式混用(目前支持TCC,Saga)。
支持并发执行 假如现在有 order，account以及stock三个服务。
由这三个服务组成一个分布式事务。 当用户下单时，需要经过这三个服务中内部一些接口(account 扣钱，stock减库存，order 创建订单)。
如果只是同步执行第一阶段，那么第一阶段总执行时间= (account+stock+order)。
很多场景下，分布式事务之间并不会存在执行依赖先后的关系。所以多个子事务一阶段可以同时并发执行。
流程就像这样：
上图我们需要保证创建订单前必须先执行account扣减余额和stock扣减库存服务，才能创建订单order的服务。同时account和stock服务并不需要保证他们的执行顺序。
那么我们一阶段总执行耗时可以粗略=max(account,stock)+order。
因此，easycar是支持分层并发执行的。 对参与的RM通过设置的权重做分层，同一层的RM可以并发调用，一层处理完毕再接下一层。在这个基础上，当某个RM发生调用错误时，那么后面一层也不会执行了，整个分布式事务需要回滚。
异常处理 分布式事务中会出现一些问题，比如
  空补偿： Cancel请求到来时，Try还没有执行，这时候这样的请求我们不能执行，理应直接返回。
  悬挂： Try执行时，Cancel已执行完成，不能执行，直接返回。
  幂等： 所有操作的接口都存在这个问题。
  这些问题需要用户自己去解决，框架不会自动帮你处理。
在我看来，这些问题本身就是服务的必要工作，而不是通过外部服务来帮你保证。
换句话说，前端说它参数做了校验，难道后端就不校验接口了吗？</description>
    </item>
    
    <item>
      <title>Gnet原理解析</title>
      <link>https://www.syst.top/posts/go/gnet/</link>
      <pubDate>Tue, 07 Jun 2022 16:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/gnet/</guid>
      <description>距离上次写文章过了一月有余，这段时间着实太躺了。以至于昨晚做了一个噩梦，醒来的时候狠狠的抽了自己两巴掌，不能这么躺了。
上面当然是个笑话。
开篇 上一篇我们分析了Go原生网络模型以及部分源码，绝大部分场景下(99%)，使用原生netpoll已经足够了。
但是在一些海量并发连接下，原生netpoll会为每一个连接都开启一个goroutine处理，也就是1千万的连接就会创建一千万个goroutine。这就给了这些特殊场景下的优化空间，这也是像gnet和cloudwego/netpoll诞生的原因之一吧。
本质上他们的底层核心都是一样的，都是基于epoll(linux)实现的。
只是对事件发生后，每个库的处理方式会有所不同。
本篇文章主要分析gnet的。至于使用姿势就不发了，gnet有对应的demo库，可以自行体验。
架构 直接引用gnet官网的一张图
gnet采用的是『主从多 Reactors』。也就是一个主线程负责监听端口连接，当一个客户端连接到来时，就把这个连接根据负载均衡算法分配给其中一个sub线程，由对应的sub线程去处理这个连接的读写事件以及管理它的死亡。
下面这张图就更清晰了。
核心结构 我们先解释gnet的一些核心结构。
engine就是程序最上层的结构了。
  ln对应的listener就是服务启动后对应监听端口的监听器。
  lb对应的loadBalancer就是负载均衡器。也就是当客户端连接服务时，负载均衡器会选择一个sub线程，把连接交给此线程处理。
  mainLoop 就是我们的主线程了，对应的结构eventloop。当然我们的sub线程结构也是eventloop。结构相同，不同的是职责。主线程负责的是监听端口发生的客户端连接事件，然后再由负载均衡器把连接分配给一个sub线程。而sub线程负责的是绑定分配给他的连接(不止一个)，且等待自己管理的所有连接后续读写事件，并进行处理。
  接着看eventloop。
 netpoll.Poller:每一个 eventloop都对应一个epoll或者kqueue。 buffer用来作为读消息的缓冲区。 connCoun记录当前eventloop存储的tcp连接数。 udpSockets和connetcions分别管理着这个eventloop下所有的udp socket和tcp连接，注意他们的结构map。这里的int类型存储的就是fd。  对应conn结构，
这里面有几个字段介绍下，
 buffer:存储当前conn对端(client)发送的最新数据，比如发送了三次，那个此时buffer存储的是第三次的数据,代码里有。 inboundBuffer:存储对端发送的且未被用户读取的剩余数据，还是个Ring Buffer。 outboundBuffer:存储还未发送给对端的数据。(比如服务端响应客户端的数据，由于conn fd是不阻塞的，调用write返回不可写的时候，就可以先把数据放到这里)  conn相当于每个连接都会有自己独立的缓存空间。这样做是为了减少集中式管理内存带来的锁问题。使用Ring buffer是为了增加空间的复用性。
整体结构就这些。
核心逻辑 当程序启动时，
会根据用户设置的options明确eventloop循环的数量，也就是有多少个sub线程。再进一步说，在linux环境就是会创建多少个epoll对象。
那么整个程序的epoll对象就是count(sub)+1(main Listener)。
上图就是我说的，会根据设置的数量创建对应的eventloop,把对应的eventloop 注册到负载均衡器中。
当新连接到来时，就可以根据一定的算法(gnet提供了轮询、最少连接以及hash)挑选其中一个eventloop把连接分配给它。
我们先来看主线程，(由于我使用的是mac,所以后面关于IO多路复用，实现部分就是kqueue代码了，当然原理是一样的)
Polling就是等待网络事件到来，传递了一个闭包参数，更确切的说是一个事件到来时的回调函数，从名字可以看出，就是处理新连接的。
至于Polling函数，
逻辑很简单，一个for循环等待事件到来，然后处理事件。
主线程的事件分两种，
一种是正常的fd发生网络连接事件，
一种是通过NOTE_TRIGGER立即激活的事件。
通过NOTE_TRIGGER触发告诉你队列里有task任务，去执行task任务。
如果是正常的网络事件到来，就处理闭包函数，主线程处理的就是上面的accept连接函数。
accept连接逻辑很简单，拿到连接的fd。设置fd非阻塞模式(想想连接是阻塞的会咋么样?),然后根据负载均衡算法选择一个sub 线程，通过register函数把此连接分配给它。
register做了两件事，首先需要把当前连接注册到当前sub 线程的epoll or kqueue 对象中,新增read的flag。</description>
    </item>
    
    <item>
      <title>Go netpoll大解析</title>
      <link>https://www.syst.top/posts/go/netpoll/</link>
      <pubDate>Thu, 14 Apr 2022 10:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/netpoll/</guid>
      <description>开篇 之前简单看过一点go原生netpoll，没注意太多细节。最近从头到尾看了一遍，特写篇文章记录下。文章很长，请耐心看完，一定有所收获。
用户空间和内核空间 在linux中，经常能看到两个词语:User space(用户空间)和Kernel space (内核空间)。
简单的说， Kernel space是linux内核运行的空间，User space是用户程序运行的空间。它们之间是相互隔离的。
现代操作系统都是采用虚拟存储器。那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。空间分配如下图所示：
Kernel space可以调用系统的一切资源。User space 不能直接调用系统资源，在 Linux系统中，所有的系统资源管理都是在内核空间中完成的。比如读写磁盘文件、分配回收内存、从网络接口读写数据等等。应用程序无法直接进行这样的操作，但是用户程序可以通过内核提供的接口来完成这样的任务。比如像下面这样，
应用程序要读取磁盘上的一个文件，它可以向内核发起一个 “系统调用” 告诉内核：”我要读取磁盘上的某某文件”。其实就是通过一个特殊的指令让进程从用户态进入到内核态，在内核空间中，CPU 可以执行任何的指令，当然也包括从磁盘上读取数据。具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并且拿到了想要的数据，继续往下执行用户空间执行逻辑。
这样的话，一旦涉及到对I/O的处理，就必然会涉及到在用户态和内核态之间来回切换。
io模型 网上有太多关于I/O模型的文章，看着看着有可能就跑偏了，所以我还是从 &amp;laquo;UNIX 网络编程&amp;raquo; 中总结的5中I/O模型说起吧。
Unix可用的5种I/O模型。
 阻塞I/O 非阻塞I/O I/O复用 信号驱动式I/O(SIGIO) 异步I/O(POSIX的aio_系列函数)  阻塞I/O 阻塞式I/O下，进程调用recvfrom，直到数据到达且被复制到应用程序的缓冲区中或者发生错误才返回，在整个过程进程都是被阻塞的。
非阻塞I/O 从图中可以看出，前三次调用recvfrom中没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用程序缓冲区，于是recvfrom成功返回。
当一个应用程序像这样对一个非阻塞描述符循环调用recvfrom时，我们通常称为轮询(polling)，持续轮询内核，以这种方式查看某个操作是否就绪。
I/O多路复用 有了I/O多路复用(I/O multiplexing)，我们就可以调用 select 或者 poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。
上面这句话难理解是吧，说白了这里指的是，在第一步中，我们只是阻塞在select调用上，直到数据报套接字变为可读，返回可读条件，这里并没有发生I/O事件，所以说这一步，并没有阻塞在真正的I/O系统调用上。
其他两种就不过多介绍了。
还有一点，我们会经常提到同步I/O和异步I/O。
POSIX 把这两种术语定义如下:
 同步I/O操作(synchronous I/O opetation) 导致请求进程被阻塞，直到I/O操作完成。 异步I/O(asynchronous opetation) 不导致请求进程被阻塞。  基于上面的定义，
异步I/O的关键在于第二步的recrfrom是否会阻塞住用户进程，如果不阻塞，那它就是异步I/O。从上面汇总图中可以看出，只有异步I/O满足POSIX中对异步I/O的定义。
Go netpoller Go netpoller 底层就是对I/O多路复用的封装。不同平台对I/O多路复用有不同的实现方式。比如Linux的select、poll和epoll(具体差别不是很明白可以看这篇)。在MacOS则是kqueue,而Windows是基于异步I/O实现的icop&amp;hellip;&amp;hellip;，基于这些背景，Go针对不同的平台调用实现了多版本的netpoller。
下面我们通过一个demo开始讲解。
很简单一个demo，开启一个tcp服务。然后每来一个连接，就启动一个g去处理连接。处理完毕，关闭连接。
而且我们使用的是同步的模式去编写异步的逻辑，一个连接对应一个g处理，极其简单和易于理解。go标准库中的http.server也是这么干的。</description>
    </item>
    
    <item>
      <title>一个用go实现的有限状态机 </title>
      <link>https://www.syst.top/posts/go/easyfsm/</link>
      <pubDate>Sun, 06 Mar 2022 17:37:22 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/easyfsm/</guid>
      <description>easyfsm 之前看过新亮老哥的go-fsm-order，感觉还不错。最近在迁移项目的时候，发现有多处业务存在一些状态的流转，所以就基于go-fsm-order做了重改，让它可以在不同的业务场景下使用。
为什么不使用looplab/fsm，star挺多的啊。
不是特别喜欢，每次实例化fsm都需要重新传递对应events(虽然我们可以统一封装)，我更期望在项目启动时把此项目涉及到不同业务状态机流转注册到fsm，对应:不同业务-&amp;gt;[状态]-&amp;gt;[事件]-&amp;gt;处理事件主体(包含handler、params、hooks、observers等)。
当你开始进行状态流转时，只需要
fsm:=NewFsm(&amp;#34;业务名称&amp;#34;,&amp;#34;当前状态&amp;#34;) currentState,err:=fsm.Call(&amp;#34;事件名称&amp;#34;,&amp;#34;对应事件所需参数可选项&amp;#34;) 为什么需要区分业务？
因为绝大多数业务的状态值都是从数据库中获取的，比如订单表的订单状态，商品表中的商品状态，有可能值是相同的。
同一个业务同一属性对应状态值表达单一，不同业务下属性状态可能会出现值相同，但所表达的含义是不同的。
整体设计:
简单解释一下：
 业务:比如有商品状态业务、订单状态业务&amp;hellip;.. 状态：订单待付款、待发货&amp;hellip;. 事件：对应状态仅可达事件集合。比如待付款状态的可达事件仅有:支付事件和取消事件(取决于自己的业务) 执行事件主体：执行自定义的事件函数,如果有需要，还可以自定义执行事件前后hook，事件订阅者(比如支付事件发生后，异步通知用户等)  使用姿势 go get -u github.com/wuqinqiang/easyfsm 首先自定义业务、状态、事件。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/wuqinqiang/easyfsm&amp;#34; ) var ( // 业务 	businessName easyfsm.BusinessName = &amp;#34;order&amp;#34; // 对应状态 	initState easyfsm.State = 1 // 初始化 	paidState easyfsm.State = 2 // 已付款 	canceled easyfsm.State = 3 // 已取消  //对应事件 	paymentOrderEvent easyfsm.EventName = &amp;#34;paymentOrderEvent&amp;#34; cancelOrderEvent easyfsm.</description>
    </item>
    
    <item>
      <title>你还不体验泛型吗</title>
      <link>https://www.syst.top/posts/go/generics/</link>
      <pubDate>Sun, 02 Jan 2022 18:32:00 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/generics/</guid>
      <description>介绍 之前有看过官方发布的一些泛型文章，但是自己没动手玩过。还有没有没玩过的，那么最后一班车了。
不管学什么入门先从官网拿例子。
这段代码很简单，定义两个函数，计算对应传入的map值的和。两个函数最大的不同在于函数参数类型有所不同，一个map的值类型为int64,一个为float64，对应返回参数也有所不同。
在没有泛型的情况下，每种类型都不得不重新定义一个函数。
有人可能会说，上面的代码你可以这样写在一个函数里，
你确认这真的好吗？
泛型函数 但是，有了泛型之后，那就简单多了。
上面这段代码中，
定义了一个新函数SumIntsOrFloats，该函数声明两个类型参数 [K comparable, V int64 | float64]。其中K指定了类型必须为可比较(即可以用作比较符 == 和 !=)。因为 go中规定map的key必须是可比较类型。
比如，我们不能这样声明一个map。
所以这里的K就不能使用any关键字。
另一个V参数指定了一个约束，该约束由int64和float64组成，使用 | 指定了联合类型。
所以这里m参数为map[K]V类型，K,V即为参数类型指定的类型。
那么，如果你传入的map值的类型为其他类型。比如下面这种就不行了。
类型约束 上面看到的是我们在方法上对参数做一些约束。当然我们也可以直接声明类型约束。
上面的代码声明了一个Number用做类型约束的接口类型。在接口里声明int64和float64联合类型。
在SumNumbers中如果约束类型为int64或者 float64，那么只需要使用Number类型约束即可，就不用每个不同函数写 int64 | float64，达到代码复用的效果。
但是如果我这样，
我们把map中的值类型调整为自定义的otherInt64类型，otherInt64的基础类型也是int64。但是，这段代码编译会报错。
原因是 int64 约束会将其限制为只能是该类型，也就是只能是 int64，不能是基于此类型定义的其他类型。
如果想使用otherInt64咋么办，很简单，只需要一个～符号，
使用带～xxtype会将其限制为基础类型为xxtype的所有类型。
应用 上面只是简单介绍了一下使用姿势，那么哪些场景下可以使用泛型呢？
比如日常开发中，像slice、map、channel的一些处理函数，可能逻辑相同但是类型不同导致copy多个不同函数，这时候可以用泛型解决。比如，
还有一些行为方面的。比如 go 中的排序，通过泛型，不需要每一个结构都实现(Len，Less，Swap)三个方法，而是抽象出依赖于三个方法的行为。那么想要实现排序只需要依赖定义的这个抽象就行了。
其他方面的应用可以自行体验。
总结 这篇文章主要带你们体验下泛型的基本使用，以及对应的类型约束，最后还简单实验了两个泛型的场景demo，感兴趣的可以自行体验。更多内容，欢迎留言区域交流。
附录  https://go.dev/doc/tutorial/generics https://teivah.medium.com/when-to-use-generics-in-go-36d49c1aeda https://github.com/mattn/go-generics-example  </description>
    </item>
    
    <item>
      <title>那些用Go实现的分布式事务框架</title>
      <link>https://www.syst.top/posts/go/transaction/</link>
      <pubDate>Wed, 08 Dec 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/transaction/</guid>
      <description>开篇 不知不觉竟然一个月没更新了，人一旦懒下来只会越来越懒。
最近对分布式事务产生了一些兴趣，查阅了一些文章以及论文。这篇文章主要介绍我看的两个项目，不涉及一些理论知识。
 阿里开源版本的Seata，主要看了Go实现的seata-golang(落后java版) 以及前段时间很多公众号都发的dtm。  Seata简介 Seata是由阿里开源的分布式事务服务，目前为用户提供了AT、TCC、SAGA、XA的事务模式，整体采用的是两阶段提交协议。Go版的seata-golang 目前好像只实现了mysql的AT、TCC模式，作者现在不咋更新了。
Seata 有几个核心角色：
 TC(Transaction Coordinator) -事务协调者。(维护全局和分支事务的状态，驱动全局事务提交或回滚) TM(Transaction Manager)-事务管理器。(定义全局事务的范围：开始全局事务、提交或回滚全局事务。) RM(Resource Manager)-资源管理器。(管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚)  当然这样看，可能还不是很理解，我拿一张官网的图加以解释。
从上图中可以看出，这三个角色所负责的工作如下，
TC
 维护全局和分支事务状态，需要进行存储。 当一个分布式事务处理结束，需要通知到每个RM是commit还是rollback。  TM
 向TC请求开启一个分布式事务，得到一个全局唯一的分布式id。 根据每个参与分布式事务的RM一阶段的反馈，决定二阶段向TC请求此次分布式事务是commit还是rollback(绝大部分场景下，一阶段任一RM失败，本次分布式事务失败)  RM
说的白一点就是管理参与分布式事务的各个服务(比如经典下单场景中涉及到的:订单服务、库存服务、营销服务等)
ps:个人感觉，这里的RM有点类似微服务中的中间处理层(专业术语他们管这叫bff-&amp;gt;backend for fronted)。
  一阶段 prepare 行为(主动)：每个RM调用 自定义 的 prepare 逻辑。
  二阶段 commit 行为(被动触发)：如果本次分布式事务第一阶段全部RM成功，TC处理完自身状态变更后，调用各个RM自定义 的 commit 逻辑。(一阶段RM全部成功)
  二阶段 rollback 行为(被动触发)：如果本次分布式事务第一阶段任一RM失败，TC处理完自身状态变更后，调用各个RM自定义 的 rollback 逻辑。(一阶段任意RM失败)
  好了。下面可以看看seata-golang 实现的一些细节了，seata-golang 底层采用gRPC进行通信。
seata-golang 我们先看RM部分结构。</description>
    </item>
    
    <item>
      <title>那些用Go实现的分布式事务框架(2)</title>
      <link>https://www.syst.top/posts/go/transaction2/</link>
      <pubDate>Wed, 08 Dec 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/transaction2/</guid>
      <description>开篇 上一篇我们主要介绍的是seata-golang。一个对标seata的go语言实现，当然版本还是落后Java版很多的。
这次我们来介绍一下另一个go实现的分布式事务:dtm。
首先来看下dtm整体架构图(来源官网)。
再来看之前的seata架构图。
从架构上来看，大差不差。
seata中的TC对标dam的TM。
RM两边意思一致。
seata中的TM对标dtm事务SDK。作用都是一样:第一阶段开启一个全局事务,执行各RM分支事务，第二阶段根据RM第一阶段执行结果，决定调用TC(seata)|TM(dtm) commit或者rollback。
架构上，个人感觉只是因为模块名称以及图画不一样的差别。
当然在实现细节上还是有很大差别的。
我们先简单介绍下DTM各个模块。
TM TM 层在代码中是没有具体的主体结构的，开始都是函数之前的调用。
启动TM实际上开启了两个服务，http以及grpc这两个服务。
// StartSvr StartSvr func StartSvr() { app := common.GetGinApp() app = httpMetrics(app) addRoute(app) dtmimp.Logf(&amp;#34;dtmsvr listen at: %d&amp;#34;, common.DtmHttpPort) go app.Run(fmt.Sprintf(&amp;#34;:%d&amp;#34;, common.DtmHttpPort)) lis, err := net.Listen(&amp;#34;tcp&amp;#34;, fmt.Sprintf(&amp;#34;:%d&amp;#34;, common.DtmGrpcPort)) dtmimp.FatalIfError(err) s := grpc.NewServer( grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer( grpc.UnaryServerInterceptor(grpcMetrics), grpc.UnaryServerInterceptor(dtmgimp.GrpcServerLog)), )) dtmgimp.RegisterDtmServer(s, &amp;amp;dtmServer{}) dtmimp.Logf(&amp;#34;grpc listening at %v&amp;#34;, lis.Addr()) go func() { err := s.Serve(lis) dtmimp.FatalIfError(err) }() go updateBranchAsync() // 省略代码 } http路由，</description>
    </item>
    
  </channel>
</rss>
