<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>enum on 记得</title>
    <link>https://www.syst.top/tags/enum/</link>
    <description>Recent content in enum on 记得</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 25 Apr 2021 22:25:52 +0800</lastBuildDate><atom:link href="https://www.syst.top/tags/enum/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>iota 在 Go 中的使用 </title>
      <link>https://www.syst.top/posts/go/enum/</link>
      <pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/enum/</guid>
      <description>介绍 Go 语言实际上没有直接支持枚举的关键字。一般我们都是通过 const + iota 实现枚举的能力。
有人要问了，为什么一定要使用枚举呢？stackoverflow 上有一个高赞的回答，如下:
You should always use enums when a variable (especially a method parameter) can only take one out of a small set of possible values. Examples would be things like type constants (contract status: &amp;quot;permanent&amp;quot;, &amp;quot;temp&amp;quot;, &amp;quot;apprentice&amp;quot;), or flags (&amp;quot;execute now&amp;quot;, &amp;quot;defer execution&amp;quot;). If you use enums instead of integers (or String codes), you increase compile-time checking and avoid errors from passing in invalid constants, and you document which values are legal to use.</description>
    </item>
    
    <item>
      <title>原来sync.Once还能这么用</title>
      <link>https://www.syst.top/posts/go/synconce/</link>
      <pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/synconce/</guid>
      <description>介绍 sync.Once估计大家都不陌生，官方介绍中，
 Once is an object that will perform exactly one action
 正是因为这个特性，Once常常被用于单例对象的初始化场景。
也正是因为这个特性，其实它还能做一些其他的事情。
缓存击穿 日常背诵八股文，我相信你们对缓存击穿这个词特别熟悉。
缓存击穿一般待指热点key缓存失效(到期|删了)，同一时刻大量对热点key的并发请求。缓存找不到数据，所有请求都打入到DB层。此时，身为开发的你，明天和意外就不知道哪个先到了。
为了防止这种情况发生，针对相同key的请求，只需要一个请求(A)到达DB层取数据，其他请求等待A通知就行了。
就像这样，
​ 图片来源:caching
singleflight Go里有很多防缓存击穿的工具，比如singleflight库。
type call struct { wg sync.WaitGroup val interface{} err error forgotten bool //.....省略部分字段 } type Group struct { mu sync.Mutex m map[string]*call } 通过上面简单的代码大概能看出，其实就是对key做了缓存。
把一个key对应call结构存储在map中。保证只有一个key真正执行fn()服务 ，其他请求则通过sync.waitGroup的wait等待结果。
至于g.docall(c,key,fn)，
当带着全村人希望的那个请求，获取到数据，给对应key的call赋值，最终执行done，通知等待这个key全村的村民获取数据。
代码并不复杂。
自定义singleflight 我们也可以实现一个简易版本的。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) type CacheEntry struct { data []byte err error wait chan struct{} } type OrderSever struct { cache map[string]*CacheEntry mutex sync.</description>
    </item>
    
    <item>
      <title>推荐两款go开发中提高效率工具</title>
      <link>https://www.syst.top/posts/go/go-tool/</link>
      <pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/go-tool/</guid>
      <description>介绍 推荐两款 go 开发中用的还行的工具。
为什么推荐工具？是为了让评论区的大佬介绍其他更好用的工具，解放我的双手。
顺便问问，有没有只说话就能自动打完代码的工具？
JSON-To-Stuct 这个工具可以把 json 格式的数据转换成 go 的 struct。比如你在对接第三方的时候，就不需要根据对方的接口一个个定义 struct 字段。下面示例复制的微信小商店商品 json 数据到网站的左框即可，当然自己还是需要做一些局部的调整。
其实这个功能 21 版的 goland 也支持了。在 goland 中你只需要这样,
Table-To-Stuct 被业务缠身的同学每天免不了 CURD。CURD 之前总得建表吧。建表之后总得在代码中定义模型吧。总不能又一个个字段定义，那么下面这个工具可能管用。
假设你有一个库 dream，库里有一个表 category，结构如下，
CREATE TABLE `category` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(20) NOT NULL DEFAULT &amp;#39;&amp;#39;, `parent_id` int(11) unsigned NOT NULL DEFAULT &amp;#39;0&amp;#39;, `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`) ) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4; 你只需引入包 github.</description>
    </item>
    
    <item>
      <title>无限缓冲的channel(1)</title>
      <link>https://www.syst.top/posts/go/unlimited/</link>
      <pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/unlimited/</guid>
      <description>介绍 事情的起因是前几周看到鸟窝写了一篇关于实现无限缓冲 channel 的文章，当时忙着和小姐姐聊天没看，今天想起来了。
不过这篇文章不会涉及到鸟窝自己实现的 chanx，我们会在下一篇提到。
我们都知道，channel 有两种类型:无缓冲和有缓冲的。
当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。
有时候，我们并不知道也无法预估写入通道的数量规模。如果此时通道的写入速度远远超过读取速度，那么必然会在某个时间点塞满通道，导致写入阻塞。 比如之前我翻译的一篇文章 使用 Go 每分钟处理百万请求 中，作者就出现处理速度太慢，导致通道塞满，其他请求被阻塞，响应时间慢慢增加。
此时有人就会提到，能不能提供一个无限缓冲(Unbounded or Unlimited)的通道。
这个问题早在 2017 年就有人提过 issues，最终 go 官方没有实现这个提案。
不过，这个 issues 下面总共产生了 67 个 comments，评论很精彩。 比如有人提到:
cznic:Unlimited capacity channels ask for a machine with unlimited memory. rsc:The limited capacity of channels is an important source of backpressure in a set of communicating goroutines. It is typically a mistake to use an unbounded channel, because you lose that backpressure.</description>
    </item>
    
    <item>
      <title>无限缓冲的channel(2)</title>
      <link>https://www.syst.top/posts/go/unlimited-2/</link>
      <pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/unlimited-2/</guid>
      <description>chanx 上篇文章我们提到，当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。 由此引发了关于无限缓存的 channel 话题讨论。 我们分析了一个实现无限缓冲的代码。 最后，我们也提到了它还可以继续优化的点。
鸟窝的 chanx 正是基于此方案改造而成的，我们来看看他俩的不同之处。
上篇文章说过，所谓的无限缓冲，无非是借助一个中间层的数据结构，暂存临时数据。
在 chanx 中，结构是这样的:
type UnboundedChan struct { In chan&amp;lt;- T // channel for write 	Out &amp;lt;-chan T // channel for read 	buffer *RingBuffer // buffer } in 和 out 的职责在上篇文章已经说明，这里的 buffer 就是我们所谓的中间临时存储层。其中的 RingBuffer 结构我们后面再说。
func NewUnboundedChan(initCapacity int) UnboundedChan { return NewUnboundedChanSize(initCapacity, initCapacity, initCapacity) } func NewUnboundedChanSize(initInCapacity, initOutCapacity, initBufCapacity int) UnboundedChan { in := make(chan T, initInCapacity) out := make(chan T, initOutCapacity) ch := UnboundedChan{In: in, Out: out, buffer: NewRingBuffer(initBufCapacity)} go process(in, out, ch) return ch } 它提供了两个初始化 UnboundedChan 的方法，从代码中我们可以明显的看出,NewUnboundedChanSize 可以给每个属性自定义自己的容量大小。仅此而已。</description>
    </item>
    
  </channel>
</rss>
