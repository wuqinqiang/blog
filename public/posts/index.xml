<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 记得</title>
		<link>https://www.syst.top/posts/</link>
		<description>Recent content in Posts on 记得</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Tue, 27 Jul 2021 10:01:52 +0800</lastBuildDate>
		<atom:link href="https://www.syst.top/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>超实用的 gRPC 客户端调试工具</title>
			<link>https://www.syst.top/posts/go/grpc/</link>
			<pubDate>Tue, 27 Jul 2021 10:01:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/grpc/</guid>
			<description>介绍 正好看到董泽润老哥写了一篇关于使用 WireShark 分析 gRPC 流量的文章，学到了。
那我就介绍两个日常开发使用过的两款 gRPC 客户端调试工具吧。
Evans Evans 有两种模式：REPL 和 CLI。比起其他 gRPC 客户端,更具有表现力。并且它还支持自动补全功能。
它的安装非常方便，在 Mac 上我们只需要执行以下两行命令即可。
$ brew tap ktr0731/evans $ brew install evans 我们来操作一下 REPL 模式。
首先我们需要有一个 pb 文件，假设你的文件在 api/api.proto，我们只需要这样： 默认地址为 127.0.0.1:50051，当然你可以通过 --host 和 --port 来指定服务器。 上图的命令:
 show package 读取 pb 包名， show service 显示对应服务列表。 call xxx 调用 grpc 服务&amp;hellip;&amp;hellip; &amp;hellip;..  更多命令可自行查阅官网。
除了上述这种直接引入 pb 文件外，我们还可以通过 gRPC 反射包(reflection)， 将 grpc.Server 注册到反射服务中, 这样的话，就可以通过 reflection 提供的反射服务查询到对应的 gRPC 服务或者调用 gRPC 服务。</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>正好看到董泽润老哥写了一篇关于使用 <code>WireShark</code> 分析 <code>gRPC</code> 流量的文章，学到了。</p>
<p>那我就介绍两个日常开发使用过的两款 <code>gRPC</code> 客户端调试工具吧。</p>
<h2 id="evans">Evans</h2>
<p><code>Evans</code> 有两种模式：<code>REPL</code> 和 <code>CLI</code>。比起其他 <code>gRPC</code> 客户端,更具有表现力。并且它还支持自动补全功能。</p>
<p>它的安装非常方便，在 <code>Mac</code> 上我们只需要执行以下两行命令即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">$</span> <span class="nx">brew</span> <span class="nx">tap</span> <span class="nx">ktr0731</span><span class="o">/</span><span class="nx">evans</span>
<span class="err">$</span> <span class="nx">brew</span> <span class="nx">install</span> <span class="nx">evans</span>
</code></pre></div><p>我们来操作一下 <code>REPL</code> 模式。</p>
<p>首先我们需要有一个 <code>pb</code> 文件，假设你的文件在 <code>api/api.proto</code>，我们只需要这样：
<img src="https://image.syst.top/image/grpc/1.gif" alt="image"></p>
<p>默认地址为 <code>127.0.0.1:50051</code>，当然你可以通过 <code>--host</code> 和 <code>--port</code> 来指定服务器。
<img src="https://image.syst.top/image/grpc/2.png" alt="image"></p>
<p>上图的命令:</p>
<ul>
<li><code>show package</code> 读取 <code>pb</code> 包名，</li>
<li><code>show service</code> 显示对应服务列表。</li>
<li><code>call xxx</code> 调用 <code>grpc</code> 服务&hellip;&hellip;</li>
<li>&hellip;..</li>
</ul>
<p>更多命令可自行查阅官网。</p>
<p>除了上述这种直接引入 <code>pb</code> 文件外，我们还可以通过 <code>gRPC</code> 反射包(<code>reflection</code>)， 将 <code>grpc.Server</code> 注册到反射服务中,
这样的话，就可以通过 <code>reflection</code> 提供的反射服务查询到对应的 <code>gRPC</code> 服务或者调用 <code>gRPC</code> 服务。</p>
<p>操作起来很简单，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
<span class="s">&#34;google.golang.org/grpc&#34;</span>
<span class="s">&#34;google.golang.org/grpc/reflection&#34;</span>
<span class="p">)</span>
	<span class="nx">grpcServer</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>
	<span class="nx">reflection</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">grpcServer</span><span class="p">)</span>
</code></pre></div><p>回到 <code>Evans</code> 工具， 如果一个 <code>gRPC</code> 服务启动了反射，我们就可以使用 <code>-r (--reflection)</code> 选项来启动 <code>Evans</code>。</p>
<p>比如像下面这样：
<img src="https://image.syst.top/image/grpc/3.gif" alt="image"></p>
<h3 id="bloomrpc">BloomRPC</h3>
<p><code>BloomRPC</code> 是一个简单的<code>GUI</code> 客户端工具，使用这个那就更简单了。</p>
<p>只需要导入 <code>pb</code> 文件，然后点两下即可。
<img src="https://image.syst.top/image/grpc/4.gif" alt="image"></p>
<p>当然有个不好点在于，每次修改了 <code>pb</code>，都不得不重新导入。</p>
<h3 id="总结">总结</h3>
<p>以上介绍了两款 <code>gRPC</code> 客户端工具。不知道你们平常都使用 <code>gRPC</code> 哪些周边工具，欢迎一起讨论。当然调试工具再好，改写的 <code>test</code> 还是逃不了。</p>
]]></content>
		</item>
		
		<item>
			<title>go并发-工作池模式</title>
			<link>https://www.syst.top/posts/go/worker-pool/</link>
			<pubDate>Thu, 01 Jul 2021 23:37:45 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/worker-pool/</guid>
			<description>开篇 之前写过一篇文章，它有个响亮的名字: Handling 1 Million Requests per Minute with Go。 这是国外的一个作者写的，我做了一篇说明。起的也是这个标题， 阅读量是我最好的一篇，果然文章都是靠标题出彩的&amp;hellip;..
今天偶然看到另一篇文章(原文在文末)。两篇文章原理相似:有一批工作任务(job)，通过工作池(worker-pool)的方式，达到多 worker 并发处理 job 的效果。
他们还是有很多不同的点，实现上差别也是蛮大的。
首先上一篇文章我放了一张图片，大概就是上篇整体的工作流。  每个 worker 处理完任务就好，不关心结果,不对结果做进一步处理。 只要请求不停止，程序就不会停止，没有控制机制，除非宕机。  这篇文章不同点在于:
首先数据会从 generate (生产数据)-&amp;gt;并发处理数据-&amp;gt;处理结果聚合。 图大概是这样的, 然后它可以通过 context.context 达到控制工作池停止工作的效果。
最后通过代码，你会发现它不是传统意义上的 worker-pool，后面会说明。
下图能清晰表达整体流程了。 顺便说一句，这篇文章实现的代码比 Handling 1 Million Requests per Minute with Go 的代码简单多了。
首先看 job。
package wpool import ( &amp;#34;context&amp;#34; ) type JobID string type jobType string type jobMetadata map[string]interface{} type ExecutionFn func(ctx context.Context, args interface{}) (interface{}, error) type JobDescriptor struct { ID JobID JType jobType Metadata map[string]interface{} } type Result struct { Value interface{} Err error Descriptor JobDescriptor } type Job struct { Descriptor JobDescriptor ExecFn ExecutionFn Args interface{} } // 处理 job 逻辑,处理结果包装成 Result 结果 func (j Job) execute(ctx context.</description>
			<content type="html"><![CDATA[<h3 id="开篇">开篇</h3>
<p>之前写过一篇文章，它有个响亮的名字: <code>Handling 1 Million Requests per Minute with Go</code>。
这是国外的一个作者写的，我做了一篇说明。起的也是这个标题，
阅读量是我最好的一篇，果然文章都是靠标题出彩的&hellip;..</p>
<p>今天偶然看到另一篇文章(原文在文末)。两篇文章原理相似:有一批工作任务(job)，通过工作池(worker-pool)的方式，达到多 <code>worker</code> 并发处理 <code>job</code> 的效果。</p>
<p>他们还是有很多不同的点，实现上差别也是蛮大的。</p>
<p>首先上一篇文章我放了一张图片，大概就是上篇整体的工作流。
<img src="https://image.syst.top/image/work-pool.png" alt="image"></p>
<ul>
<li>每个 <code>worker</code> 处理完任务就好，不关心结果,不对结果做进一步处理。</li>
<li>只要请求不停止，程序就不会停止，没有控制机制，除非宕机。</li>
</ul>
<p>这篇文章不同点在于:</p>
<p>首先数据会从 <code>generate</code> (生产数据)-&gt;并发处理数据-&gt;处理结果聚合。
图大概是这样的,
<img src="https://image.syst.top/image/out.png" alt="image"></p>
<p>然后它可以通过 <code>context.context</code> 达到控制工作池停止工作的效果。</p>
<p>最后通过代码，你会发现它不是传统意义上的 <code>worker-pool</code>，后面会说明。</p>
<p>下图能清晰表达整体流程了。
<img src="https://image.syst.top/image/work-pool-2.png" alt="image"></p>
<p>顺便说一句，这篇文章实现的代码比 <code>Handling 1 Million Requests per Minute with Go</code> 的代码简单多了。</p>
<p>首先看 <code>job</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">wpool</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">JobID</span> <span class="kt">string</span>
<span class="kd">type</span> <span class="nx">jobType</span> <span class="kt">string</span>
<span class="kd">type</span> <span class="nx">jobMetadata</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">ExecutionFn</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">args</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">type</span> <span class="nx">JobDescriptor</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span>       <span class="nx">JobID</span> 
	<span class="nx">JType</span>    <span class="nx">jobType</span>
	<span class="nx">Metadata</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Result</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Value</span>      <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">Err</span>        <span class="kt">error</span>
	<span class="nx">Descriptor</span> <span class="nx">JobDescriptor</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Job</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Descriptor</span> <span class="nx">JobDescriptor</span>
	<span class="nx">ExecFn</span>     <span class="nx">ExecutionFn</span>
	<span class="nx">Args</span>       <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 处理 job 逻辑,处理结果包装成 Result 结果
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="nx">Job</span><span class="p">)</span> <span class="nf">execute</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="nx">Result</span> <span class="p">{</span>
	<span class="nx">value</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">j</span><span class="p">.</span><span class="nf">ExecFn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">j</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">Result</span><span class="p">{</span>
			<span class="nx">Err</span><span class="p">:</span>        <span class="nx">err</span><span class="p">,</span>
			<span class="nx">Descriptor</span><span class="p">:</span> <span class="nx">j</span><span class="p">.</span><span class="nx">Descriptor</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">Result</span><span class="p">{</span>
		<span class="nx">Value</span><span class="p">:</span>      <span class="nx">value</span><span class="p">,</span>
		<span class="nx">Descriptor</span><span class="p">:</span> <span class="nx">j</span><span class="p">.</span><span class="nx">Descriptor</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这个可以简单过一下。最终每个 <code>job</code> 处理完都会包装成 <code>Result</code> 返回。</p>
<p>下面这段就是核心代码了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">wpool</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="c1">// 运行中的每个worker
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">jobs</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">results</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Result</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">job</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">jobs</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">results</span> <span class="o">&lt;-</span> <span class="nx">job</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;cancelled worker. Error detail: %v\n&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
			<span class="nx">results</span> <span class="o">&lt;-</span> <span class="nx">Result</span><span class="p">{</span>
				<span class="nx">Err</span><span class="p">:</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">(),</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">WorkerPool</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">workersCount</span> <span class="kt">int</span> <span class="c1">//worker 数量
</span><span class="c1"></span>	<span class="nx">jobs</span>         <span class="kd">chan</span> <span class="nx">Job</span> <span class="c1">// 存储 job 的 channel 
</span><span class="c1"></span>	<span class="nx">results</span>      <span class="kd">chan</span> <span class="nx">Result</span> <span class="c1">// 处理完每个 job 对应的 结果集
</span><span class="c1"></span>	<span class="nx">Done</span>         <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">//是否结束
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">wcount</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">WorkerPool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">WorkerPool</span><span class="p">{</span>
		<span class="nx">workersCount</span><span class="p">:</span> <span class="nx">wcount</span><span class="p">,</span>
		<span class="nx">jobs</span><span class="p">:</span>         <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">wcount</span><span class="p">),</span>
		<span class="nx">results</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Result</span><span class="p">,</span> <span class="nx">wcount</span><span class="p">),</span>
		<span class="nx">Done</span><span class="p">:</span>         <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">workersCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">,</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span><span class="p">,</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">results</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">Done</span><span class="p">)</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">results</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">Results</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Result</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">results</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">GenerateFrom</span><span class="p">(</span><span class="nx">jobsBulk</span> <span class="p">[]</span><span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">jobsBulk</span> <span class="p">{</span>
		<span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span> <span class="o">&lt;-</span> <span class="nx">jobsBulk</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p>整个 <code>WorkerPool</code> 结构很简单。 <code>jobs</code> 是一个缓冲 <code>channel</code>。每一个任务都会放入 <code>jobs</code> 中等待处理 <code>woker</code> 处理。</p>
<p><code>results</code> 也是一个通道类型，它的作用是保存每个 <code>job</code> 处理后产生的结果 <code>Result</code>。</p>
<p>首先通过 <code>New</code> 初始化一个 <code>worker-pool</code> 工作池,然后执行 <code>Run</code> 开始运行。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">wcount</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">WorkerPool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">WorkerPool</span><span class="p">{</span>
		<span class="nx">workersCount</span><span class="p">:</span> <span class="nx">wcount</span><span class="p">,</span>
		<span class="nx">jobs</span><span class="p">:</span>         <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">wcount</span><span class="p">),</span>
		<span class="nx">results</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Result</span><span class="p">,</span> <span class="nx">wcount</span><span class="p">),</span>
		<span class="nx">Done</span><span class="p">:</span>         <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">workersCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">,</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span><span class="p">,</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">results</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">Done</span><span class="p">)</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">results</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>初始化的时候传入 <code>worker</code> 数，对应每个 <code>g</code> 运行 <code>work(ctx,&amp;wg,wp.jobs,wp.results)</code>,组成了 <code>worker-pool</code>。
同时通过 <code>sync.WaitGroup</code>,我们可以等待所有 <code>worker</code> 工作结束，也就意味着 <code>work-pool</code> 结束工作，当然可能是因为任务处理结束，也可能是被停止了。</p>
<p>每个 <code>job</code> 数据源是如何来的？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// job数据源，把每个 job 放入到 jobs channel 中
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">GenerateFrom</span><span class="p">(</span><span class="nx">jobsBulk</span> <span class="p">[]</span><span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">jobsBulk</span> <span class="p">{</span>
		<span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span> <span class="o">&lt;-</span> <span class="nx">jobsBulk</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>对应每个 <code>worker</code> 的工作，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">jobs</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">results</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Result</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">job</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">jobs</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">results</span> <span class="o">&lt;-</span> <span class="nx">job</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;cancelled worker. Error detail: %v\n&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
			<span class="nx">results</span> <span class="o">&lt;-</span> <span class="nx">Result</span><span class="p">{</span>
				<span class="nx">Err</span><span class="p">:</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">(),</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>每个 worker 都尝试从同一个 <code>jobs</code> 获取数据，这是一个典型的 <code>fan-out</code> 模式。
当对应的 <code>g</code> 获取到 <code>job</code> 进行处理后，会把处理结果发送到同一个 <code>results channel</code> 中,这又是一个 <code>fan-in</code> 模式。
当然我们通过 <code>context.Context</code> 可以对每个 <code>worker</code> 做停止运行控制。</p>
<p>最后是处理结果集合，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 处理结果集
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">Results</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Result</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">results</span>
<span class="p">}</span>
</code></pre></div><p>那么整体的测试代码就是:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestWorkerPool</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">wp</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="nx">workerCount</span><span class="p">)</span>

	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">TODO</span><span class="p">())</span>
	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>

	<span class="k">go</span> <span class="nx">wp</span><span class="p">.</span><span class="nf">GenerateFrom</span><span class="p">(</span><span class="nf">testJobs</span><span class="p">())</span>

	<span class="k">go</span> <span class="nx">wp</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">wp</span><span class="p">.</span><span class="nf">Results</span><span class="p">():</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>

			<span class="nx">i</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Descriptor</span><span class="p">.</span><span class="nx">ID</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;unexpected error: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="nx">val</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">val</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;wrong value %v; expected %v&#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">wp</span><span class="p">.</span><span class="nx">Done</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>看了代码之后，我们知道，这并不是一个传统意义的 <code>worker-pool</code>。它并不像 <code>Handling 1 Million Requests per Minute with Go</code> 这篇文章一样，
初始化一个真正的 <code>worker-pool</code>，一旦接收到 <code>job</code>,就尝试从池中获取一个 <code>worker</code>，
把对应的 <code>job</code> 交给这个 <code>work</code> 进行处理，等 <code>work</code> 处理完毕，重新进行到工作池中，等待下一次被利用。</p>
]]></content>
		</item>
		
		<item>
			<title>iota 在 Go 中的使用 </title>
			<link>https://www.syst.top/posts/go/enum/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/enum/</guid>
			<description>介绍 Go 语言实际上没有直接支持枚举的关键字。一般我们都是通过 const + iota 实现枚举的能力。
有人要问了，为什么一定要使用枚举呢？stackoverflow 上有一个高赞的回答，如下:
You should always use enums when a variable (especially a method parameter) can only take one out of a small set of possible values. Examples would be things like type constants (contract status: &amp;quot;permanent&amp;quot;, &amp;quot;temp&amp;quot;, &amp;quot;apprentice&amp;quot;), or flags (&amp;quot;execute now&amp;quot;, &amp;quot;defer execution&amp;quot;). If you use enums instead of integers (or String codes), you increase compile-time checking and avoid errors from passing in invalid constants, and you document which values are legal to use.</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>Go 语言实际上没有直接支持枚举的关键字。一般我们都是通过 <code>const</code> + <code>iota</code> 实现枚举的能力。</p>
<p>有人要问了，为什么一定要使用枚举呢？<code>stackoverflow</code> 上有一个高赞的回答，如下:</p>
<pre><code>You should always use enums when a variable (especially a method parameter) can only take one out of a small set of possible values. Examples would be things like type constants (contract status: &quot;permanent&quot;, &quot;temp&quot;, &quot;apprentice&quot;), or flags (&quot;execute now&quot;, &quot;defer execution&quot;).

If you use enums instead of integers (or String codes), you increase compile-time checking and avoid errors from passing in invalid constants, and you document which values are legal to use.

BTW, overuse of enums might mean that your methods do too much (it's often better to have several separate methods, rather than one method that takes several flags which modify what it does), but if you have to use flags or type codes, enums are the way to go.

</code></pre><p>简单翻译一下， 两点很重要。</p>
<ul>
<li>当一个变量(尤其是方法参数) 只能从一小部分可能的值中取出一个时，理应使用枚举。
例如类型常量(合同状态：永久、临时工、学徒)， 或者在做任务程序时，是立即执行还是延迟执行的标记。</li>
<li>如果使用枚举而不是整形，则会增加编译时的检查，避免错误无效值的传入，记录哪些值是合法使用的。</li>
</ul>
<h3 id="如何实现枚举">如何实现枚举</h3>
<p><code>iota</code> 是 Go 中预声明的一个特殊常量。它会被预声明为0，但是它的值在编译阶段并非是固定的，当预声明的 <code>iota</code> 出现在一个常量声明中的时候，它的值在第n个常量描述中的值为n(从0开始)。所以它只在同类型多个常量声明的情况下才显得有意义。</p>
<p>比如，大家都了解的电商，订单系统一定会涉及到订单状态的流转。那么这时候，我们一般可以这样做:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Cancelled</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">//订单已取消 0
</span><span class="c1"></span>	<span class="nx">NoPay</span>     <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">//未支付  1
</span><span class="c1"></span>	<span class="nx">PendIng</span>   <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// 未发货 2
</span><span class="c1"></span>	<span class="nx">Delivered</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// 已发货 3
</span><span class="c1"></span>	<span class="nx">Received</span>  <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// 已收货 4
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Cancelled</span><span class="p">,</span> <span class="nx">NoPay</span><span class="p">)</span> <span class="c1">// 打印:0,1
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><p>当然，这样看着好麻烦。其实，其他常量可以重复上一行 <code>iota</code> 表达式，我们可以改成这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Cancelled</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">//订单已取消 0
</span><span class="c1"></span>	<span class="nx">NoPay</span>                        <span class="c1">//未支付 1
</span><span class="c1"></span>	<span class="nx">PendIng</span>                      <span class="c1">// 未发货 2
</span><span class="c1"></span>	<span class="nx">Delivered</span>                    <span class="c1">// 已发货 3
</span><span class="c1"></span>	<span class="nx">Received</span>                     <span class="c1">// 已收货 4
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Cancelled</span><span class="p">,</span> <span class="nx">NoPay</span><span class="p">)</span> <span class="c1">// 打印:0,1
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><p>有人会用 0 的值来表示状态吗？一般都不会，我们想以1开头，那么可以这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Cancelled</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span><span class="o">+</span><span class="mi">1</span> <span class="c1">//订单已取消 1
</span><span class="c1"></span>	<span class="nx">NoPay</span>                        <span class="c1">//未支付 2
</span><span class="c1"></span>	<span class="nx">PendIng</span>                      <span class="c1">// 未发货 3
</span><span class="c1"></span>	<span class="nx">Delivered</span>                    <span class="c1">// 已发货 4
</span><span class="c1"></span>	<span class="nx">Received</span>                     <span class="c1">// 已收货 5
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Cancelled</span><span class="p">,</span> <span class="nx">NoPay</span><span class="p">)</span> <span class="c1">// 打印:1,2
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>我们还想在 <code>Delivered</code> 后跳过一个数字，才是 <code>Received</code> 的值,也就是 <code>Received=6</code>，那么可以借助 <code>_</code> 符号。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Cancelled</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span><span class="o">+</span><span class="mi">1</span> <span class="c1">//订单已取消 1
</span><span class="c1"></span>	<span class="nx">NoPay</span>                        <span class="c1">//未支付 2
</span><span class="c1"></span>	<span class="nx">PendIng</span>                      <span class="c1">// 未发货 3
</span><span class="c1"></span>	<span class="nx">Delivered</span>                    <span class="c1">// 已发货 4
</span><span class="c1"></span>	<span class="nx">_</span>
	<span class="nx">Received</span>                     <span class="c1">// 已收货 6
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Received</span><span class="p">)</span> <span class="c1">// 打印:6
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><p>顺着来可以，倒着当然也行。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Max</span> <span class="p">=</span> <span class="mi">5</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Received</span>  <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="nx">Max</span> <span class="o">-</span> <span class="kc">iota</span> <span class="c1">// 已收货  5
</span><span class="c1"></span>	<span class="nx">Delivered</span>                          <span class="c1">// 已发货 4
</span><span class="c1"></span>	<span class="nx">PendIng</span>                            <span class="c1">// 未发货 3
</span><span class="c1"></span>	<span class="nx">NoPay</span>                              <span class="c1">//未支付 2
</span><span class="c1"></span>	<span class="nx">Cancelled</span>                          <span class="c1">//订单已取消 1
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Received</span><span class="p">,</span><span class="nx">Delivered</span><span class="p">)</span> <span class="c1">// 打印:5,4
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>你还可以使用位运算，比如在 go 源码中的包 <code>sync</code> 中的锁上面有这么一段代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">mutexLocked</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>  <span class="c1">//1&lt;&lt;0
</span><span class="c1"></span>    <span class="nx">mutexWoken</span>               <span class="c1">//1&lt;&lt;1
</span><span class="c1"></span>    <span class="nx">mutexStarving</span>            <span class="c1">//1&lt;&lt;2
</span><span class="c1"></span>    <span class="nx">mutexWaiterShift</span> <span class="p">=</span> <span class="kc">iota</span>  <span class="c1">//3
</span><span class="c1"></span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;mutexLocked的值&#34;</span><span class="p">,</span><span class="nx">mutexLocked</span><span class="p">)</span> <span class="c1">//打印：1
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;mutexWoken的值&#34;</span><span class="p">,</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="c1">//打印：2
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;mutexStarving的值&#34;</span><span class="p">,</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="c1">//打印：4
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;mutexWaiterShift的值&#34;</span><span class="p">,</span><span class="nx">mutexWaiterShift</span><span class="p">)</span> <span class="c1">// 打印：3
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><p>可能有人平常是直接定义常量值或者用字符串来表示的。</p>
<p>比如，上面这些我完全可以用 <code>string</code> 来表示，我还真见过用字符串来表示订单状态的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Cancelled</span> <span class="p">=</span> <span class="s">&#34;cancelled&#34;</span>
	<span class="nx">NoPay</span>     <span class="p">=</span> <span class="s">&#34;noPay&#34;</span>
	<span class="nx">PendIng</span>   <span class="p">=</span> <span class="s">&#34;pendIng&#34;</span>
	<span class="nx">Delivered</span> <span class="p">=</span> <span class="s">&#34;delivered&#34;</span>
	<span class="nx">Received</span>  <span class="p">=</span> <span class="s">&#34;received&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">OrderStatusMsg</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
	<span class="nx">Cancelled</span><span class="p">:</span> <span class="s">&#34;订单已取消&#34;</span><span class="p">,</span>
	<span class="nx">NoPay</span><span class="p">:</span>     <span class="s">&#34;未付款&#34;</span><span class="p">,</span>
	<span class="nx">PendIng</span><span class="p">:</span>   <span class="s">&#34;未发货&#34;</span><span class="p">,</span>
	<span class="nx">Delivered</span><span class="p">:</span> <span class="s">&#34;已发货&#34;</span><span class="p">,</span>
	<span class="nx">Received</span><span class="p">:</span>  <span class="s">&#34;已收货&#34;</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">OrderStatusMsg</span><span class="p">[</span><span class="nx">Cancelled</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div><p>或者直接定义整形常量值。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Cancelled</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">NoPay</span>     <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">PendIng</span>   <span class="p">=</span> <span class="mi">3</span>
	<span class="nx">Delivered</span> <span class="p">=</span> <span class="mi">4</span>
	<span class="nx">Received</span>  <span class="p">=</span> <span class="mi">5</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">OrderStatusMsg</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
	<span class="nx">Cancelled</span><span class="p">:</span> <span class="s">&#34;订单已取消&#34;</span><span class="p">,</span>
	<span class="nx">NoPay</span><span class="p">:</span>     <span class="s">&#34;未付款&#34;</span><span class="p">,</span>
	<span class="nx">PendIng</span><span class="p">:</span>   <span class="s">&#34;未发货&#34;</span><span class="p">,</span>
	<span class="nx">Delivered</span><span class="p">:</span> <span class="s">&#34;已发货&#34;</span><span class="p">,</span>
	<span class="nx">Received</span><span class="p">:</span>  <span class="s">&#34;已收货&#34;</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">OrderStatusMsg</span><span class="p">[</span><span class="nx">Cancelled</span><span class="p">])</span>
<span class="p">}</span>

</code></pre></div><p>其实上述两种都可以，但是相比之下使用 <code>iota</code> 更有优势。</p>
<ul>
<li>能保证一组常量的唯一性，人工定义的不能保证。</li>
<li>可以为一组动作分享同一种行为。</li>
<li>避免无效值。</li>
<li>提高代码阅读性以及维护。</li>
</ul>
<h3 id="延伸">延伸</h3>
<p>按照上面我们所演示的，最后我们可以这样操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Cancelled</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">//订单已取消 1
</span><span class="c1"></span>	<span class="nx">NoPay</span>                            <span class="c1">//未支付 2
</span><span class="c1"></span>	<span class="nx">PendIng</span>                          <span class="c1">// 未发货 3
</span><span class="c1"></span>	<span class="nx">Delivered</span>                        <span class="c1">// 已发货 4
</span><span class="c1"></span>	<span class="nx">Received</span>                         <span class="c1">// 已收货 5
</span><span class="c1"></span><span class="p">)</span>

<span class="c1">//公共行为 赋予类型 String() 函数，方便打印值含义
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">order</span> <span class="nx">OrderStatus</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;cancelled&#34;</span><span class="p">,</span> <span class="s">&#34;noPay&#34;</span><span class="p">,</span> <span class="s">&#34;pendIng&#34;</span><span class="p">,</span> <span class="s">&#34;delivered&#34;</span><span class="p">,</span> <span class="s">&#34;received&#34;</span><span class="p">}[</span><span class="nx">order</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">//创建公共行为 赋予类型 int 函数 EnumIndex()
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">order</span> <span class="nx">OrderStatus</span><span class="p">)</span> <span class="nf">EnumIndex</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">order</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">order</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="nx">Received</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">order</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>    <span class="c1">// 打印:received
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">order</span><span class="p">.</span><span class="nf">EnumIndex</span><span class="p">())</span> <span class="c1">// 打印:5
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h3 id="总结">总结</h3>
<p>这篇文章主要介绍了 <code>Golang</code> 中对 <code>iota</code> 的使用介绍，以及我们为什么要使用它。</p>
<p>不知道大家平常对于此类场景是用的什么招数，欢迎下方留言交流。</p>
]]></content>
		</item>
		
		<item>
			<title>原来sync.Once还能这么用</title>
			<link>https://www.syst.top/posts/go/synconce/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/synconce/</guid>
			<description>介绍 sync.Once估计大家都不陌生，官方介绍中，
 Once is an object that will perform exactly one action
 正是因为这个特性，Once常常被用于单例对象的初始化场景。
也正是因为这个特性，其实它还能做一些其他的事情。
缓存击穿 日常背诵八股文，我相信你们对缓存击穿这个词特别熟悉。
缓存击穿一般待指热点key缓存失效(到期|删了)，同一时刻大量对热点key的并发请求。缓存找不到数据，所有请求都打入到DB层。此时，身为开发的你，明天和意外就不知道哪个先到了。
为了防止这种情况发生，针对相同key的请求，只需要一个请求(A)到达DB层取数据，其他请求等待A通知就行了。
就像这样，
​ 图片来源:caching
singleflight Go里有很多防缓存击穿的工具，比如singleflight库。
type call struct { wg sync.WaitGroup val interface{} err error forgotten bool //.....省略部分字段 } type Group struct { mu sync.Mutex m map[string]*call } 通过上面简单的代码大概能看出，其实就是对key做了缓存。
把一个key对应call结构存储在map中。保证只有一个key真正执行fn()服务 ，其他请求则通过sync.waitGroup的wait等待结果。
至于g.docall(c,key,fn)，
当带着全村人希望的那个请求，获取到数据，给对应key的call赋值，最终执行done，通知等待这个key全村的村民获取数据。
代码并不复杂。
自定义singleflight 我们也可以实现一个简易版本的。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) type CacheEntry struct { data []byte err error wait chan struct{} } type OrderSever struct { cache map[string]*CacheEntry mutex sync.</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p><code>sync.Once</code>估计大家都不陌生，官方介绍中，</p>
<blockquote>
<p>Once is an object that will perform exactly one action</p>
</blockquote>
<p>正是因为这个特性，<code>Once</code>常常被用于单例对象的初始化场景。</p>
<p>也正是因为这个特性，其实它还能做一些其他的事情。</p>
<h3 id="缓存击穿">缓存击穿</h3>
<p>日常背诵八股文，我相信你们对<strong>缓存击穿</strong>这个词特别熟悉。</p>
<p><strong>缓存击穿</strong>一般待指热点<code>key</code>缓存失效(到期|删了)，同一时刻大量对热点<code>key</code>的并发请求。缓存找不到数据，所有请求都打入到<code>DB</code>层。此时，身为开发的你，明天和意外就不知道哪个先到了。</p>
<p>为了防止这种情况发生，针对相同<code>key</code>的请求，只需要一个请求(A)到达<code>DB</code>层取数据，其他请求等待<code>A</code>通知就行了。</p>
<p>就像这样，</p>
<p><img src="https://cdn.syst.top/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png" alt="缓存击穿"></p>
<p>​                                 图片来源:<a href="https://medium.com/codex/caching-system-stability-766bf5fff69f">caching</a></p>
<h3 id="singleflight">singleflight</h3>
<p><code>Go</code>里有很多防缓存击穿的工具，比如<code>singleflight</code>库。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">call</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">val</span> <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">err</span> <span class="kt">error</span>
	<span class="nx">forgotten</span> <span class="kt">bool</span>
	<span class="c1">//.....省略部分字段
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>       
	<span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">call</span> 
<span class="p">}</span>
</code></pre></div><p><img src="https://cdn.syst.top/once-1.png" alt=""></p>
<p>通过上面简单的代码大概能看出，其实就是对<code>key</code>做了缓存。</p>
<p>把一个<code>key</code>对应<code>call</code>结构存储在<code>map</code>中。保证只有一个<code>key</code>真正执行<code>fn()</code>服务 ，其他请求则通过<code>sync.waitGroup</code>的<code>wait</code>等待结果。</p>
<p>至于<code>g.docall(c,key,fn)</code>，</p>
<p><img src="https://cdn.syst.top/once-2.png" alt=""></p>
<p>当带着全村人希望的那个请求，获取到数据，给对应<code>key</code>的<code>call</code>赋值，最终执行<code>done</code>，通知等待这个<code>key</code>全村的村民获取数据。</p>
<p>代码并不复杂。</p>
<h3 id="自定义singleflight"><strong>自定义</strong>singleflight</h3>
<p>我们也可以实现一个简易版本的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">CacheEntry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nx">err</span>  <span class="kt">error</span>
	<span class="nx">wait</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">OrderSever</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cache</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CacheEntry</span>
	<span class="nx">mutex</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">order</span> <span class="o">*</span><span class="nx">OrderSever</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">order</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">order</span><span class="p">.</span><span class="nx">cache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">order</span><span class="p">.</span><span class="nx">cache</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CacheEntry</span><span class="p">)</span>
	<span class="p">}</span>
  
  <span class="c1">//已经有其他兄弟请求了，你等等
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">entry</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">order</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">order</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="o">&lt;-</span><span class="nx">entry</span><span class="p">.</span><span class="nx">wait</span>
		<span class="k">return</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">entry</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">CacheEntry</span><span class="p">{</span>
		<span class="nx">data</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="nx">wait</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
	<span class="p">}</span>
	<span class="nx">order</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">entry</span>
	<span class="nx">order</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="c1">// 请求数据
</span><span class="c1"></span>	<span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nf">getOrder</span><span class="p">()</span>
  <span class="c1">// 请求数据完毕，通知其他兄弟可以拿数据了。
</span><span class="c1"></span>	<span class="nb">close</span><span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">wait</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">//外部服务
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getOrder</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">50</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>代码整体不难，主要的点在于我们是通过通道来实现通知自家兄弟取数据。</p>
<p>最后，让我们使用<code>Once</code>来达到同样的效果，不然标题不白起了嘛。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">CacheEntry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nx">err</span>  <span class="kt">error</span>
	<span class="nx">once</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">OrderSever</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cache</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CacheEntry</span>
	<span class="nx">mutex</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">order</span> <span class="o">*</span><span class="nx">OrderSever</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">order</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">order</span><span class="p">.</span><span class="nx">cache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">order</span><span class="p">.</span><span class="nx">cache</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CacheEntry</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">entry</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">order</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  
  <span class="c1">// 找不到就初始化一个
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">entry</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">CacheEntry</span><span class="p">{</span>
			<span class="nx">data</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="nx">err</span><span class="p">:</span>  <span class="kc">nil</span><span class="p">,</span>
			<span class="nx">once</span><span class="p">:</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span><span class="p">),</span>
		<span class="p">}</span>
		<span class="nx">order</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">entry</span>
	<span class="p">}</span>
	<span class="nx">order</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  
  <span class="c1">// 我只执行一次。
</span><span class="c1"></span>	<span class="nx">entry</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nf">getOrder</span><span class="p">()</span>
	<span class="p">})</span>
  <span class="c1">//数据被赋值了，返回
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getOrder</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">50</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>上面核心代码都写出来了，实际开发中需要对请求资源做一些超时控制等操作。</p>
<h3 id="总结">总结</h3>
<p>平常对<code>Once</code>的使用只停留在初始化工作上，而弱化了它的使用场景。对于其他工具也是一个道理，这就需要去积累和挖掘了。</p>
<h3 id="附录"><strong>附录</strong></h3>
<p>[1]https://medium.com/codex/caching-system-stability-766bf5fff69f</p>
<p><a href="https://blog.chuie.io/posts/synconce/">https://blog.chuie.io/posts/synconce/</a></p>
]]></content>
		</item>
		
		<item>
			<title>推荐两款go开发中提高效率工具</title>
			<link>https://www.syst.top/posts/go/go-tool/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/go-tool/</guid>
			<description>介绍 推荐两款 go 开发中用的还行的工具。
为什么推荐工具？是为了让评论区的大佬介绍其他更好用的工具，解放我的双手。
顺便问问，有没有只说话就能自动打完代码的工具？
JSON-To-Stuct 这个工具可以把 json 格式的数据转换成 go 的 struct。比如你在对接第三方的时候，就不需要根据对方的接口一个个定义 struct 字段。下面示例复制的微信小商店商品 json 数据到网站的左框即可，当然自己还是需要做一些局部的调整。
其实这个功能 21 版的 goland 也支持了。在 goland 中你只需要这样,
Table-To-Stuct 被业务缠身的同学每天免不了 CURD。CURD 之前总得建表吧。建表之后总得在代码中定义模型吧。总不能又一个个字段定义，那么下面这个工具可能管用。
假设你有一个库 dream，库里有一个表 category，结构如下，
CREATE TABLE `category` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(20) NOT NULL DEFAULT &amp;#39;&amp;#39;, `parent_id` int(11) unsigned NOT NULL DEFAULT &amp;#39;0&amp;#39;, `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`) ) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4; 你只需引入包 github.</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>推荐两款 <code>go</code> 开发中用的还行的工具。</p>
<p>为什么推荐工具？是为了让评论区的大佬介绍其他更好用的工具，解放我的双手。</p>
<p>顺便问问，有没有只说话就能自动打完代码的工具？</p>
<h3 id="json-to-stuct">JSON-To-Stuct</h3>
<p>这个工具可以把 <code>json</code> 格式的数据转换成 <code>go</code> 的 <code>struct</code>。比如你在对接第三方的时候，就不需要根据对方的接口一个个定义 <code>struct</code> 字段。下面示例复制的微信小商店商品 <code>json</code> 数据到网站的左框即可，当然自己还是需要做一些局部的调整。</p>
<p><img src="https://image.syst.top/image/go-tool/1.png" alt="image"></p>
<p>其实这个功能 21 版的 <code>goland</code> 也支持了。在 <code>goland</code> 中你只需要这样,</p>
<p><img src="https://image.syst.top/image/go-tool/2.gif" alt="image"></p>
<h3 id="table-to-stuct">Table-To-Stuct</h3>
<p>被业务缠身的同学每天免不了 <code>CURD</code>。<code>CURD</code> 之前总得建表吧。建表之后总得在代码中定义模型吧。总不能又一个个字段定义，那么下面这个工具可能管用。</p>
<p>假设你有一个库 <code>dream</code>，库里有一个表 <code>category</code>，结构如下，</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">category</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">parent_id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">created_at</span><span class="o">`</span> <span class="k">timestamp</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="o">`</span><span class="n">updated_at</span><span class="o">`</span> <span class="k">timestamp</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="k">KEY</span> <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">name</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">23</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span><span class="p">;</span>
</code></pre></div><p>你只需引入包 <code>github.com/gohouse/converter</code> ,然后写这样的代码，就可以实现 <code>table-to-go</code> 功能。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/gohouse/converter&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 初始化
</span><span class="c1"></span>	<span class="nx">t2t</span> <span class="o">:=</span> <span class="nx">converter</span><span class="p">.</span><span class="nf">NewTable2Struct</span><span class="p">()</span>
	<span class="c1">// 个性化配置
</span><span class="c1"></span>	<span class="nx">t2t</span><span class="p">.</span><span class="nf">Config</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">converter</span><span class="p">.</span><span class="nx">T2tConfig</span><span class="p">{</span>
		<span class="c1">// 如果字段首字母本来就是大写, 就不添加tag, 默认false添加, true不添加
</span><span class="c1"></span>		<span class="nx">RmTagIfUcFirsted</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
		<span class="c1">// tag的字段名字是否转换为小写, 如果本身有大写字母的话, 默认false不转
</span><span class="c1"></span>		<span class="nx">TagToLower</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
		<span class="c1">// 字段首字母大写的同时, 是否要把其他字母转换为小写,默认false不转换
</span><span class="c1"></span>		<span class="nx">UcFirstOnly</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
		<span class="c1">//// 每个struct放入单独的文件,默认false,放入同一个文件(暂未提供)
</span><span class="c1"></span>		<span class="c1">//SeperatFile: false,
</span><span class="c1"></span>	<span class="p">})</span>
	<span class="c1">// 开始迁移转换
</span><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">t2t</span><span class="p">.</span>
		<span class="c1">// 指定某个表,如果不指定,则默认全部表都迁移
</span><span class="c1"></span>		<span class="nf">Table</span><span class="p">(</span><span class="s">&#34;category&#34;</span><span class="p">).</span>
		<span class="c1">//// 表前缀
</span><span class="c1"></span>		<span class="c1">//Prefix(&#34;prefix_&#34;).
</span><span class="c1"></span>		<span class="c1">// 是否添加json tag
</span><span class="c1"></span>		<span class="nf">EnableJsonTag</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span>
		<span class="c1">// 生成struct的包名(默认为空的话, 则取名为: package model)
</span><span class="c1"></span>		<span class="nf">PackageName</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">).</span>
		<span class="c1">// tag字段的key值,默认是orm
</span><span class="c1"></span>		<span class="nf">TagKey</span><span class="p">(</span><span class="s">&#34;orm&#34;</span><span class="p">).</span>
		<span class="c1">// 是否添加结构体方法获取表名
</span><span class="c1"></span>		<span class="nf">RealNameMethod</span><span class="p">(</span><span class="s">&#34;TableName&#34;</span><span class="p">).</span>
		<span class="c1">// 生成的结构体保存路径
</span><span class="c1"></span>		<span class="nf">SavePath</span><span class="p">(</span><span class="s">&#34;model/category.go&#34;</span><span class="p">).</span>
		<span class="c1">// 数据库dsn,这里可以使用 t2t.DB() 代替,参数为 *sql.DB 对象
</span><span class="c1"></span>		<span class="nf">Dsn</span><span class="p">(</span><span class="s">&#34;root:Passw0rd@tcp(localhost:3306)/dream?charset=utf8&#34;</span><span class="p">).</span>
		<span class="c1">// 执行
</span><span class="c1"></span>		<span class="nf">Run</span><span class="p">()</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>运行这段代码，最后会根据设置的 <code>SavePath</code> 里的地址(尚未存在的目录需要先自行创建)，生成 <code>category.go</code> 文件，内容如下，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">model</span>

<span class="kd">type</span> <span class="nx">Category</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Id</span>        <span class="kt">int</span>    <span class="s">`orm:&#34;id&#34; json:&#34;id&#34;`</span>
	<span class="nx">Name</span>      <span class="kt">string</span> <span class="s">`orm:&#34;name&#34; json:&#34;name&#34;`</span>
	<span class="nx">ParentId</span>  <span class="kt">int</span>    <span class="s">`orm:&#34;parent_id&#34; json:&#34;parent_id&#34;`</span>
	<span class="nx">CreatedAt</span> <span class="kt">string</span> <span class="s">`orm:&#34;created_at&#34; json:&#34;created_at&#34;`</span>
	<span class="nx">UpdatedAt</span> <span class="kt">string</span> <span class="s">`orm:&#34;updated_at&#34; json:&#34;updated_at&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Category</span><span class="p">)</span> <span class="nf">TableName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;category&#34;</span>
<span class="p">}</span>
</code></pre></div><p>相应的再进行调整即可。</p>
<h3 id="总结">总结</h3>
<p>今天主要分享的是 <code>json-to-stuct</code>、<code>table-to-stuct</code> 这两款日常会用上的工具。</p>
<p>好了，现在开始你们给我介绍趁手的工具了。</p>
]]></content>
		</item>
		
		<item>
			<title>无限缓冲的channel(1)</title>
			<link>https://www.syst.top/posts/go/unlimited/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/unlimited/</guid>
			<description>介绍 事情的起因是前几周看到鸟窝写了一篇关于实现无限缓冲 channel 的文章，当时忙着和小姐姐聊天没看，今天想起来了。
不过这篇文章不会涉及到鸟窝自己实现的 chanx，我们会在下一篇提到。
我们都知道，channel 有两种类型:无缓冲和有缓冲的。
当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。
有时候，我们并不知道也无法预估写入通道的数量规模。如果此时通道的写入速度远远超过读取速度，那么必然会在某个时间点塞满通道，导致写入阻塞。 比如之前我翻译的一篇文章 使用 Go 每分钟处理百万请求 中，作者就出现处理速度太慢，导致通道塞满，其他请求被阻塞，响应时间慢慢增加。
此时有人就会提到，能不能提供一个无限缓冲(Unbounded or Unlimited)的通道。
这个问题早在 2017 年就有人提过 issues，最终 go 官方没有实现这个提案。
不过，这个 issues 下面总共产生了 67 个 comments，评论很精彩。 比如有人提到:
cznic:Unlimited capacity channels ask for a machine with unlimited memory. rsc:The limited capacity of channels is an important source of backpressure in a set of communicating goroutines. It is typically a mistake to use an unbounded channel, because you lose that backpressure.</description>
			<content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p>事情的起因是前几周看到鸟窝写了一篇关于实现无限缓冲 <code>channel</code> 的文章，当时忙着和小姐姐聊天没看，今天想起来了。</p>
<p>不过这篇文章不会涉及到鸟窝自己实现的 <code>chanx</code>，我们会在下一篇提到。</p>
<p>我们都知道，<code>channel</code> 有两种类型:无缓冲和有缓冲的。</p>
<p>当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。</p>
<p>有时候，我们并不知道也无法预估写入通道的数量规模。如果此时通道的写入速度远远超过读取速度，那么必然会在某个时间点塞满通道，导致写入阻塞。
比如之前我翻译的一篇文章 <a href="https://www.syst.top/posts/go/handle-million-requests/">使用 Go 每分钟处理百万请求</a> 中，作者就出现处理速度太慢，导致通道塞满，其他请求被阻塞，响应时间慢慢增加。</p>
<p>此时有人就会提到，能不能提供一个无限缓冲(Unbounded or Unlimited)的通道。</p>
<p>这个问题早在 2017 年就有人提过 issues，最终 go 官方没有实现这个提案。</p>
<p>不过，这个 issues 下面总共产生了 67 个 comments，评论很精彩。
<img src="https://image.syst.top/image/unlimited/unlimit-1.png" alt="image"></p>
<p>比如有人提到:</p>
<pre><code>cznic:Unlimited capacity channels ask for a machine with unlimited memory.

rsc:The limited capacity of channels is an important source of backpressure in a set of communicating goroutines. It is typically a mistake to use an unbounded channel, because you lose that backpressure. If one goroutine falls sufficiently behind, you usually want to take some action in response, not just queue its messages forever. The appropriate response varies by situation: maybe you want to drop messages, maybe you want to keep summary messages, maybe you want to take different responses as the goroutine falls further and further behind. Making it trivial to reach for unbounded channels keeps developers from thinking about this, which I believe is a strong disadvantage.
</code></pre><p>那么如何实现一个无限缓冲的通道呢？</p>
<p>针对这类需求，有很多版本的实现，我们来看其中的一个实现。鸟窝的 chanx 就是在这个基础上做修改的。</p>
<p>我们一步步还原它的实现，这其中还能知道作者的思考过程。</p>
<h2 id="代码">代码</h2>
<p>第一版,</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-2.png" alt="image"></p>
<p><code>MakeInfinite</code> 函数返回两个通道，第一个用于数据的写入，第二个用于数据的读取。</p>
<p>注意看这里的细节，在返回的时候就约束了通道的操作类型:一个只写，一个只读，这样避免了用户破坏通道的操作流程。
这里面的代码也简单，只要写入通道 <code>in</code> 未被关闭，那么就把从 <code>in</code> 通道中读取的值 <code>append</code> 到 <code>inQueue</code> 切片中。
<code>inQueue</code> 在这里就是实现无限缓冲的中间层。</p>
<p>然后有个 test。</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-3.png" alt="image"></p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-4.png" alt="image"></p>
<p>当走到第二个 <code>case</code> 的时候，由于 <code>inQueue</code> 一开始是空的，那么必然会出现  <code>index out</code>。
不仅是一开始，在运行中，如果读取比写入快，那么必然也会导致相同的情况。</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-5.jpg" alt="image">
<img src="https://image.syst.top/image/unlimited/unlimit-6.png" alt="image"></p>
<p>在 <code>inQueue</code> 没有值的时候，我们把 <code>nil</code> 也写入到通道，
然后测试代码中我们从 <code>out channel</code> 读取数值试图把值断言 <code>int</code> 失败了。 那么，当队列中没有数据时，我们不应该写入 <code>out</code> 通道。</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-7.jpg" alt="image">
作者使用了一个技巧，如果 <code>inQueue</code> 没有数据，那么尝试写入一个 <code>nil</code> 通道将永远阻塞。
通常，永久阻塞是一个不好的行为，但是这个是包含在 <code>select</code> 语句中的，所以问题不大。</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-8.png" alt="image"></p>
<p>还有问题。原因很简单，我们再发送完数据就马上关闭了 <code>in</code> 通道。随后 <code>break loop</code>。接下来关闭 <code>out</code> 通道，程序运行结束。
此时 <code>inQueue</code> 还有值未被取出。</p>
<p>只要写比读快，那么就永远存在这个问题。我们需要保证在通道关闭的时候，<code>inQueue</code> 已为空。
<img src="https://image.syst.top/image/unlimited/unlimit-9.jpg" alt="image"></p>
<h2 id="总结">总结</h2>
<p>上面是如何实现一个无限缓冲的 <code>channel</code>？</p>
<p>借助了一个临时存储数据的中间层。</p>
<p>上面的实现有没有哪些地方可以改进？</p>
<p><code>inQueue</code> 作为中间层，本质上是一个切片。明明 <code>inQueue</code> 已经扩容到很大的值了，但是并没有对应的 <code>reset</code>。会导致 <code>inQueue</code> 指向还在底层数组靠后的位置，并不能复用数组前面的空间，造成浪费。</p>
<p><code>chanx</code> 是咋么改进的？</p>
<p>下一篇</p>
]]></content>
		</item>
		
		<item>
			<title>无限缓冲的channel(2)</title>
			<link>https://www.syst.top/posts/go/unlimited-2/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/unlimited-2/</guid>
			<description>chanx 上篇文章我们提到，当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。 由此引发了关于无限缓存的 channel 话题讨论。 我们分析了一个实现无限缓冲的代码。 最后，我们也提到了它还可以继续优化的点。
鸟窝的 chanx 正是基于此方案改造而成的，我们来看看他俩的不同之处。
上篇文章说过，所谓的无限缓冲，无非是借助一个中间层的数据结构，暂存临时数据。
在 chanx 中，结构是这样的:
type UnboundedChan struct { In chan&amp;lt;- T // channel for write 	Out &amp;lt;-chan T // channel for read 	buffer *RingBuffer // buffer } in 和 out 的职责在上篇文章已经说明，这里的 buffer 就是我们所谓的中间临时存储层。其中的 RingBuffer 结构我们后面再说。
func NewUnboundedChan(initCapacity int) UnboundedChan { return NewUnboundedChanSize(initCapacity, initCapacity, initCapacity) } func NewUnboundedChanSize(initInCapacity, initOutCapacity, initBufCapacity int) UnboundedChan { in := make(chan T, initInCapacity) out := make(chan T, initOutCapacity) ch := UnboundedChan{In: in, Out: out, buffer: NewRingBuffer(initBufCapacity)} go process(in, out, ch) return ch } 它提供了两个初始化 UnboundedChan 的方法，从代码中我们可以明显的看出,NewUnboundedChanSize 可以给每个属性自定义自己的容量大小。仅此而已。</description>
			<content type="html"><![CDATA[<h2 id="chanx">chanx</h2>
<p>上篇文章我们提到，当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。 由此引发了关于无限缓存的 <code>channel</code> 话题讨论。
我们分析了一个实现无限缓冲的代码。 最后，我们也提到了它还可以继续优化的点。</p>
<p>鸟窝的 <code>chanx</code> 正是基于此方案改造而成的，我们来看看他俩的不同之处。</p>
<p>上篇文章说过，所谓的无限缓冲，无非是借助一个中间层的数据结构，暂存临时数据。</p>
<p>在 <code>chanx</code> 中，结构是这样的:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UnboundedChan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">In</span>     <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">T</span>    <span class="c1">// channel for write
</span><span class="c1"></span>	<span class="nx">Out</span>    <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">T</span>    <span class="c1">// channel for read
</span><span class="c1"></span>	<span class="nx">buffer</span> <span class="o">*</span><span class="nx">RingBuffer</span> <span class="c1">// buffer
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>in</code> 和 <code>out</code> 的职责在上篇文章已经说明，这里的 <code>buffer</code> 就是我们所谓的中间临时存储层。其中的 <code>RingBuffer</code> 结构我们后面再说。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewUnboundedChan</span><span class="p">(</span><span class="nx">initCapacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UnboundedChan</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">NewUnboundedChanSize</span><span class="p">(</span><span class="nx">initCapacity</span><span class="p">,</span> <span class="nx">initCapacity</span><span class="p">,</span> <span class="nx">initCapacity</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewUnboundedChanSize</span><span class="p">(</span><span class="nx">initInCapacity</span><span class="p">,</span> <span class="nx">initOutCapacity</span><span class="p">,</span> <span class="nx">initBufCapacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UnboundedChan</span> <span class="p">{</span>
	<span class="nx">in</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">initInCapacity</span><span class="p">)</span>
	<span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">initOutCapacity</span><span class="p">)</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">UnboundedChan</span><span class="p">{</span><span class="nx">In</span><span class="p">:</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">Out</span><span class="p">:</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">:</span> <span class="nf">NewRingBuffer</span><span class="p">(</span><span class="nx">initBufCapacity</span><span class="p">)}</span>

	<span class="k">go</span> <span class="nf">process</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>
</code></pre></div><p>它提供了两个初始化 <code>UnboundedChan</code> 的方法，从代码中我们可以明显的看出,<code>NewUnboundedChanSize</code> 可以给每个属性自定义自己的容量大小。仅此而已。</p>
<p><code>chanx</code> 中 关于 <code>in</code> 和 <code>out</code> 都是带缓冲的通道，而上篇文章中的 <code>in</code> 和 <code>out</code> 都是无缓冲的通道。
这和他们对数据的流转处理有很大关系。</p>
<p>我们接下去看 <code>process(in,out,ch)</code> 最核心的方法。
<img src="https://image.syst.top/image/unlimited-2/unlimit-1.jpg" alt="image"></p>
<p>这时候，我们再放上一篇核心代码。</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-7.jpg" alt="image"></p>
<p>可以很明显他们看出它俩的区别。</p>
<p>上篇从 <code>in</code> 通道读数据会先 <code>append</code> 到 <code>buffer</code>，然后从 <code>buffer</code> 中取数据写入 <code>out</code> 通道。
而 <code>chanx</code> 从 <code>in</code> 通道取出数据先尝试写入 <code>out</code>(没有中间商赚差价?)，只有在 <code>out</code> 已经满的情况下，才塞入到 <code>buffer</code>。</p>
<p><code>chanx</code> 还有一段小细节代码。
<img src="https://image.syst.top/image/unlimited-2/unlimit-2.jpg" alt="image"></p>
<p>能走到这里，一定是因为 <code>out</code> 通道满了。我们把值追加到 <code>buffer</code> 的同时，需要尝试把 <code>buffer</code> 中的数据写入 <code>out</code> 。
此时 <code>in</code> 通道也许还在持续的写入数据， 为了避免 <code>in</code> 通道塞满，阻塞业务写入，我们同时需要尝试从 <code>in</code> 通道中读数据追加到 <code>buffer</code>。</p>
<h2 id="buffer">buffer</h2>
<p>上篇文章我提到了关于 <code>buffer</code> 优化的点。</p>
<p><code>chanx</code> 是如何优化的?</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// type T interface{}
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RingBuffer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">buf</span>         <span class="p">[]</span><span class="nx">T</span> 
	<span class="nx">initialSize</span> <span class="kt">int</span>
	<span class="nx">size</span>        <span class="kt">int</span>
	<span class="nx">r</span>           <span class="kt">int</span> <span class="c1">// read pointer
</span><span class="c1"></span>	<span class="nx">w</span>           <span class="kt">int</span> <span class="c1">// write pointer
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这是 <code>buffer</code> 的结构，其中</p>
<ul>
<li><code>buf</code> 具体存储数据的结构。</li>
<li><code>initialSize</code> 初始化化 <code>buf</code> 的长度</li>
<li><code>size</code> 当前 <code>buf</code> 的长度</li>
<li><code>r</code> 当前读数据位置</li>
<li><code>w</code> 当前写入数据位置</li>
</ul>
<p><code>buffer</code> 本质上就是一个环形的队列，目的是达到资源的复用。
并且当 <code>buffer</code> 满时，提供自动扩容的功能。</p>
<p>我们来看具体把数据写入 <code>buffer</code> 的源码。
<img src="https://image.syst.top/image/unlimited-2/unlimit-3.png" alt="image"></p>
<p>接着看扩容。
<img src="https://image.syst.top/image/unlimited-2/unlimit-4.png" alt="image"></p>
<p>这段代码唯一难理解的就是数据迁移了。这里的数据迁移目的是为了保证先入先出的原则。</p>
<p>可能加了注释有些人也无法理解，那么就再加一个草率图。</p>
<p>假设我们 <code>buffer</code> 的长度是 8。 当前读和写的 <code>index</code> 都是5。说明 <code>buffer</code> 满了，触发自动扩容规则，进行数据迁移。</p>
<p>那么迁移的过程就是下图这样的。</p>
<p><img src="https://image.syst.top/image/unlimited-2/unlimit-5.png" alt="image"></p>
<p>还有，当 <code>buffer</code> 为空并且当前的 <code>size</code> 比初始化 <code>size</code> 还大，那么可以考虑重置 <code>buffer</code> 了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//if ch.buffer.IsEmpty() &amp;&amp; ch.buffer.size &gt; ch.buffer.initialSize { 
</span><span class="c1">//						ch.buffer.Reset()
</span><span class="c1">//					}
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">=</span> <span class="mi">0</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">=</span> <span class="mi">0</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">initialSize</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">initialSize</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>剩下的代码,就没什么好说的了。</p>
<h3 id="总结">总结</h3>
<p>继上篇文章后，这篇文章我们主要讲解了 <code>chanx</code> 是如何实现无限缓冲的 <code>channel</code>。
其中最重要的一个点在于 <code>chanx</code> 中 <code>buffer</code> 实现采用的是 <code>ringbuffer</code>，达到资源复用的同时还能自动扩容。</p>
]]></content>
		</item>
		
		<item>
			<title>为什么把 dig 迁移到 wire</title>
			<link>https://www.syst.top/posts/go/why-dig-to-wire/</link>
			<pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/why-dig-to-wire/</guid>
			<description>开篇 dig 和 wire 都是 Go 依赖注入的工具，那么，本质上功能相似的框架，为什么要从 dig 切换成 wire？
场景 我们从场景出发。
假设我们的项目分层是:router-&amp;gt;controller-&amp;gt;service-&amp;gt;dao。
大概就长这样:
现在我们需要对外暴露一个订单服务的接口。
首页看 main.go 文件。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;github.com/wuqinqiang/digvswire/dig&amp;#34; &amp;#34;github.com/wuqinqiang/digvswire/router&amp;#34; ) func main() { serverStart() } func serverStart() { defer func() { if err := recover(); err != nil { fmt.Printf(&amp;#34;init app err:%v\n&amp;#34;, err) } }() e := gin.Default() di := dig.ContainerByDig() err := router.RegisterRouter(e, di) if err != nil { fmt.Printf(&amp;#34;register router err:%v&amp;#34;, err) } _ = e.</description>
			<content type="html"><![CDATA[<h3 id="开篇">开篇</h3>
<p><code>dig</code> 和 <code>wire</code> 都是 <code>Go</code> 依赖注入的工具，那么，本质上功能相似的框架，为什么要从 <code>dig</code> 切换成 <code>wire</code>？</p>
<h3 id="场景">场景</h3>
<p>我们从场景出发。</p>
<p>假设我们的项目分层是:<code>router-&gt;controller-&gt;service-&gt;dao</code>。</p>
<p>大概就长这样:</p>
<p><img src="https://image.syst.top/image/dig-to-wire/1.png" alt="image"></p>
<p>现在我们需要对外暴露一个订单服务的接口。</p>
<p>首页看 <code>main.go</code> 文件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/dig&#34;</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/router&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">serverStart</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">serverStart</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;init app err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">di</span> <span class="o">:=</span> <span class="nx">dig</span><span class="p">.</span><span class="nf">ContainerByDig</span><span class="p">()</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">router</span><span class="p">.</span><span class="nf">RegisterRouter</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">di</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;register router err:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8090&#34;</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p>这里使用了 <code>gin</code> 启动项目。 然后我们查看 <code>dig.ContainerByDig()</code>，</p>
<h3 id="dig">dig</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">dig</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/controller&#34;</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/dao&#34;</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/server&#34;</span>
	<span class="s">&#34;go.uber.org/dig&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">ContainerByDig</span><span class="p">()</span> <span class="o">*</span><span class="nx">dig</span><span class="p">.</span><span class="nx">Container</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">dig</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">dao</span><span class="p">.</span><span class="nx">NewOrderDao</span><span class="p">)</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">)</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
</code></pre></div><p>首先通过 <code>dig.New()</code> 创建一个 <code>di</code> 容器。
<code>Provide</code> 函数用于添加服务提供者，  <code>Provide</code> 函数第一个参数本质上是一个函数。一个告诉容器 &ldquo;我能提供什么，为了提供它，我需要什么？&rdquo; 的函数。</p>
<p>比如我们看第二个 <code>server.NewOrderServer</code>,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">server</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/dao&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">_</span> <span class="nx">OrderServerInterface</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">OrderServer</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">OrderServerInterface</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">GetUserOrderList</span><span class="p">(</span><span class="nx">userId</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="nx">dao</span><span class="p">.</span><span class="nx">Order</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">OrderServer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">orderDao</span> <span class="nx">dao</span><span class="p">.</span><span class="nx">OrderDao</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewOrderServer</span><span class="p">(</span><span class="nx">order</span> <span class="nx">dao</span><span class="p">.</span><span class="nx">OrderDao</span><span class="p">)</span> <span class="nx">OrderServerInterface</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">OrderServer</span><span class="p">{</span><span class="nx">orderDao</span><span class="p">:</span> <span class="nx">order</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">OrderServer</span><span class="p">)</span> <span class="nf">GetUserOrderList</span><span class="p">(</span><span class="nx">userId</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">orderList</span> <span class="p">[]</span><span class="nx">dao</span><span class="p">.</span><span class="nx">Order</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">o</span><span class="p">.</span><span class="nx">orderDao</span><span class="p">.</span><span class="nf">GetOrderListById</span><span class="p">(</span><span class="nx">userId</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这里的 <code>NewOrderServer(xxx)</code> 在 <code>Provide</code> 中的语意就是 &ldquo;我能提供一个 <code>OrderServerInterface</code> 服务，但是我需要依赖一个 <code>dao.OrderDao</code>&quot;。</p>
<p>刚才的代码中，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">dao</span><span class="p">.</span><span class="nx">NewOrderDao</span><span class="p">)</span>
<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">)</span>
<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>
</code></pre></div><p>因为我们的调用链是 <code>controller-&gt;server-&gt;dao</code>，那么本质上他们的依赖是 <code>controller&lt;-server&lt;-dao</code>，只是依赖的不是具体的实现，而是抽象的接口。</p>
<p>所以你看到 <code>Provide</code> 是按照依赖关系顺序写的。</p>
<p>其实完全没有必要，因为这一步 <code>dig</code> 只会对这些函数进行分析，提取函数的形参以及返回值。然后根据返回的参数来组织容器结构。
并不会在这一步执行传入的函数，所以在 <code>Provide</code> 阶段前后顺序并不重要，只要确保不遗漏依赖项即可。</p>
<p>万事俱备，我们开始注册一个能获取订单的路由，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">router</span><span class="p">.</span><span class="nf">RegisterRouter</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>

<span class="c1">// router.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RegisterRouter</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span><span class="p">,</span> <span class="nx">dig</span> <span class="o">*</span><span class="nx">dig</span><span class="p">.</span><span class="nx">Container</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">dig</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">handle</span> <span class="o">*</span><span class="nx">controller</span><span class="p">.</span><span class="nx">OrderHandler</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/user/orders&#34;</span><span class="p">,</span> <span class="nx">handle</span><span class="p">.</span><span class="nx">GetUserOrderList</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>此时，调用 <code>invoke</code>， 才是真正需要获取 <code>*controller.OrderHandler</code> 对象。</p>
<p>调用 <code>invoke</code> 方法，会对传入的参数做分析，参数中存在 <code>handle *controller.OrderHandler</code>, 就会去容器中寻找哪个 <code>Provide</code> 进来的函数返回类型是 <code>handle *controller.OrderHandler</code>,</p>
<p>就能对应找到,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>
<span class="c1">// 对应
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewOrderHandler</span><span class="p">(</span><span class="nx">server</span> <span class="nx">server</span><span class="p">.</span><span class="nx">OrderServerInterface</span><span class="p">)</span> <span class="o">*</span><span class="nx">OrderHandler</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">OrderHandler</span><span class="p">{</span>
		<span class="nx">server</span><span class="p">:</span> <span class="nx">server</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>发现这个函数有形参 <code>server.OrderServerInterface</code>,那就去找对应返回此类型的函数，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">)</span>
<span class="c1">//对应
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewOrderServer</span><span class="p">(</span><span class="nx">order</span> <span class="nx">dao</span><span class="p">.</span><span class="nx">OrderDao</span><span class="p">)</span> <span class="nx">OrderServerInterface</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">OrderServer</span><span class="p">{</span><span class="nx">orderDao</span><span class="p">:</span> <span class="nx">order</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>又发现形参 <code>（order dao.OrderDao)</code>,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">dao</span><span class="p">.</span><span class="nx">NewOrderDao</span><span class="p">)</span>
<span class="c1">//对应
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewOrderDao</span><span class="p">()</span> <span class="nx">OrderDao</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">OrderDaoImpl</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>最后发现 <code>NewOrderDao</code> 没有依赖，不需要再查询依赖。开始执行函数的调用 <code>NewOrderDao()</code>，把返回的 <code>OrderDao</code> 传入到上层的 <code>NewOrderServer(order dao.OrderDao)</code> 进行函数调用，
<code>NewOrderServer(order dao.OrderDao)</code> 返回的 <code>OrderServerInterface</code> 继续返回到上层 <code>NewOrderHandler(server server.OrderServerInterface)</code> 执行调用，最后再把函数调用返回的 <code>*OrderHandler</code> 传递给 <code>dig.Invoke(func(handle *controller.OrderHandler) {}</code>,</p>
<p>整个链路就通了。用一个简陋的图来描述这个过程
<img src="https://image.syst.top/image/dig-to-wire/2.png" alt="image"></p>
<p><code>dig</code> 的整个流程采用的是反射机制，在运行时计算依赖关系，构造依赖对象。</p>
<p>这样会存在什么问题？</p>
<p>假设我现在注释掉 <code>Provide</code> 的一行代码，比如,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ContainerByDig</span><span class="p">()</span> <span class="o">*</span><span class="nx">dig</span><span class="p">.</span><span class="nx">Container</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">dig</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="c1">//_ = d.Provide(dao.NewOrderDao)
</span><span class="c1"></span>	<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">)</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
</code></pre></div><p>我们在编译项目的时候并不会报任何错误，只会在运行时才发现缺少了依赖项。
<img src="https://image.syst.top/image/dig-to-wire/3.png" alt="image"></p>
<h3 id="wire">wire</h3>
<p>还是上面的代码，我们使用 <code>wire</code> 作为我们的 <code>DI</code> 容器。</p>
<p><code>wire</code> 也有两个核心概念: <code>Provider</code> 和 <code>Injector</code>。</p>
<p>其中 <code>Provider</code> 的概念和 <code>dig</code> 的概念是一样的:&ldquo;我能提供什么？我需要什么依赖&rdquo;。</p>
<p>比如下面 <code>wire.go</code> 中的代码,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//+build wireinject
</span><span class="c1"></span>
<span class="kn">package</span> <span class="nx">wire</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/google/wire&#34;</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/controller&#34;</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/dao&#34;</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/server&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">orderSet</span> <span class="p">=</span> <span class="nx">wire</span><span class="p">.</span><span class="nf">NewSet</span><span class="p">(</span>
	<span class="nx">dao</span><span class="p">.</span><span class="nx">NewOrderDao</span><span class="p">,</span>
	<span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">,</span>
	<span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">ContainerByWire</span><span class="p">()</span> <span class="o">*</span><span class="nx">controller</span><span class="p">.</span><span class="nx">OrderHandler</span> <span class="p">{</span>
	<span class="nx">wire</span><span class="p">.</span><span class="nf">Build</span><span class="p">(</span><span class="nx">orderSet</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">controller</span><span class="p">.</span><span class="nx">OrderHandler</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><p>其中，<code>dao.NewOrderDao</code> 、<code>server.NewOrderServer</code> 以及 <code>controller.NewOrderHandler</code> 就是 <code>Provider</code>。</p>
<p>你会发现这里还调用 <code>wire.NewSet</code> 把他们整合在一起，赋值给了一个变量 <code>orderSet</code>。</p>
<p>其实是用到 <code>ProviderSet</code> 的概念。原理就是把一组相关的 <code>Provider</code> 进行打包。</p>
<p>这样的好处是:</p>
<ul>
<li>结构依赖清晰，便于阅读。</li>
<li>以组的形式，减少 <code>injector</code> 里的 <code>Build</code>。</li>
</ul>
<p>至于 <code>injector</code>，本质上就是按照依赖关系调用 <code>Provider</code> 的函数，然后最终生成我们想要的对象(服务)。</p>
<p>比如上面的 <code>ContainerByWire()</code> 就是一个 <code>injector</code>。</p>
<p>那么 <code>wire.go</code> 文件整体的思路就是:定义好 <code>injector</code>，然后实现所需的 <code>Provider</code>。</p>
<p>最后在当前 <code>wire.go</code> 文件夹下执行 <code>wire</code> 命令后，</p>
<p>此时如果你的依赖项存在问题，那么就会报错提示。比如我现在隐藏上面的 <code>dao.NewOrderDao</code>,那么会出现
<img src="https://image.syst.top/image/dig-to-wire/4.png" alt="image"></p>
<p>如果依赖不存在问题，最终会生成一个 <code>wire_gen.go</code> 文件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Code generated by Wire. DO NOT EDIT.
</span><span class="c1"></span>
<span class="c1">//go:generate go run github.com/google/wire/cmd/wire
</span><span class="c1">//+build !wireinject
</span><span class="c1"></span>
<span class="kn">package</span> <span class="nx">wire</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/google/wire&#34;</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/controller&#34;</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/dao&#34;</span>
	<span class="s">&#34;github.com/wuqinqiang/digvswire/server&#34;</span>
<span class="p">)</span>

<span class="c1">// Injectors from wire.go:
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">ContainerByWire</span><span class="p">()</span> <span class="o">*</span><span class="nx">controller</span><span class="p">.</span><span class="nx">OrderHandler</span> <span class="p">{</span>
	<span class="nx">orderDao</span> <span class="o">:=</span> <span class="nx">dao</span><span class="p">.</span><span class="nf">NewOrderDao</span><span class="p">()</span>
	<span class="nx">orderServerInterface</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">NewOrderServer</span><span class="p">(</span><span class="nx">orderDao</span><span class="p">)</span>
	<span class="nx">orderHandler</span> <span class="o">:=</span> <span class="nx">controller</span><span class="p">.</span><span class="nf">NewOrderHandler</span><span class="p">(</span><span class="nx">orderServerInterface</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">orderHandler</span>
<span class="p">}</span>

<span class="c1">// wire.go:
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">orderSet</span> <span class="p">=</span> <span class="nx">wire</span><span class="p">.</span><span class="nf">NewSet</span><span class="p">(</span><span class="nx">dao</span><span class="p">.</span><span class="nx">NewOrderDao</span><span class="p">,</span> <span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">,</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>

</code></pre></div><p>需要注意上面两个文件。我们看到 <code>wire.go</code> 中第一行 <code>//+build wireinject</code> ，这个 <code>build tag</code> 确保在常规编译时忽略 <code>wire.go</code> 文件。
而与之相对的 <code>wire_gen.go</code> 中的 <code>//+build !wireinject</code>。 两个对立的 <code>build tag</code> 是为了确保在任意情况下，两个文件只有一个文件生效，
避免出现 &ldquo;<code>ContainerByWire()</code> 方法被重新定义&rdquo; 的编译错误。</p>
<p>现在我们可以真正使用 <code>injector</code> 了，我们在入口文件中替换成 <code>dig</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">serverStart</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;init app err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">router</span><span class="p">.</span><span class="nf">RegisterRouterByWire</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">wire</span><span class="p">.</span><span class="nf">ContainerByWire</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8090&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RegisterRouterByWire</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span><span class="p">,</span> <span class="nx">handler</span> <span class="o">*</span><span class="nx">controller</span><span class="p">.</span><span class="nx">OrderHandler</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/v2/user/orders&#34;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">.</span><span class="nx">GetUserOrderList</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>一切正常。</p>
<p>当然 <code>wire</code> 有一个点需要注意，在 <code>wire.go</code> 文件中开头几行:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//+build wireinject
</span><span class="c1"></span>
<span class="kn">package</span> <span class="nx">wire</span>
</code></pre></div><p><code>build tag</code> 和 <code>package</code> 他们之间是有空行的，如果没有空行，<code>build tag</code> 识别不了，那么编译的时候就会报重复声明的错误：
<img src="https://image.syst.top/image/dig-to-wire/5.png" alt="image"></p>
<p>还有很多高级的操作可以自行了解。</p>
<h3 id="总结">总结</h3>
<p>以上大体介绍了 go 中 <code>dig</code> 和 <code>wire</code> 两个 <code>DI</code> 工具。其中 <code>dig</code> 是通过运行时反射实现的依赖注入。
而 <code>wire</code> 是根据自定义的代码，通过命令，生成相应的依赖注入代码，在编译期就完成依赖注入，无需反射机制。
这样的好处是：</p>
<ul>
<li>方便排查，如果存在依赖错误，编译时就能发现。而 <code>dig</code> 只能在运行时才能发现依赖错误。</li>
<li>避免依赖膨胀，<code>wire</code> 生成的代码只包含被依赖的，而 <code>dig</code> 可能会存在好多无用依赖。</li>
<li>依赖关系静态存在源码，便于工具分析。</li>
</ul>
<h3 id="reference">Reference</h3>
<p>[1]
<a href="https://github.com/google/wire">https://github.com/google/wire</a></p>
<p>[2]
<a href="https://github.com/uber-go/dig">https://github.com/uber-go/dig</a></p>
<p>[3]
<a href="https://medium.com/@dche423/master-wire-cn-d57de86caa1b">https://medium.com/@dche423/master-wire-cn-d57de86caa1b</a></p>
<p>[4]
<a href="https://www.cnblogs.com/li-peng/p/14708132.html">https://www.cnblogs.com/li-peng/p/14708132.html</a></p>
]]></content>
		</item>
		
		<item>
			<title>在Go中你犯过的错</title>
			<link>https://www.syst.top/posts/go/mistake/</link>
			<pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/mistake/</guid>
			<description>在迭代器变量上使用 goroutine 这算高频吧。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) func main() { var wg sync.WaitGroup items := []int{1, 2, 3, 4, 5} for index, _ := range items { wg.Add(1) go func() { defer wg.Done() fmt.Printf(&amp;#34;item:%v\n&amp;#34;, items[index]) }() } wg.Wait() } 一个很简单的利用 sync.waitGroup 做任务编排的场景，看一下好像没啥问题，运行看看结果。
为啥不是1-5(当然不是顺序的)。
原因很简单，循环器中的 i 实际上是一个单变量，go func 里的闭包只绑定在一个变量上， 每个 goroutine 可能要等到循环结束才真正的运行，这时候运行的 i 值大概率就是5了, 没人能保证这个过程，有的只是手段。
正确的做法
func main() { var wg sync.WaitGroup items := []int{1, 2, 3, 4, 5} for index, _ := range items { wg.</description>
			<content type="html"><![CDATA[<h3 id="在迭代器变量上使用-goroutine">在迭代器变量上使用 goroutine</h3>
<p>这算高频吧。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">items</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v\n&#34;</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div><p>一个很简单的利用 <code>sync.waitGroup</code> 做任务编排的场景，看一下好像没啥问题，运行看看结果。</p>
<p><img src="https://image.syst.top/image/mistake/mistake-1.png" alt="image"></p>
<p>为啥不是1-5(当然不是顺序的)。</p>
<p>原因很简单，循环器中的 i 实际上是一个单变量，<code>go func</code>  里的闭包只绑定在一个变量上，
每个 <code>goroutine</code> 可能要等到循环结束才真正的运行，这时候运行的 i 值大概率就是5了,
没人能保证这个过程，有的只是手段。</p>
<p>正确的做法</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

	<span class="nx">items</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v\n&#34;</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}(</span><span class="nx">index</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>通过将 <code>i</code>  作为一个参数传入闭包中，i 每次迭代都会被求值，
并放置在 <code>goroutine</code> 的堆栈中，因此每个切片元素最终都会被执行打印。</p>
<p>或者这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">i</span><span class="o">:=</span><span class="nx">index</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v\n&#34;</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}()</span>
	<span class="p">}</span>
</code></pre></div><h3 id="waitgroup">WaitGroup</h3>
<p>上面的例子有用到 <code>sync.waitGroup</code>，使用不当，也会犯错。</p>
<p>我把上面的例子稍微改动复杂一点点。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;github.com/prometheus/common/log&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">userId</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">userList</span> <span class="p">[]</span><span class="nx">User</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">userList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">userList</span><span class="p">,</span> <span class="nx">User</span><span class="p">{</span><span class="nx">userId</span><span class="p">:</span> <span class="nx">i</span><span class="p">})</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">userList</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">userList</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;err message:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	
	<span class="c1">// 处理其他事务
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">user</span> <span class="nx">User</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 处理杂七杂八的业务....
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">user</span><span class="p">.</span><span class="nx">userId</span> <span class="o">==</span> <span class="mi">9</span> <span class="p">{</span>
		<span class="c1">// 此人是非法用户
</span><span class="c1"></span>		<span class="k">return</span> <span class="s">&#34;失败&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;非法用户&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&#34;成功&#34;</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>发现问题严重性了吗？</p>
<p>当用户<code>id</code>等于9的时候，<code>err !=nil</code> 直接 <code>return</code> 了，导致 <code>waitGroup</code> 计数器根本没机会减1，
最终 <code>wait</code> 会阻塞，多么可怕的 <code>bug</code>。</p>
<p>在绝大多数的场景下，我们都必须这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">userList</span> <span class="p">[]</span><span class="nx">User</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">userList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">userList</span><span class="p">,</span> <span class="nx">User</span><span class="p">{</span><span class="nx">userId</span><span class="p">:</span> <span class="nx">i</span><span class="p">})</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">userList</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>

			<span class="c1">//....业务代码
</span><span class="c1"></span>			<span class="c1">//....业务代码
</span><span class="c1"></span>			<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">userList</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;err message:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h3 id="野生-goroutine">野生 goroutine</h3>
<p>我不知道你们公司是咋么处理异步操作的，是下面这样吗</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// doSomething
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// doSomething
</span><span class="c1"></span>	<span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><p>我们为了防止程序中出现不可预知的 <code>panic</code>，导致程序直接挂掉，都会加入 <code>recover</code>，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;处理失败&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>但是如果这时候我们直接开启一个 <code>goroutine</code>，在这个 <code>goroutine</code> 里面发生了  <code>panic</code>，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;处理失败&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>此时最外层的 <code>recover</code> 并不能捕获，程序会直接挂掉。
<img src="https://image.syst.top/image/mistake/mistake-2.png" alt="image"></p>
<p>但是你总不能每次开启一个新的 <code>goroutine</code> 就在里面 <code>recover</code>,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="c1">// func1
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}()</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;错误失败&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="c1">// func2
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}()</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;请求错误&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>多蠢啊。所以基本上大家都会包一层。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="c1">// func1
</span><span class="c1"></span>	<span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;错误失败&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="c1">// func2
</span><span class="c1"></span>	<span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;请求错误&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">RunSafe</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RunSafe</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;错误:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nf">fn</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>当然我这里只是简单都打印一些日志信息，一般还会带上堆栈都信息。</p>
<h3 id="channel">channel</h3>
<p><code>channel</code> 在 <code>go</code> 中的地位实在太高了，各大开源项目到处都是 <code>channel</code> 的影子，
以至于你在工业级的项目 issues 中搜索 <code>channel</code> ，能看到很多的 <code>bug</code>，
比如 etcd 这个 <code>issue</code>,
<img src="https://image.syst.top/image/mistake/mistake-3.png" alt="image"></p>
<p>一个往已关闭的 <code>channel</code> 中发送数据引发的 <code>panic</code>,等等类似场景很多。</p>
<p>这个故事告诉我们，否管大不大佬，改写的 <code>bug</code> 还是会写，手动狗头。</p>
<p><code>channel</code> 除了上述高频出现的错误，还有以下几点:</p>
<h4 id="直接关闭一个-nil-值-channel-会引发-panic">直接关闭一个 nil 值 channel 会引发 panic</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h4 id="关闭一个已关闭的-channel-会引发-panic">关闭一个已关闭的 channel 会引发 panic。</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>另外，有时候使用 <code>channel</code> 不小心会导致 <code>goroutine</code> 泄露，比如下面这种情况,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">cx</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine 结束&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;res&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">cx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;timeout&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p>启动一个 <code>goroutine</code> 去处理业务，业务需要执行2秒，而我们设置的超时时间是1秒。
这就会导致 <code>channel</code> 从未被读取，
我们知道没有缓冲的 <code>channel</code> 必须等发送方和接收方都准备好才能操作。
此时 <code>goroutine</code> 会被永久阻塞在  <code>ch &lt;- struct{}{}</code> 这行代码，除非程序结束。
而这就是 <code>goroutine</code> 泄露。</p>
<p>解决这个也很简单，把无缓冲的 <code>channel</code> 改成缓冲为1。</p>
<h3 id="总结">总结</h3>
<p>这篇文章主要介绍了使用 <code>Go</code> 在日常开发中容易犯下的错。
当然还远远不止这些，你可以在下方留言中补充你犯过的错。</p>
]]></content>
		</item>
		
		<item>
			<title>如何优雅地实现并发编排任务</title>
			<link>https://www.syst.top/posts/go/mr/</link>
			<pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/mr/</guid>
			<description>业务场景 在做任务开发的时候，你们一定会碰到以下场景:
场景1：调用第三方接口的时候， 一个需求你需要调用不同的接口，做数据组装。 场景2:一个应用首页可能依托于很多服务。那就涉及到在加载页面时需要同时请求多个服务的接口。这一步往往是由后端统一调用组装数据再返回给前端，也就是所谓的 BFF(Backend For Frontend) 层。
针对以上两种场景，假设在没有强依赖关系下，选择串行调用，那么总耗时即:
time=s1+s2+....sn 按照当代秒入百万的有为青年，这么长时间早就把你祖宗十八代问候了一遍。
为了伟大的KPI，我们往往会选择并发地调用这些依赖接口。那么总耗时就是:
time=max(s1,s2,s3.....,sn) 当然开始堆业务的时候可以先串行化，等到上面的人着急的时候，亮出绝招。
这样，年底 PPT 就可以加上浓重的一笔流水账:为业务某个接口提高百分之XXX性能，间接产生XXX价值。
当然这一切的前提是，做老板不懂技术，做技术”懂”你。
言归正传,如果修改成并发调用，你可能会这么写，
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) func main() { var wg sync.WaitGroup wg.Add(2) var userInfo *User var productList []Product go func() { defer wg.Done() userInfo, _ = getUser() }() go func() { defer wg.Done() productList, _ = getProductList() }() wg.Wait() fmt.Printf(&amp;#34;用户信息:%+v\n&amp;#34;, userInfo) fmt.Printf(&amp;#34;商品信息:%+v\n&amp;#34;, productList) } /********用户服务**********/ type User struct { Name string Age uint8 } func getUser() (*User, error) { time.</description>
			<content type="html"><![CDATA[<h3 id="业务场景">业务场景</h3>
<p>在做任务开发的时候，你们一定会碰到以下场景:</p>
<p>场景1：调用第三方接口的时候， 一个需求你需要调用不同的接口，做数据组装。
场景2:一个应用首页可能依托于很多服务。那就涉及到在加载页面时需要同时请求多个服务的接口。这一步往往是由后端统一调用组装数据再返回给前端，也就是所谓的 BFF(Backend For Frontend) 层。</p>
<p>针对以上两种场景，假设在没有强依赖关系下，选择串行调用，那么总耗时即:</p>
<pre><code>time=s1+s2+....sn
</code></pre><p>按照当代秒入百万的有为青年，这么长时间早就把你祖宗十八代问候了一遍。</p>
<p>为了伟大的KPI，我们往往会选择并发地调用这些依赖接口。那么总耗时就是:</p>
<pre><code>time=max(s1,s2,s3.....,sn)
</code></pre><p>当然开始堆业务的时候可以先串行化，等到上面的人着急的时候，亮出绝招。</p>
<p>这样，年底 PPT 就可以加上浓重的一笔流水账:为业务某个接口提高百分之XXX性能，间接产生XXX价值。</p>
<p>当然这一切的前提是，做老板不懂技术，做技术”懂”你。</p>
<p>言归正传,如果修改成并发调用，你可能会这么写，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">userInfo</span> <span class="o">*</span><span class="nx">User</span>
	<span class="kd">var</span> <span class="nx">productList</span> <span class="p">[]</span><span class="nx">Product</span>
	
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nx">userInfo</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">getUser</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nx">productList</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">getProductList</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;用户信息:%+v\n&#34;</span><span class="p">,</span> <span class="nx">userInfo</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;商品信息:%+v\n&#34;</span><span class="p">,</span> <span class="nx">productList</span><span class="p">)</span>
<span class="p">}</span>


<span class="cm">/********用户服务**********/</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">Age</span>  <span class="kt">uint8</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getUser</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">u</span> <span class="nx">User</span>
	<span class="nx">u</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;wuqinqiang&#34;</span>
	<span class="nx">u</span><span class="p">.</span><span class="nx">Age</span> <span class="p">=</span> <span class="mi">18</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">u</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="cm">/********商品服务**********/</span>

<span class="kd">type</span> <span class="nx">Product</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Title</span> <span class="kt">string</span>
	<span class="nx">Price</span> <span class="kt">uint32</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getProductList</span><span class="p">()</span> <span class="p">([]</span><span class="nx">Product</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">400</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">list</span> <span class="p">[]</span><span class="nx">Product</span>
	<span class="nx">list</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">Product</span><span class="p">{</span>
		<span class="nx">Title</span><span class="p">:</span> <span class="s">&#34;SHib&#34;</span><span class="p">,</span>
		<span class="nx">Price</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="k">return</span> <span class="nx">list</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>先不管其他问题。从实现上来说，需要多少服务，你会开多少个 <code>G</code>，利用 <code>sync.WaitGroup</code> 的特性，
实现并发编排任务的效果。</p>
<p>好像，问题不大。</p>
<p>但是随着代号 <code>996</code> 业务场景的增加，你会发现，好多模块都有相似的功能，只是对应的业务场景不同而已。</p>
<p>那么我们能不能抽像出一套针对此业务场景的工具，而把具体业务实现交给业务方。</p>
<p>安排。</p>
<h3 id="使用">使用</h3>
<p>本着不重复造轮子的原则，去搜了下开源项目，最终看上了 <code>go-zero</code> 里面的一个工具 <code>mapreduce</code>。
从文件名我们能看出来是什么了，可以自行 <code>Google</code> 这个名词。</p>
<p>使用很简单。我们通过它改造一下上面的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/tal-tech/go-zero/core/mr&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">userInfo</span> <span class="o">*</span><span class="nx">User</span>
	<span class="kd">var</span> <span class="nx">productList</span> <span class="p">[]</span><span class="nx">Product</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">mr</span><span class="p">.</span><span class="nf">Finish</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">userInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">getUser</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">},</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">productList</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">getProductList</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">})</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;用户信息:%+v\n&#34;</span><span class="p">,</span> <span class="nx">userInfo</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;商品信息:%+v\n&#34;</span><span class="p">,</span> <span class="nx">productList</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><pre><code>用户信息:&amp;{Name:wuqinqiang Age:18}
商品信息:[{Title:SHib Price:10}]
</code></pre><p>是不是舒服多了。</p>
<p>但是这里还需要注意一点，假设你调用的其中一个服务错误，并且你 <code>return err</code> 对应的错误，那么其他调用的服务会被取消。
比如我们修改 getProductList 直接响应错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getProductList</span><span class="p">()</span> <span class="p">([]</span><span class="nx">Product</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;test error&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//打印
</span><span class="c1"></span><span class="nx">用户信息</span><span class="p">:&lt;</span><span class="kc">nil</span><span class="p">&gt;</span>
<span class="nx">商品信息</span><span class="p">:[]</span>
</code></pre></div><p>那么最终打印的时候连用户信息都会为空，因为出现一个服务错误，用户服务请求被取消了。</p>
<p>一般情况下，在请求服务错误的时候我们会有保底操作，一个服务错误不能影响其他请求的结果。
所以在使用的时候具体处理取决于业务场景。</p>
<h3 id="源码">源码</h3>
<p>既然用了，那么就追下源码吧。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Finish</span><span class="p">(</span><span class="nx">fns</span> <span class="o">...</span><span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">fns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">MapReduceVoid</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">source</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fns</span> <span class="p">{</span>
			<span class="nx">source</span> <span class="o">&lt;-</span> <span class="nx">fn</span>
		<span class="p">}</span>
	<span class="p">},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">writer</span> <span class="nx">Writer</span><span class="p">,</span> <span class="nx">cancel</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">item</span><span class="p">.(</span><span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">fn</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">cancel</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">pipe</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cancel</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">drain</span><span class="p">(</span><span class="nx">pipe</span><span class="p">)</span>
	<span class="p">},</span> <span class="nf">WithWorkers</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">fns</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MapReduceVoid</span><span class="p">(</span><span class="nx">generator</span> <span class="nx">GenerateFunc</span><span class="p">,</span> <span class="nx">mapper</span> <span class="nx">MapperFunc</span><span class="p">,</span> <span class="nx">reducer</span> <span class="nx">VoidReducerFunc</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">MapReduce</span><span class="p">(</span><span class="nx">generator</span><span class="p">,</span> <span class="nx">mapper</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">input</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">writer</span> <span class="nx">Writer</span><span class="p">,</span> <span class="nx">cancel</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">reducer</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
		<span class="nf">drain</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
		<span class="c1">// We need to write a placeholder to let MapReduce to continue on reducer done,
</span><span class="c1"></span>		<span class="c1">// otherwise, all goroutines are waiting. The placeholder will be discarded by MapReduce.
</span><span class="c1"></span>		<span class="nx">writer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">lang</span><span class="p">.</span><span class="nx">Placeholder</span><span class="p">)</span>
	<span class="p">},</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><p>对于 <code>MapReduceVoid</code>函数，主要查看三个闭包参数。</p>
<ul>
<li>第一个 <code>GenerateFunc</code> 用于生产数据。</li>
<li><code>MapperFunc</code> 读取生产出的数据，进行处理。</li>
<li><code>VoidReducerFunc</code> 这里表示不对 <code>mapper</code> 后的数据做聚合返回。所以这个闭包在此操作几乎0作用。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MapReduce</span><span class="p">(</span><span class="nx">generate</span> <span class="nx">GenerateFunc</span><span class="p">,</span> <span class="nx">mapper</span> <span class="nx">MapperFunc</span><span class="p">,</span> <span class="nx">reducer</span> <span class="nx">ReducerFunc</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">source</span> <span class="o">:=</span> <span class="nf">buildSource</span><span class="p">(</span><span class="nx">generate</span><span class="p">)</span> 
	<span class="k">return</span> <span class="nf">MapReduceWithSource</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">mapper</span><span class="p">,</span> <span class="nx">reducer</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">buildSource</span><span class="p">(</span><span class="nx">generate</span> <span class="nx">GenerateFunc</span><span class="p">)</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">source</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span><span class="c1">// 创建无缓冲通道
</span><span class="c1"></span>	<span class="nx">threading</span><span class="p">.</span><span class="nf">GoSafe</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
		<span class="nf">generate</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="c1">//开始生产数据
</span><span class="c1"></span>	<span class="p">})</span>

	<span class="k">return</span> <span class="nx">source</span> <span class="c1">//返回无缓冲通道
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>buildSource</code>函数中，返回一个无缓冲的通道。并开启一个 <code>G</code> 运行 <code>generate(source)</code>，往无缓冲通道塞数据。 这个<code>generate(source)</code> 不就是一开始 <code>Finish</code> 传递的第一个闭包参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">return</span> <span class="nf">MapReduceVoid</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">source</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="c1">// 就这个
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fns</span> <span class="p">{</span>
			<span class="nx">source</span> <span class="o">&lt;-</span> <span class="nx">fn</span>
		<span class="p">}</span>
	<span class="p">})</span>
</code></pre></div><p>然后查看 <code>MapReduceWithSource</code> 函数,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MapReduceWithSource</span><span class="p">(</span><span class="nx">source</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">mapper</span> <span class="nx">MapperFunc</span><span class="p">,</span> <span class="nx">reducer</span> <span class="nx">ReducerFunc</span><span class="p">,</span>
	<span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">options</span> <span class="o">:=</span> <span class="nf">buildOptions</span><span class="p">(</span><span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="c1">//任务执行结束通知信号
</span><span class="c1"></span>	<span class="nx">output</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
    <span class="c1">//将mapper处理完的数据写入collector
</span><span class="c1"></span>    <span class="nx">collector</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">options</span><span class="p">.</span><span class="nx">workers</span><span class="p">)</span>
    <span class="c1">// 取消操作信号
</span><span class="c1"></span>	<span class="nx">done</span> <span class="o">:=</span> <span class="nx">syncx</span><span class="p">.</span><span class="nf">NewDoneChan</span><span class="p">()</span>
	<span class="nx">writer</span> <span class="o">:=</span> <span class="nf">newGuardedWriter</span><span class="p">(</span><span class="nx">output</span><span class="p">,</span> <span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">())</span>
	<span class="kd">var</span> <span class="nx">closeOnce</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="kd">var</span> <span class="nx">retErr</span> <span class="nx">errorx</span><span class="p">.</span><span class="nx">AtomicError</span>
	<span class="nx">finish</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">closeOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">done</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="nb">close</span><span class="p">(</span><span class="nx">output</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="nx">cancel</span> <span class="o">:=</span> <span class="nf">once</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">retErr</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">retErr</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">ErrCancelWithNil</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nf">drain</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
		<span class="nf">finish</span><span class="p">()</span>
	<span class="p">})</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">cancel</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">))</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nf">finish</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}()</span>
		<span class="nf">reducer</span><span class="p">(</span><span class="nx">collector</span><span class="p">,</span> <span class="nx">writer</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
		<span class="nf">drain</span><span class="p">(</span><span class="nx">collector</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="c1">// 真正从生成器通道取数据执行Mapper
</span><span class="c1"></span>	<span class="k">go</span> <span class="nf">executeMappers</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">w</span> <span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">mapper</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
	<span class="p">},</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">collector</span><span class="p">,</span> <span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">(),</span> <span class="nx">options</span><span class="p">.</span><span class="nx">workers</span><span class="p">)</span>

	<span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">output</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">retErr</span><span class="p">.</span><span class="nf">Load</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrReduceNoOutput</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这段代码挺长的，我们说下核心的点。我们看到使用一个<code>G</code> 调用 <code>executeMappers</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nf">executeMappers</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">w</span> <span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">mapper</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
	<span class="p">},</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">collector</span><span class="p">,</span> <span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">(),</span> <span class="nx">options</span><span class="p">.</span><span class="nx">workers</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">executeMappers</span><span class="p">(</span><span class="nx">mapper</span> <span class="nx">MapFunc</span><span class="p">,</span> <span class="nx">input</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">collector</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{},</span>
	<span class="nx">done</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">lang</span><span class="p">.</span><span class="nx">PlaceholderType</span><span class="p">,</span> <span class="nx">workers</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 等待所有任务全部执行完毕
</span><span class="c1"></span>		<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
		<span class="c1">// 关闭通道
</span><span class="c1"></span>		<span class="nb">close</span><span class="p">(</span><span class="nx">collector</span><span class="p">)</span>
	<span class="p">}()</span>
   <span class="c1">//根据指定数量创建 worker池
</span><span class="c1"></span>	<span class="nx">pool</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">lang</span><span class="p">.</span><span class="nx">PlaceholderType</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span> 
	<span class="nx">writer</span> <span class="o">:=</span> <span class="nf">newGuardedWriter</span><span class="p">(</span><span class="nx">collector</span><span class="p">,</span> <span class="nx">done</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="nx">pool</span> <span class="o">&lt;-</span> <span class="nx">lang</span><span class="p">.</span><span class="nx">Placeholder</span><span class="p">:</span>
			<span class="c1">// 从buildSource() 返回的无缓冲通道取数据
</span><span class="c1"></span>			<span class="nx">item</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">input</span> 
			<span class="c1">// 当通道关闭，结束
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="o">&lt;-</span><span class="nx">pool</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="c1">// better to safely run caller defined method
</span><span class="c1"></span>			<span class="nx">threading</span><span class="p">.</span><span class="nf">GoSafe</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
					<span class="o">&lt;-</span><span class="nx">pool</span>
				<span class="p">}()</span>
				<span class="c1">//真正运行闭包函数的地方
</span><span class="c1"></span>               <span class="c1">// func(item interface{}, w Writer) {
</span><span class="c1"></span>               <span class="c1">//    mapper(item, w, cancel)
</span><span class="c1"></span>               <span class="c1">//    }
</span><span class="c1"></span>				<span class="nf">mapper</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span>
			<span class="p">})</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>具体的逻辑已备注，代码很容易懂。</p>
<p>一旦 <code>executeMappers</code> 函数返回，关闭 <code>collector</code> 通道，那么执行 <code>reducer</code> 不再阻塞。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">cancel</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">))</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nf">finish</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}()</span>
		<span class="nf">reducer</span><span class="p">(</span><span class="nx">collector</span><span class="p">,</span> <span class="nx">writer</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
		<span class="c1">//这里
</span><span class="c1"></span>		<span class="nf">drain</span><span class="p">(</span><span class="nx">collector</span><span class="p">)</span>
	<span class="p">}()</span>
</code></pre></div><p>这里的 <code>reducer(collector, writer, cancel)</code> 其实就是从 <code>MapReduceVoid</code> 传递的第三个闭包函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MapReduceVoid</span><span class="p">(</span><span class="nx">generator</span> <span class="nx">GenerateFunc</span><span class="p">,</span> <span class="nx">mapper</span> <span class="nx">MapperFunc</span><span class="p">,</span> <span class="nx">reducer</span> <span class="nx">VoidReducerFunc</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">MapReduce</span><span class="p">(</span><span class="nx">generator</span><span class="p">,</span> <span class="nx">mapper</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">input</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">writer</span> <span class="nx">Writer</span><span class="p">,</span> <span class="nx">cancel</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">reducer</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
		<span class="c1">//这里
</span><span class="c1"></span>		<span class="nf">drain</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
		<span class="c1">// We need to write a placeholder to let MapReduce to continue on reducer done,
</span><span class="c1"></span>		<span class="c1">// otherwise, all goroutines are waiting. The placeholder will be discarded by MapReduce.
</span><span class="c1"></span>		<span class="nx">writer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">lang</span><span class="p">.</span><span class="nx">Placeholder</span><span class="p">)</span>
	<span class="p">},</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><p>然后这个闭包函数又执行了 <code>reducer(input, cancel)</code>，这里的 <code>reducer</code> 就是我们一开始解释过的 <code>VoidReducerFunc</code>，从 <code>Finish() 而来</code>。</p>
<p><img src="https://image.syst.top/image/mr/mr.png" alt="image"></p>
<p>等等,看到上面三个地方的 <code>drain(input)</code>了吗？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// drain drains the channel.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">drain</span><span class="p">(</span><span class="nx">channel</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="c1">// drain the channel
</span><span class="c1"></span>	<span class="k">for</span> <span class="k">range</span> <span class="nx">channel</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>其实就是一个排空 <code>channel</code> 的操作，但是三个地方都对同一个 <code>channel</code>,也是让我费解。</p>
<p>还有更重要的一点。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">cancel</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">))</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nf">finish</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}()</span>
		<span class="nf">reducer</span><span class="p">(</span><span class="nx">collector</span><span class="p">,</span> <span class="nx">writer</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
		<span class="nf">drain</span><span class="p">(</span><span class="nx">collector</span><span class="p">)</span>
	<span class="p">}()</span>
</code></pre></div><p>上面的代码，假如执行 <code>reducer</code>，<code>writer</code> 写入引发 <code>panic</code>,那么<code>drain(collector)</code> 会直接卡住。</p>
<p>不过作者已经修复了这个问题，直接把 <code>drain(collector)</code> 放入到 <code>defer</code>。
<img src="https://image.syst.top/image/mr/mr-2.png" alt="image"></p>
<p>具体 issues[1]。</p>
<p>到这里，关于 <code>Finish</code> 的源码也就结束了。感兴趣的可以看看其他源码。</p>
<p>很喜欢 <code>go-zero</code> 里的一些工具，但是往往用的一些工具并不独立，
依赖于其他文件包，导致明明只想使用其中一个工具却需要安装整个包。
所以最终的结果就是扒源码，创建无依赖库工具集，遵循 <code>MIT</code> 即可。</p>
<p>附录
[1]
<a href="https://github.com/tal-tech/go-zero/issues/676">https://github.com/tal-tech/go-zero/issues/676</a></p>
]]></content>
		</item>
		
		<item>
			<title>etcd 实战基础篇(一) </title>
			<link>https://www.syst.top/posts/go/etcd-2021-04-10/</link>
			<pubDate>Sat, 10 Apr 2021 09:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/etcd-2021-04-10/</guid>
			<description>最近一直在看 etcd 相关的东西，为了不&amp;quot;白看&amp;quot;，加深理解，随即开启此系列的输出。
Etcd是什么 Etcd 是由 Go 编写的。它是一个强一致性的分布式键值存储，提供一种可靠的方式来存储需要由分布式系统或者机器集群访问的数据。 同时 Etcd 各节点中的通信是通过 Raft 一致性算法来处理的。 有很多大型开源项目的底层都基于 Etcd，举几个比较有名的工业级项目:kubernetes、 CoreDNS、ROOK&amp;hellip;&amp;hellip;
Etcd 的场景  服务发现。(可以把服务存储到某个 prefix 开头的 key中，然后消费端或者服务信息以调用， 同时消费者也可以通过 watch 获得 key 的变化) 消息分布和订阅 分布式锁 Leader 选举 分布式队列 负载均衡 &amp;hellip;&amp;hellip;  和 redis 的区别 面试的时候可能有面试官喜欢问，
 redis 的数据类型更丰富(string, hash, set ,zset, list)，etcd 仅仅就是 key-val。 etcd 的底层是 Raft 算法，可以保证数据的强一致性。而 redis 数据复制上是主备异步复制，只能最终一致性。 读写性能上，因为 etcd 保证强一致性，所以会比 redis 差。 存储方面，etcd 使用的是持久化存储boltdb，而 redis 的方案是可持久化的 aof/rdb -&amp;hellip;&amp;hellip;  环境与说明 直接下载编译好的二进制文件也好，还是自己下载源码编译运行，先开启一个单节点服务就行。我本地使用 goreman 搭建了三个实例。 这里稍微说明一下:PEER ADDRS 指的是向其他 etcd server 暴露的通信地址,比如上图 name=infra1 要调用 infra2， 调用的就是 http://127.</description>
			<content type="html"><![CDATA[<p>最近一直在看 etcd 相关的东西，为了不&quot;白看&quot;，加深理解，随即开启此系列的输出。</p>
<h3 id="etcd是什么">Etcd是什么</h3>
<p>Etcd 是由 Go 编写的。它是一个强一致性的分布式键值存储，提供一种可靠的方式来存储需要由分布式系统或者机器集群访问的数据。 同时 Etcd 各节点中的通信是通过 Raft 一致性算法来处理的。
有很多大型开源项目的底层都基于 Etcd，举几个比较有名的工业级项目:kubernetes、 CoreDNS、ROOK&hellip;&hellip;</p>
<h3 id="etcd-的场景">Etcd 的场景</h3>
<ul>
<li>服务发现。(可以把服务存储到某个 prefix 开头的 key中，然后消费端或者服务信息以调用， 同时消费者也可以通过 watch 获得 key 的变化)</li>
<li>消息分布和订阅</li>
<li>分布式锁</li>
<li>Leader 选举</li>
<li>分布式队列</li>
<li>负载均衡</li>
<li>&hellip;&hellip;</li>
</ul>
<h3 id="和-redis-的区别">和 redis 的区别</h3>
<p>面试的时候可能有面试官喜欢问，</p>
<ul>
<li>redis 的数据类型更丰富(string, hash, set ,zset, list)，etcd 仅仅就是 key-val。</li>
<li>etcd 的底层是 Raft 算法，可以保证数据的强一致性。而 redis 数据复制上是主备异步复制，只能最终一致性。</li>
<li>读写性能上，因为 etcd 保证强一致性，所以会比 redis 差。</li>
<li>存储方面，etcd 使用的是持久化存储boltdb，而 redis 的方案是可持久化的 aof/rdb
-&hellip;&hellip;</li>
</ul>
<h3 id="环境与说明">环境与说明</h3>
<p>直接下载编译好的二进制文件也好，还是自己下载源码编译运行，先开启一个单节点服务就行。我本地使用 goreman 搭建了三个实例。
<img src="https://image.syst.top/image/etcd/peer.png" alt="image">
这里稍微说明一下:<code>PEER ADDRS</code> 指的是向其他 <code>etcd server</code> 暴露的通信地址,比如上图 <code>name=infra1</code> 要调用 <code>infra2</code>，
调用的就是 <code>http://127.0.0.1:22380</code>。 而 <code>CLIENT ADDRS</code> 是对客户端暴露的地址。比如接下来我们的客户端连接的是 <code>infra1</code>，使用的就是 <code>http://127.0.0.1:2379</code>。</p>
<p>目前网上的教程大多使用编译好的 etcdctl 这样的二进制文件，通过命令行来进行操作,简单直观。比如:
<img src="https://image.syst.top/image/etcd/etcd-ctl.png" alt="image"></p>
<p>但是也会导致一个问题，你并不知道客户端底层是如何运行的，这中间又涉及了哪些接口，对应的数据结构是什么样的。 所以为了一步步深入 etcd，我们从代码层面操作 etcd 客户端。</p>
<p>以下是本篇文章涉及到的全部代码,下面我们开始分块讲解.</p>
<h3 id="初始化-etcd-客户端">初始化 etcd 客户端</h3>
<p>我们先初始化一个 etcd 客户端</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">cli</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>

<span class="c1">// 初始化etcd 客户端
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// 解析etcd的地址，编程[]string
</span><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="c1">// 创建一个 etcd 的客户端
</span><span class="c1"></span>	<span class="nx">cli</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="put-操作">put 操作</h3>
<p>命令行 <code>etcdctl put key val</code> 对应操作</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 设置key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>除了简单的设置，我们还有一种租约模式，也就是设置一个key的有效期，在有效期之内可以进行续租，如果没续租到期就过期。 对应的命令行是分两段:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">etcdctl</span> <span class="nx">lease</span> <span class="nx">grant</span> <span class="mi">200</span>
<span class="c1">// lease 326978bac638650a granted with TTL(200s)
</span><span class="c1"></span><span class="nx">etcdctl</span> <span class="nx">put</span> <span class="nx">hello</span> <span class="nx">world</span> <span class="o">--</span><span class="nx">lease</span><span class="p">=</span><span class="mi">326978</span><span class="nx">bac638650a</span>
</code></pre></div><p>对应操作</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 设置会过期的key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKeyLease</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ttl</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>

	<span class="c1">// 创建一个租约对象
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">lease</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">Lease</span>
	<span class="nx">lease</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">NewLease</span><span class="p">(</span><span class="nx">cli</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">leaseResp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseGrantResponse</span>
	<span class="c1">// 根据时间，生成一个租约
</span><span class="c1"></span>	<span class="nx">leaseResp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">lease</span><span class="p">.</span><span class="nf">Grant</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">ttl</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 租约 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseResp</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>etcd 的租约模式，简单的说， 当 Lease server 收到 client 请求，比如上面创建一个有效期200秒的请求，会通过 Raft
模块完成日志同步， 随后 Apply 模块的 Grant 接口执行日志条目内容。这是后续我们要研究的，这里略微提一下。</p>
<p>首先你得创建一个 Lease(租约)，获取到一个 Lease 唯一id，然后 put 的时候带上这个 id。当一个 key 指定一个 Lease 的时候，
底层最终是会把这个 key 关联到 Lease 的内存集合中。所以本质上，一个 Lease 可以 关联 n 个 key。而我们平常使用的缓存 key 设置过期时间，一般是把 key 和过期时间一对一绑定。</p>
<p>可能有人还要问，Lease 到期了是如何删除掉关联的 key？</p>
<p>其实原理说起来也很简单。Lease 在底层存储的结构是堆。由一个异步的 G 专门负责的去淘汰过期的 Lease。定时从最小堆中取出已经到期的 Lease。 然后删除 Lease 以及 删除通过 LeaseId 关联上此 Lease 的
key 列表。后面我们分析源码的时候专门讨论这块。</p>
<p>这里我还要说一点，你可以看到，不管是 put 一个普通的 key，还是一个带有租约的 key，调用的都是同一个方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 普通的
</span><span class="c1"></span>	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="c1">// 租约
</span><span class="c1"></span>	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseResp</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
	
<span class="c1">// 源码里面
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">OpOption</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Op</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseID</span> <span class="nx">LeaseID</span><span class="p">)</span> <span class="nx">OpOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">op</span> <span class="o">*</span><span class="nx">Op</span><span class="p">)</span> <span class="p">{</span> <span class="nx">op</span><span class="p">.</span><span class="nx">leaseID</span> <span class="p">=</span> <span class="nx">leaseID</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">op</span> <span class="o">*</span><span class="nx">Op</span><span class="p">)</span> <span class="nf">applyOpts</span><span class="p">(</span><span class="nx">opts</span> <span class="p">[]</span><span class="nx">OpOption</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
		<span class="nf">opt</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>看出来了吗？一个很常见的设计模式，装饰器。</p>
<h3 id="get-操作">Get 操作</h3>
<p>命令行 <code>etcdctl get key</code> 对应操作,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;获取 key 失败 :%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key %v 的值是：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们都知道，etcd从 v3 开始，底层实现了 MVCC 机制。所以在 etcd 中的 key 是存在多个历史版本的。
我们会在命令行中 <code>etcdctl get hello --rev=?</code>,比如
<img src="https://image.syst.top/image/etcd/rev-1.png" alt="image">
可以看到，不同版本的 key(&ldquo;hello&rdquo;)的值是不一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 获取指定版本的key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">version</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithRev</span><span class="p">(</span><span class="nx">version</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;删除 key:%v 失败:%v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;请求key:%v,请求版本:%v,获取结果：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</code></pre></div><p>一样的套路。我们也可以运行这段代码演示一下。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">src</span><span class="p">.</span><span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="nx">src</span><span class="p">.</span><span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
</code></pre></div><p><img src="https://image.syst.top/image/etcd/rev-2.png" alt="image">
其他参数暂时忽略，主要看 Kvs 里面的结果。</p>
<h3 id="watch-操作">Watch 操作</h3>
<p>命令行 <code>./etcdctl watch hello</code></p>
<p>为了避免客户端的反复轮询， etcd 提供了 event 机制。客户端可以订阅一系列的 event ，用于 watch 某些 key 。
当这些被 watch 的 key 更新时， etcd 就会通知客户端。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 监听key 变动
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WatchKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">watch</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">WatchChan</span>
	<span class="nx">watch</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Watch</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">watch</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key:%v变动通知：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;值:%+v\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">res</span><span class="p">.</span><span class="nx">Events</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><p>可以从上面这段代码看出，watch 是通过 channel 的方式来进行通知的</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 开启一个 G
</span><span class="c1">//	go src.WatchKey(&#34;hello&#34;)
</span></code></pre></div><p>然后我们运行这段程序，在命令行上操作 hello 这个 key，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="p">.</span><span class="o">/</span><span class="nx">etcdctl</span> <span class="nx">lease</span> <span class="nx">grant</span> <span class="mi">30</span>
<span class="nx">lease</span> <span class="mi">326978</span><span class="nx">bac638651e</span> <span class="nx">granted</span> <span class="nx">with</span> <span class="nf">TTL</span><span class="p">(</span><span class="mi">30</span><span class="nx">s</span><span class="p">)</span>
<span class="p">.</span><span class="o">/</span><span class="nx">etcdctl</span> <span class="nx">put</span> <span class="nx">hello</span> <span class="nx">world</span><span class="o">-</span><span class="nx">age</span> <span class="o">--</span><span class="nx">lease</span><span class="p">=</span><span class="mi">326978</span><span class="nx">bac638651e</span>
</code></pre></div><p><img src="https://image.syst.top/image/etcd/watch.png" alt="image">
可以看到接收到两个事件，一个是 put，一个是租约到期 delete。</p>
<h3 id="总结">总结</h3>
<p>以下是这篇文章全部代码</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">src</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">cli</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>

<span class="c1">// 初始化etcd 客户端
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// 解析etcd的地址，编程[]string
</span><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="c1">// 创建一个 etcd 的客户端
</span><span class="c1"></span>	<span class="nx">cli</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 设置key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 设置会过期的key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKeyLease</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ttl</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>

	<span class="c1">// 创建一个租约对象
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">lease</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">Lease</span>
	<span class="nx">lease</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">NewLease</span><span class="p">(</span><span class="nx">cli</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">leaseResp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseGrantResponse</span>
	<span class="c1">// 根据时间，生成一个租约
</span><span class="c1"></span>	<span class="nx">leaseResp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">lease</span><span class="p">.</span><span class="nf">Grant</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">ttl</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 租约 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseResp</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 获取key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;获取 key 失败 :%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key %v 的值是：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 获取指定版本的key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">version</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithRev</span><span class="p">(</span><span class="nx">version</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;删除 key:%v 失败:%v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;请求key:%v,请求版本:%v,获取结果：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 删除key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeleteKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">DeleteResponse</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;删除 key:%v 失败:%v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%+v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 监听key 变动
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WatchKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">watch</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">WatchChan</span>
	<span class="nx">watch</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Watch</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithRev</span><span class="p">(</span><span class="mi">21</span><span class="p">))</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">watch</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key:%v变动通知：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;值:%+v\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">res</span><span class="p">.</span><span class="nx">Events</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>

<span class="p">}</span>

</code></pre></div><p>这篇文章主要介绍了etcd这个分布式存储工具，包括它的应用场景以及实战基本的操作。
上面其实还有很多的实例没有写出来，一个是因为懒，没必要一个个演示一遍，另一个原因是留给你们自行实现。
我们以这个为开始，一步步敲开 etcd 的大门。</p>
]]></content>
		</item>
		
		<item>
			<title>etcd 实战基础篇(二) </title>
			<link>https://www.syst.top/posts/go/etcd-2021-04-15/</link>
			<pubDate>Sat, 10 Apr 2021 09:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/etcd-2021-04-15/</guid>
			<description>上一篇我们主要介绍了 etcd 使用场景以及最基础性的一些操作(put、get、watch)。 这一篇我们接着实战etcd其他业务场景。
基于 etcd 的分布式锁 基于 etcd 实现一个分布式锁特别简单。etcd 提供了开箱即用的包 concurrency，几行代码就实现一个分布式锁。
package src import ( &amp;#34;context&amp;#34; &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/coreos/etcd/clientv3&amp;#34; &amp;#34;github.com/coreos/etcd/clientv3/concurrency&amp;#34; &amp;#34;log&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;time&amp;#34; ) var addr = flag.String(&amp;#34;addr&amp;#34;, &amp;#34;http://127.0.0.1:2379&amp;#34;, &amp;#34;etcd address&amp;#34;) // 初始化etcd客户端 func initEtcdClient() *clientv3.Client { var client *clientv3.Client var err error // 解析etcd的地址，编程[]string 	endpoints := strings.Split(*addr, &amp;#34;,&amp;#34;) // 创建一个 etcd 的客户端 	client, err = clientv3.New(clientv3.Config{Endpoints: endpoints, DialTimeout: 5 * time.Second}) if err != nil { fmt.</description>
			<content type="html"><![CDATA[<p>上一篇我们主要介绍了 etcd 使用场景以及最基础性的一些操作(put、get、watch)。 这一篇我们接着实战etcd其他业务场景。</p>
<h3 id="基于-etcd-的分布式锁">基于 etcd 的分布式锁</h3>
<p>基于 etcd 实现一个分布式锁特别简单。etcd 提供了开箱即用的包 <code>concurrency</code>，几行代码就实现一个分布式锁。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">src</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
	<span class="s">&#34;github.com/coreos/etcd/clientv3/concurrency&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>

<span class="c1">// 初始化etcd客户端
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">initEtcdClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// 解析etcd的地址，编程[]string
</span><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="c1">// 创建一个 etcd 的客户端
</span><span class="c1"></span>	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">client</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Lock</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">lockName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="c1">// 创建一个 session,如果程序宕机奔溃，etcd可以知道
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewSession</span><span class="p">(</span><span class="nx">client</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="c1">// 创建一个etcd  locker
</span><span class="c1"></span>	<span class="nx">locker</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewLocker</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;id：%v 尝试获取锁%v&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
	<span class="nx">locker</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;id:%v取得锁%v&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>

	<span class="c1">// 模拟业务耗时
</span><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">300</span><span class="p">)</span>

	<span class="nx">locker</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;id:%v释放锁%v&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们再写个脚本运行，看看结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;etcd-test/src&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">lockName</span> <span class="p">=</span> <span class="s">&#34;locker-test&#34;</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">src</span><span class="p">.</span><span class="nf">Lock</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>我们发起了10个并发抢同一个 key 锁的命令。运行结果如下，
<img src="https://image.syst.top/image/etcd/lock.png" alt="image"></p>
<p>从图片可以看到，同一时刻一定只有一个 G 得到锁，一个 G 获取到一个锁的前提一定是当前 key 未被锁。</p>
<p>有人要问了，当一个锁解开时，之前未获取到锁而发生等待的客户端谁先获取到这把锁？ 这个问题，我们后续分析原理的时候再揭晓。</p>
<p>说到分布式锁，不得不提起 redis。它有一个看似安全实际一点都不安全的分布式锁。它的命令模式是</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">set</span> <span class="nx">key</span> <span class="nx">value</span> <span class="p">[</span><span class="nx">EX</span> <span class="nx">seconds</span><span class="p">]</span> <span class="p">[</span><span class="nx">PX</span> <span class="nx">milliseconds</span><span class="p">]</span> <span class="p">[</span><span class="nx">NX</span><span class="p">|</span><span class="nx">XX</span><span class="p">]</span>
</code></pre></div><p>这其中，介绍两个关键的属性:</p>
<ul>
<li>EX 标示设置过期时间，单位是秒。</li>
<li>NX 表示 当对应的 key 不存在时，才创建。</li>
</ul>
<p>我们在使用 redis 做分布式锁的时候会这么写。(代码用了包 <code>https://github.com/go-redis/redis</code>)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RedisLock</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rdb</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span>
		<span class="nx">Addr</span><span class="p">:</span>     <span class="s">&#34;127.0.0.1:6379&#34;</span><span class="p">,</span>
		<span class="nx">Password</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
		<span class="nx">DB</span><span class="p">:</span>       <span class="mi">0</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 尝试获取锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">rdb</span><span class="p">.</span><span class="nf">SetNX</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="s">&#34;value&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">res</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 尝试获取锁失败\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 获取到锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">//模拟业务耗时
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 释放锁，时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">rdb</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rdb</span><span class="p">.</span><span class="nf">SetNX</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="s">&#34;value&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</code></pre></div><p>我们规定锁的过期时间是2秒，下面有一句 <code>time.Sleep(1 * time.Second) </code> 用来模拟处理业务的耗时。业务处理结束，我们删除 key <code>rdb.Del(ctx, &quot;key&quot;)</code> 。</p>
<p>我们写个简单的脚本，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nf">RedisLock</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>我们开启十个 G 并发的调用 <code>RedisLock</code> 函数。每次调用，函数内部都会新建一个 redis 客户端，本质上是10个客户端。</p>
<p>运行这段程序，</p>
<p><img src="https://image.syst.top/image/redis/lock-1.png" alt="image"></p>
<p>从图中看出，同一时刻只有一个客户端获取到锁，并且在一秒的任务处理后，释放了锁，好像没太大的问题。</p>
<p>那么，我再写一个简单的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/go-redis/redis/v8&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">ctx</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
<span class="kd">var</span> <span class="nx">rdb</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Client</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">ExampleLock</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">timeSleep</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rdb</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span>
		<span class="nx">Addr</span><span class="p">:</span>     <span class="s">&#34;127.0.0.1:6379&#34;</span><span class="p">,</span>
		<span class="nx">Password</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
		<span class="nx">DB</span><span class="p">:</span>       <span class="mi">0</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">timeSleep</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="nx">timeSleep</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 尝试获取锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">rdb</span><span class="p">.</span><span class="nf">SetNX</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="s">&#34;value&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">res</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:尝试获取锁失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 获取到锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 释放锁，时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">rdb</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们设置锁的过期时间是 3 秒，而获取锁之后的任务处理时间为 7 秒。</p>
<p>然后我们开启两个 G。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div><p>其中第二行数字5，从代码中可以看出，是指启动 G 后过5秒去获取锁。</p>
<p>这段代码整体流程是这样的:G(1) 获取到锁后，设置的锁持有时间是3秒，由于任务执行需要7秒的时间，因此在3秒过后锁会自动释放。
G(2) 可以在第5秒的时候获取到锁，然后它执行任务也得7秒。最后，G(1)在获取锁后7秒执行释放锁的操作，G(2)同理。</p>
<p><img src="https://image.syst.top/image/redis/lock-2.png" alt="image"></p>
<p>发现问题了吗？</p>
<p>G(1) 的锁在3秒后已经自动释放了。但是在任务处理结束后又执行了解锁的操作,可此时这个锁是 G(2) 的呀。</p>
<p>那么接下来由于 G(1) 误解了 G(2) 的锁，如果此时有其他的 G，那么就可以获取到锁。</p>
<p>等 G(2) 任务执行结束，同理又会误解其他 G 的锁，这是一个恶性循环。
这也是掘金一篇由 redis 分布式锁造成茅台超卖重大事故的原因之一。</p>
<p>至于其他的，可以自行查看这篇文章[1]。</p>
<h3 id="基于-etcd-的分布式队列">基于 etcd 的分布式队列</h3>
<p>对队列更多的理论知识就不加以介绍了。我们都知道，队列是一种先进先出的数据结构，一般也只有入队和出队两种操作。
我们常常在单机的应用中使用到队列。</p>
<p>那么，如何实现一个分布式的队列呢?。</p>
<p>我们可以使用 etcd 开箱即用的工具，在 <code>etcd</code> 底层 <code>recipe</code> 包里结构 <code>Queue</code>，实现了一个多读多写的分布式队列。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Queue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Client</span>
	<span class="nx">ctx</span>    <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>

	<span class="nx">keyPrefix</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">NewQueue</span><span class="p">(</span><span class="nx">client</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">keyPrefix</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Queue</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">Queue</span><span class="p">)</span> <span class="nf">Dequeue</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">Queue</span><span class="p">)</span> <span class="nf">Enqueue</span><span class="p">(</span><span class="nx">val</span> <span class="kt">string</span><span class="p">)</span>

</code></pre></div><p>我们基于此包可以很方便的实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">src</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
	<span class="nx">recipe</span> <span class="s">&#34;github.com/coreos/etcd/contrib/recipes&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>

<span class="c1">// 初始化etcd客户端
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">initEtcdClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// 解析etcd的地址，编程[]string
</span><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="c1">// 创建一个 etcd 的客户端
</span><span class="c1"></span>	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">client</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Push</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;push err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}(</span><span class="nx">j</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Pop</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;接收值:%v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>在 <code>push</code> 中，我们开启3轮发送值入队，每次发送10个，发送一轮休息2秒。
在 <code>pop</code> 中，通过死循环获取队列中的值。</p>
<p>运行脚本程序如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;etcd-test/src&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="s">&#34;test-queue&#34;</span>
	<span class="k">go</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="k">go</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们使用两个 <code>G</code> 代表 分别运行 <code>push</code> 和 <code>pop</code> 操作。
同时为了达到运行效果，我们先运行 <code>pop</code> 等待有入队的元素。
运行结果动画如下,</p>
<p><img src="https://image.syst.top/image/etcd/queue.gif" alt="image"></p>
<p><code>etcd</code> 还提供了优先级的分布式的队列。和上面的用法相似。只是在入队的时候，不仅仅需要提供一个值，还需要提供一个整数，来表示当前 <code>push</code> 值的优先级。数值越小，优先级越高。</p>
<p>我们改动一下上述的代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">src</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
	<span class="nx">recipe</span> <span class="s">&#34;github.com/coreos/etcd/contrib/recipes&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>

<span class="c1">// 初始化etcd客户端
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">initEtcdClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// 解析etcd的地址，编程[]string
</span><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="c1">// 创建一个 etcd 的客户端
</span><span class="c1"></span>	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">client</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">PriorityPush</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewPriorityQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">item</span><span class="p">),</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;push err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}(</span><span class="nx">j</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">PriorityPop</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewPriorityQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;接收值:%v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后以下是我们的测试代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;etcd-test/src&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="s">&#34;test-queue&#34;</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nx">src</span><span class="p">.</span><span class="nf">PriorityPush</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="k">go</span> <span class="nx">src</span><span class="p">.</span><span class="nf">PriorityPop</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p>我们把0到9的数并发的 <code>push</code> 到队列中，对应的优先级整数值就是它本身，<code>push</code> 完毕，我们运行 <code>PriorityPop</code> 函数，看最终结果显示就是从0到9。</p>
<p><img src="https://image.syst.top/image/etcd/queue-2.gif" alt="image"></p>
<h3 id="总结">总结</h3>
<p>这篇文章主要介绍了如何使用 etcd 实现分布式锁以及分布式队列。其他etcd的场景，可以自行实践。</p>
<h3 id="附录">附录</h3>
<p>[1]
<a href="https://juejin.cn/post/6854573212831842311">https://juejin.cn/post/6854573212831842311</a></p>
]]></content>
		</item>
		
		<item>
			<title>使用 Go 每分钟处理百万请求 </title>
			<link>https://www.syst.top/posts/go/handle-million-requests/</link>
			<pubDate>Mon, 05 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/handle-million-requests/</guid>
			<description>介绍 偶然间看到一篇写于15年的文章，说实话，标题确实吸引了我，不过看了几遍之后，确实精彩。 关于这篇文章，我就不直接翻译了。 项目的需求就是 客户端发送请求，服务端接收请求处理数据(原文是把资源上传至 Amazon S3 资源中)。本质上就是这样, 我稍微改动了原文的业务代码，但是并不影响核心模块。在第一版中，每收到一个 Request,开启一个 G 进行处理，快速响应，很常规的操作。
代码如下
初版 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) type Payload struct { // 传啥不重要 } func (p *Payload) UpdateToS3() error { //存储逻辑,模拟操作耗时 	time.Sleep(500 * time.Millisecond) fmt.Println(&amp;#34;上传成功&amp;#34;) return nil } func payloadHandler(w http.ResponseWriter, r *http.Request) { // 业务过滤 	// 请求body解析...... 	var p Payload go p.UpdateToS3() w.Write([]byte(&amp;#34;操作成功&amp;#34;)) } func main() { http.HandleFunc(&amp;#34;/payload&amp;#34;, payloadHandler) log.Fatal(http.ListenAndServe(&amp;#34;:8099&amp;#34;, nil)) } 这样操作存在什么问题呢？一般情况下，没什么问题。但是如果是高并发的场景下，不对G数进行控制，你的 CPU 使用率暴涨，内存占用暴涨，直至程序奔溃。</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>偶然间看到一篇写于15年的文章，说实话，标题确实吸引了我，不过看了几遍之后，确实精彩。 关于这篇文章，我就不直接翻译了。 项目的需求就是 客户端发送请求，服务端接收请求处理数据(原文是把资源上传至 Amazon S3 资源中)。本质上就是这样,
<img src="https://image.syst.top/image/handle-million.png" alt="image"></p>
<p>我稍微改动了原文的业务代码，但是并不影响核心模块。在第一版中，每收到一个 Request,开启一个 G 进行处理，快速响应，很常规的操作。</p>
<p>代码如下</p>
<h3 id="初版">初版</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Payload</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 传啥不重要
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Payload</span><span class="p">)</span> <span class="nf">UpdateToS3</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">//存储逻辑,模拟操作耗时
</span><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;上传成功&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 业务过滤
</span><span class="c1"></span>	<span class="c1">// 请求body解析......
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Payload</span>
	<span class="k">go</span> <span class="nx">p</span><span class="p">.</span><span class="nf">UpdateToS3</span><span class="p">()</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/payload&#34;</span><span class="p">,</span> <span class="nx">payloadHandler</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8099&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div><p>这样操作存在什么问题呢？一般情况下，没什么问题。但是如果是高并发的场景下，不对G数进行控制，你的 CPU 使用率暴涨，内存占用暴涨，直至程序奔溃。</p>
<p>如果此操作落地至数据库，例如mysql,那么相应的，你数据库的服务器磁盘IO、网络带宽
、CPU负载、内存消耗都会达到非常高的情况，一并奔溃。所以，一旦程序中出现不可控的事物，往往是危险的信号。</p>
<h3 id="中版">中版</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">MaxQueue</span> <span class="p">=</span> <span class="mi">400</span>

<span class="kd">var</span> <span class="nx">Queue</span> <span class="kd">chan</span> <span class="nx">Payload</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">Queue</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Payload</span><span class="p">,</span> <span class="nx">MaxQueue</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Payload</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 传啥不重要
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Payload</span><span class="p">)</span> <span class="nf">UpdateToS3</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">//存储逻辑,模拟操作耗时
</span><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;上传成功&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 业务过滤
</span><span class="c1"></span>	<span class="c1">// 请求body解析......
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Payload</span>
	<span class="c1">//go p.UpdateToS3()
</span><span class="c1"></span>	<span class="nx">Queue</span> <span class="o">&lt;-</span> <span class="nx">p</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// 处理任务
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">StartProcessor</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">payload</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">Queue</span><span class="p">:</span>
			<span class="nx">payload</span><span class="p">.</span><span class="nf">UpdateToS3</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/payload&#34;</span><span class="p">,</span> <span class="nx">payloadHandler</span><span class="p">)</span>
	<span class="c1">//单独开一个g接收与处理任务
</span><span class="c1"></span>	<span class="k">go</span> <span class="nf">StartProcessor</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8099&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>这一版借助带 buffered 的 channel 来完成这个功能，这样控制住了无限制的G，但是依然没有解决问题。</p>
<p>处理请求是一个同步的操作，每次只会处理一个任务，然而高并发下请求进来的速度远远超过了处理的速度。这种情况，一旦 channel
满了之后， 后续的请求将会被阻塞等地啊。然后你会发现，响应的时间会大幅度的开始增加， 甚至不再有任何的响应。</p>
<h3 id="终版">终版</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
<span class="s">&#34;fmt&#34;</span>
<span class="s">&#34;log&#34;</span>
<span class="s">&#34;net/http&#34;</span>
<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">MaxWorker</span> <span class="p">=</span> <span class="mi">100</span> <span class="c1">//随便设置值
</span><span class="c1"></span>	<span class="nx">MaxQueue</span>  <span class="p">=</span> <span class="mi">200</span> <span class="c1">// 随便设置值
</span><span class="c1"></span><span class="p">)</span>

<span class="c1">// 一个可以发送工作请求的缓冲 channel
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">JobQueue</span> <span class="kd">chan</span> <span class="nx">Job</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">JobQueue</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">MaxQueue</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Payload</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">Job</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">PayLoad</span> <span class="nx">Payload</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Worker</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">WorkerPool</span> <span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span>
	<span class="nx">JobChannel</span> <span class="kd">chan</span> <span class="nx">Job</span>
	<span class="nx">quit</span>       <span class="kd">chan</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewWorker</span><span class="p">(</span><span class="nx">workerPool</span> <span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span><span class="p">)</span> <span class="nx">Worker</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">Worker</span><span class="p">{</span>
		<span class="nx">WorkerPool</span><span class="p">:</span> <span class="nx">workerPool</span><span class="p">,</span>
		<span class="nx">JobChannel</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">),</span>
		<span class="nx">quit</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Start 方法开启一个 worker 循环，监听退出 channel，可按需停止这个循环
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="nx">Worker</span><span class="p">)</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c1">// 将当前的 worker 注册到 worker 队列中
</span><span class="c1"></span>			<span class="nx">w</span><span class="p">.</span><span class="nx">WorkerPool</span> <span class="o">&lt;-</span> <span class="nx">w</span><span class="p">.</span><span class="nx">JobChannel</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">w</span><span class="p">.</span><span class="nx">JobChannel</span><span class="p">:</span>
				<span class="c1">// 	真正业务的地方
</span><span class="c1"></span>				<span class="c1">//	模拟操作耗时
</span><span class="c1"></span>				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;上传成功:%v\n&#34;</span><span class="p">,</span> <span class="nx">job</span><span class="p">)</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">w</span><span class="p">.</span><span class="nx">quit</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="nx">Worker</span><span class="p">)</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">w</span><span class="p">.</span><span class="nx">quit</span> <span class="o">&lt;-</span> <span class="kc">true</span>
	<span class="p">}()</span>
<span class="p">}</span>

<span class="c1">// 初始化操作
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Dispatcher</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 注册到 dispatcher 的 worker channel 池
</span><span class="c1"></span>	<span class="nx">WorkerPool</span> <span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewDispatcher</span><span class="p">(</span><span class="nx">maxWorkers</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Dispatcher</span> <span class="p">{</span>
	<span class="nx">pool</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">maxWorkers</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Dispatcher</span><span class="p">{</span><span class="nx">WorkerPool</span><span class="p">:</span> <span class="nx">pool</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 开始运行 n 个 worker
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">MaxWorker</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">worker</span> <span class="o">:=</span> <span class="nf">NewWorker</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span><span class="p">)</span>
		<span class="nx">worker</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="nx">d</span><span class="p">.</span><span class="nf">dispatch</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">dispatch</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">JobQueue</span><span class="p">:</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">job</span> <span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 尝试获取一个可用的 worker job channel，阻塞直到有可用的 worker
</span><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span>
				<span class="c1">// 分发任务到 worker job channel 中
</span><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">&lt;-</span> <span class="nx">job</span>
			<span class="p">}(</span><span class="nx">job</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 接收请求，把任务筛入JobQueue。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">work</span> <span class="o">:=</span> <span class="nx">Job</span><span class="p">{</span><span class="nx">PayLoad</span><span class="p">:</span> <span class="nx">Payload</span><span class="p">{}}</span>
	<span class="nx">JobQueue</span> <span class="o">&lt;-</span> <span class="nx">work</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 通过调度器创建worker，监听来自 JobQueue的任务
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">NewDispatcher</span><span class="p">(</span><span class="nx">MaxWorker</span><span class="p">)</span>
	<span class="nx">d</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/payload&#34;</span><span class="p">,</span> <span class="nx">payloadHandler</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8099&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>


</code></pre></div><p>最终采用的是两级 channel，一级是将用户请求数据放入到 chan Job 中，这个 channel job 相当于待处理的任务队列。</p>
<p>另一级用来存放可以处理任务的 work 缓存队列，类型为 chan chan Job。调度器把待处理的任务放入一个空闲的缓存队列当中，work 会一直处理它的缓存队列。通过这种方式，实现了一个 worker 池。大致画了一个图帮助理解
<img src="https://image.syst.top/image/work-pool.png" alt="image"></p>
<p>首先我们在接收到一个请求后，创建 Job 任务，把它放入到任务队列中等待 work 池处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">work</span> <span class="o">:=</span> <span class="nx">Job</span><span class="p">{</span><span class="nx">PayLoad</span><span class="p">:</span> <span class="nx">Payload</span><span class="p">{}}</span>
	<span class="nx">JobQueue</span> <span class="o">&lt;-</span> <span class="nx">work</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>调度器初始化work池后，在 dispatch 中，一旦我们接收到 JobQueue 的任务，就去尝试获取一个可用的 worker，分发任务给 worker 的 job channel 中。 注意这个过程不是同步的，而是每接收到一个 job，就开启一个 G 去处理。这样可以保证 JobQueue 不需要进行阻塞，对应的往 JobQueue 理论上也不需要阻塞地写入任务。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 开始运行 n 个 worker
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">MaxWorker</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">worker</span> <span class="o">:=</span> <span class="nf">NewWorker</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span><span class="p">)</span>
		<span class="nx">worker</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="nx">d</span><span class="p">.</span><span class="nf">dispatch</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">dispatch</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">JobQueue</span><span class="p">:</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">job</span> <span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 尝试获取一个可用的 worker job channel，阻塞直到有可用的 worker
</span><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span>
				<span class="c1">// 分发任务到 worker job channel 中
</span><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">&lt;-</span> <span class="nx">job</span>
			<span class="p">}(</span><span class="nx">job</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里&quot;不可控&quot;的 G 和上面还是又所不同的。仅仅极短时间内处于阻塞读 Chan 状态， 当有空闲的 worker 被唤醒，然后分发任务，整个生命周期远远短于上面的操作。</p>
<p>最后，强烈建议看一下原文，原文地址在：http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/</p>
<h3 id="最终方案">最终方案</h3>
]]></content>
		</item>
		
	</channel>
</rss>
