<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 是不是很酷</title>
		<link>https://www.syst.top/posts/</link>
		<description>Recent content in Posts on 是不是很酷</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Thu, 29 Jun 2023 15:20:00 +0800</lastBuildDate>
		<atom:link href="https://www.syst.top/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>socks5结合抓包详解</title>
			<link>https://www.syst.top/posts/go/socks5/</link>
			<pubDate>Thu, 29 Jun 2023 15:20:00 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/socks5/</guid>
			<description>SOCKS5（Socket Secure 5）是一种网络协议，用于在客户端和代理服务器之间进行通信。它是SOCKS协议的第五个版本，SOCKS5协议支持TCP和UDP协议，并提供了认证和加密的功能。
SOCKS5协议广泛用于代理服务器、xx上网、匿名访问、负载均衡等场景。它提供了一种通用的、灵活的代理解决方案，可以在各种网络环境和应用中使用。
RFC 1928是关于SOCKS5的协议文档。
协议解析
SOCKS5工作在应用层和传输层之间，首先客户端需要和代理服务器进行tcp连接。
连接完成后，客户端和代理服务器之间进行协商确定认证方式。
具体就是客户端发送认证方法请求，
 VER字段占1个字节，表示SOCKS协议的版本号，目前为5（即SOCKS5）。 NMETHODS字段占1个字节，表示客户端支持的认证方法数量。 METHODS字段占N个字节，表示客户端支持的认证方法列表。每个字节代表一种认证方法，取值范围为1到255，对应不同的认证方式。  代理服务器在收到客户端消息，从客户端提供的METHODS字段中选择一种支持的认证方法，并将该方法的标识填充到METHOD字段中。代理服务器通过这个应答消息告知客户端选择的认证方法。
目前的METHOD包含以下几个值：
 X&#39;00&amp;rsquo;：NO AUTHENTICATION REQUIRED。表示客户端无需进行任何认证，可以直接进行连接或操作。 X&#39;01&amp;rsquo;：GSSAPI。表示使用GSSAPI（Generic Security Services Application Program Interface）进行认证。 X&#39;02&amp;rsquo;：USERNAME/PASSWORD。表示客户端需要使用用户名和密码进行认证。 X&#39;03&amp;rsquo;到X&#39;7F&amp;rsquo;：由IANA（Internet Assigned Numbers Authority）分配的认证方法。这些方法可能具有特定的定义和用途，可以根据具体的分配情况来确定其含义。 X&#39;80&amp;rsquo;到X&amp;rsquo;FE&amp;rsquo;：保留给私有方法（RESERVED FOR PRIVATE METHODS）。这些方法可能由特定实现或组织自定义，不在通用的认证方法范围内。 X&amp;rsquo;FF&amp;rsquo;：无可接受的方法（NO ACCEPTABLE METHODS）。表示代理服务器无法接受客户端提供的任何认证方法，无法进行连接或操作。  如果返回的方法是X &amp;lsquo;FF&amp;rsquo;，意味着失败了，那么客户端需要关闭连接。
一旦协商完毕，客户端会发送请求的详细信息，主要包括实际要请求的目的地址和端口号。
其中各字段含义如下：
 VER：协议版本，固定为X&#39;05&amp;rsquo;。 CMD：连接命令，指定客户端的操作类型。常见的取值有：  X&#39;01&amp;rsquo;：CONNECT。 X&#39;02&amp;rsquo;：BIND。 X&#39;03&amp;rsquo;：UDP。   RSV：保留字段，固定为X&#39;00&amp;rsquo;。 ATYP：目标地址类型，指定DST.ADDR字段的类型。常见的取值有：  X&#39;01&amp;rsquo;：IPv4地址。 X&#39;03&amp;rsquo;：域名。 X&#39;04&amp;rsquo;：IPv6地址。   DST.ADDR：目标地址，根据ATYP字段的类型来确定具体的格式。 DST.PORT：目标端口，表示客户端要连接的目标服务器的端口号。  代理服务器收到请求后，会发起到DST.ADDR:PORT的连接，并响应客户端结果，
其中的值有：
REP:
 X&#39;00&amp;rsquo; 成功 X&#39;01&amp;rsquo; SOCKS服务器故障 X&#39;02&amp;rsquo; 连接不符合规则 X&#39;03&amp;rsquo; 网络不可达 X&#39;04&amp;rsquo; 主机不可达 X&#39;05&amp;rsquo; 连接被拒绝 X&#39;06&amp;rsquo; TTL 过期 X&#39;07&amp;rsquo; 命令不支持 X&#39;08&amp;rsquo; 地址类型不支持 X&#39;09&amp;rsquo; to X&amp;rsquo;FF&amp;rsquo; 未分配  RSV：预留位，必须设置成X&#39;00&amp;rsquo;。</description>
			<content type="html"><![CDATA[<p>SOCKS5（Socket Secure 5）是一种网络协议，用于在客户端和代理服务器之间进行通信。它是SOCKS协议的第五个版本，SOCKS5协议支持TCP和UDP协议，并提供了认证和加密的功能。</p>
<p>SOCKS5协议广泛用于代理服务器、xx上网、匿名访问、负载均衡等场景。它提供了一种通用的、灵活的代理解决方案，可以在各种网络环境和应用中使用。</p>
<p>RFC 1928是关于SOCKS5的协议文档。</p>
<p><strong>协议解析</strong></p>
<p>SOCKS5工作在应用层和传输层之间，首先客户端需要和代理服务器进行tcp连接。</p>
<p>连接完成后，客户端和代理服务器之间进行协商确定认证方式。</p>
<p>具体就是客户端发送认证方法请求，</p>
<p><img src="https://cdn.syst.top/rfc1928-1.png" alt="截屏2023-06-29 11.19.11"></p>
<ul>
<li>VER字段占1个字节，表示SOCKS协议的版本号，目前为5（即SOCKS5）。</li>
<li>NMETHODS字段占1个字节，表示客户端支持的认证方法数量。</li>
<li>METHODS字段占N个字节，表示客户端支持的认证方法列表。每个字节代表一种认证方法，取值范围为1到255，对应不同的认证方式。</li>
</ul>
<p>代理服务器在收到客户端消息，从客户端提供的METHODS字段中选择一种支持的认证方法，并将该方法的标识填充到METHOD字段中。代理服务器通过这个应答消息告知客户端选择的认证方法。</p>
<p><img src="https://cdn.syst.top/rfc1928-2.png" alt="截屏2023-06-29 11.34.41"></p>
<p>目前的METHOD包含以下几个值：</p>
<ul>
<li>X'00&rsquo;：NO AUTHENTICATION REQUIRED。表示客户端无需进行任何认证，可以直接进行连接或操作。</li>
<li>X'01&rsquo;：GSSAPI。表示使用GSSAPI（Generic Security Services Application Program Interface）进行认证。</li>
<li>X'02&rsquo;：USERNAME/PASSWORD。表示客户端需要使用用户名和密码进行认证。</li>
<li>X'03&rsquo;到X'7F&rsquo;：由IANA（Internet Assigned Numbers Authority）分配的认证方法。这些方法可能具有特定的定义和用途，可以根据具体的分配情况来确定其含义。</li>
<li>X'80&rsquo;到X&rsquo;FE&rsquo;：保留给私有方法（RESERVED FOR PRIVATE METHODS）。这些方法可能由特定实现或组织自定义，不在通用的认证方法范围内。</li>
<li>X&rsquo;FF&rsquo;：无可接受的方法（NO ACCEPTABLE METHODS）。表示代理服务器无法接受客户端提供的任何认证方法，无法进行连接或操作。</li>
</ul>
<p>如果返回的方法是X &lsquo;FF&rsquo;，意味着失败了，那么客户端需要关闭连接。</p>
<p>一旦协商完毕，客户端会发送请求的详细信息，主要包括实际要请求的目的地址和端口号。</p>
<p><img src="https://cdn.syst.top/rfc1928-3.png" alt="截屏2023-06-29 13.16.06"></p>
<p>其中各字段含义如下：</p>
<ul>
<li>VER：协议版本，固定为X'05&rsquo;。</li>
<li>CMD：连接命令，指定客户端的操作类型。常见的取值有：
<ul>
<li>X'01&rsquo;：CONNECT。</li>
<li>X'02&rsquo;：BIND。</li>
<li>X'03&rsquo;：UDP。</li>
</ul>
</li>
<li>RSV：保留字段，固定为X'00&rsquo;。</li>
<li>ATYP：目标地址类型，指定DST.ADDR字段的类型。常见的取值有：
<ul>
<li>X'01&rsquo;：IPv4地址。</li>
<li>X'03&rsquo;：域名。</li>
<li>X'04&rsquo;：IPv6地址。</li>
</ul>
</li>
<li>DST.ADDR：目标地址，根据ATYP字段的类型来确定具体的格式。</li>
<li>DST.PORT：目标端口，表示客户端要连接的目标服务器的端口号。</li>
</ul>
<p>代理服务器收到请求后，会发起到DST.ADDR:PORT的连接，并响应客户端结果，</p>
<p><img src="https://cdn.syst.top/rfc1928-4.png" alt="截屏2023-06-29 13.43.05"></p>
<p>其中的值有：</p>
<p>REP:</p>
<ul>
<li>X'00&rsquo; 成功</li>
<li>X'01&rsquo; SOCKS服务器故障</li>
<li>X'02&rsquo; 连接不符合规则</li>
<li>X'03&rsquo; 网络不可达</li>
<li>X'04&rsquo; 主机不可达</li>
<li>X'05&rsquo; 连接被拒绝</li>
<li>X'06&rsquo; TTL 过期</li>
<li>X'07&rsquo; 命令不支持</li>
<li>X'08&rsquo; 地址类型不支持</li>
<li>X'09&rsquo; to X&rsquo;FF&rsquo; 未分配</li>
</ul>
<p>RSV：预留位，必须设置成X'00&rsquo;。</p>
<p>BND.ADDR: 服务器绑定的地址</p>
<p>BND.PORT: 服务器绑定的端口（网络字节序）</p>
<p>当连接建立后，客户端就可以和正常一样访问目标地址&quot;通信&quot;了。此时通信的数据除了目的地址是发往代理服务器以外，所有内容都是和普通连接一样。对代理服务器而言，后面所有收到的来自客户端的数据都会原样转发到目标服务。</p>
<p><strong>抓个包看看</strong></p>
<p>实验涉及到的两个库:</p>
<ul>
<li><a href="https://github.com/shadowsocks/go-shadowsocks2">https://github.com/shadowsocks/go-shadowsocks2</a></li>
<li><a href="https://github.com/haad/proxychains">https://github.com/haad/proxychains</a></li>
</ul>
<p>假设我现在有两台服务器，服务器A(上海)和服务器B(伦敦),服务器B上部署了Shadowsocks服务，Shadowsocks 是一个安全的socks5代理。</p>
<p>我想把机器A对外请求的流量都通过B来代理，并且指定只有发送到A机器的1080端口流量才能被代理。</p>
<p>通过go-shadowsocks2启动程序，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./shadowsocks2 -c <span class="s1">&#39;ss://AES-256-GCM:password@b机器ip:port&#39;</span> -socks 127.0.0.1:1080 
</span></span></code></pre></div><p>参数说明，</p>
<p>-c: 设置Shadowsocks2客户端连接到B机器Shadowsocks的配置。</p>
<p>-socks:  指定Shadowsocks2客户端在本地监听的SOCKS5代理服务器的地址。在这个例子中，客户端在1080端口上监听代理请求。</p>
<p>myip.ipip.net是一个用来查询本机公网ip的服务。假设我们直接在服务器A上curl myip.ipip.net，那么请求的结果，</p>
<p><img src="https://cdn.syst.top/rfc1928-5.png" alt="截屏2023-06-29 15.44.36"></p>
<p>现在我们要通过上面描述的达到输出的是B服务器伦敦的ip地址。</p>
<p>我们使用了工具proxychains，配置proxychains，</p>
<p><img src="https://cdn.syst.top/rfc1928-6.png" alt="截屏2023-06-29 17.09.08"></p>
<p>执行之前，我们先开启tcpdump，我们只抓本地1080端口的流量，毕竟它是作为本地其他客户端socks5代理服务器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">tcpdump -i lo port <span class="m">1080</span> -w ss.pcap
</span></span></code></pre></div><p>然后执行，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">proxychains4 curl myip.ipip.net
</span></span></code></pre></div><p><img src="https://cdn.syst.top/rfc1928-7.png" alt="截屏2023-06-29 15.45.12"></p>
<p>最终获取抓到的包。</p>
<p><img src="https://cdn.syst.top/rfc1928-8.png" alt="截屏2023-06-29 17.35.59"></p>
<p>前三个包是tcp的三次握手，这里就不说了。</p>
<p>包4也就是客户端发送协商认证方法请求给代理服务器，其中包含支持的认证方法列表，这里只支持1种方法:0。也就是客户端无需进行任何认证，可以直接进行连接或操作。</p>
<p><img src="https://cdn.syst.top/rfc1928-9.png" alt="截屏2023-06-29 17.41.35"></p>
<p>包6服务端响应，</p>
<p><img src="https://cdn.syst.top/rfc1928-10.png" alt="截屏2023-06-29 17.41.58"></p>
<p>此时协商完毕。</p>
<p>包8是客户端发起请求的详细信息，里面包含了要访问的目标地址和端口。这里的address type=3 表示域名类型。</p>
<p><img src="https://cdn.syst.top/rfc1928-11.png" alt="截屏2023-06-29 17.46.11"></p>
<p>包9为服务端响应:</p>
<p><img src="https://cdn.syst.top/rfc1928-12.png" alt="截屏2023-06-29 17.47.51"></p>
<p>可以看到 RSV的值表示成功。</p>
<p>这里要注意的是包8中的CMD参数。上面说到有三个值。当客户端发往代理服务器的数据包的 CMD 字段的值为 0x01 时, 代表 CONNECT, 此时 DST.ADDR 和 DST.PORT 表示客户端所想要访问的目标主机的地址和端口, 代理服务器在收到该请求后建立代理服务器到目标主机的 TCP 连接, 并将代理服务器分配的 IP 地址和端口在返回的数据包中的 BIND.ADDR 和 BIND.PORT 表示。其他CMD值含义自行查看rfc。</p>
<p>但是包9中在对CONNECT请求回复中，BIND.PORT 和BIND.ADDR都不是预期的值。看了shadowsocks2里面的代码，</p>
<p><img src="https://cdn.syst.top/rfc1928-13.png" alt="截屏2023-06-29 18.04.55"></p>
<p>它是直接把ATYP设置成1，BND.ADDR和BND.PORT设置为0。</p>
<p>因为此时的本地socks5并不是最终的代理服务器，实际请求目标地址的是我们在启动shadowsocks2配置的B机器上的ss服务。本身BND.ADDR和BND.PORT字段是可选的，如果服务器不提供这些信息，客户端可以根据实际情况进行处理。</p>
<p>当响应成功，客户端开始请求传输数据了，也就是包10，发送了一个http请求。包12是对请求的响应。</p>
<p><img src="https://cdn.syst.top/rfc1928-14.png" alt="截屏2023-06-29 20.49.48"></p>
<p>所以实际的流转是,</p>
<p>local A client &lt;-socks5-&gt; A:1080 &lt;-&gt; b机器Shadowsocks &lt;-&gt; myip.ipip.net</p>
<p>在Shadowsocks2中，主要通过这个函数来实现双向数据传输:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// relay copies between left and right bidirectionally
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">relay</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">err1</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wait</span> <span class="p">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span><span class="p">,</span> <span class="nx">err1</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">right</span><span class="p">,</span> <span class="nx">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">right</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">wait</span><span class="p">))</span> <span class="c1">// unblock read on right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">left</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">wait</span><span class="p">))</span> <span class="c1">// unblock read on left
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err1</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">ErrDeadlineExceeded</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// requires Go 1.15+
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="nx">err1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">ErrDeadlineExceeded</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>也就是，(client &lt;-socks5-&gt; A:1080 )  &lt;-&gt;  (Shadowsocks &lt;-&gt; myip.ipip.net)</p>
<p>主要靠的是标准库的io.Copy。</p>
<p>最后13-16包就是tcp的4次挥手了。</p>
<p>上图这组包还有一个很基础的tcp知识点，</p>
<p><img src="https://cdn.syst.top/rfc1928-8.png" alt="截屏2023-06-29 17.35.59"></p>
<p>首先你图上看到的seq都是从0开始的，那是因为wireshark有个可以开启Relative Sequence Numbers的选项。</p>
<p>上面的包4截图可以看到包信息:Seq =1,Len=3。再看包5，是对包4的Ack, 包6包7同理。</p>
<p>但是你再看包8：Seq:4，Len=20。</p>
<p><img src="https://cdn.syst.top/rfc1928-15.png" alt="截屏2023-06-29 21.16.14"></p>
<p>但是你在包9看到的也是一个Socks协议的包，并没有看到专门对包8的Ack。</p>
<p>在TCP通信中，并不一定每个请求都会立即收到相应的ACK确认包。TCP使用了一种称为&quot;累积确认&quot;（Cumulative Acknowledgment）的机制。ACK确认包可能会延迟发送，或者包含在接收方发送的其他数据包中。这是TCP协议的一种优化机制，可以减少网络中的包数量和传输开销。</p>
<p>那么我们就知道对包8的确认，其实是随着包9的数据一起发送了。Ack=Seq(4)+Len(20)=24</p>
<p><img src="https://cdn.syst.top/rfc1928-16.png" alt="截屏2023-06-29 21.21.37"></p>
<p>完结。</p>
]]></content>
		</item>
		
		<item>
			<title>easyio:最小化的netpoll实现</title>
			<link>https://www.syst.top/posts/go/easyio/</link>
			<pubDate>Sat, 03 Jun 2023 17:06:51 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/easyio/</guid>
			<description>目前Go圈有很多款异步的网络框架:
 https://github.com/tidwall/evio https://github.com/lesismal/nbio https://github.com/panjf2000/gnet https://github.com/cloudwego/netpoll &amp;hellip;&amp;hellip;.  排名不分先后。
这里面最早的实现是evio。evio也存在一些问题，之前也写过evio文章介绍过。 其他比如nbio和gnet也写过一些源码分析。
为什么会出现这些框架？之前也提到过，由于标准库netpoll的一些特性:
 一个conn一个goroutine导致利用率低 用户无法感知conn状态 &amp;hellip;..  这些框架在应用层上做了很多优化，比如:Worker Pool,Buffer,Ring Buffer,NoCopy&amp;hellip;&amp;hellip;。
都分析了好几篇的代码了，那么咋么说也得自己动手搞一个来达成学习目的。
没错，这就是easyio的由来。
它是一个最小化的IO框架，只实现最核心的部分，加起来不超过500行代码。
也没有用户端上层应用的优化，且目前只实现了linux的epoll，以及只能运行tcp协议。
大概结构如下，具体可以看代码～～，
简单的demo，
服务端:
package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;syscall&amp;#34; &amp;#34;github.com/wuqinqiang/easyio&amp;#34; ) var _ easyio.EventHandler = (*Handler)(nil) type Handler struct{} type EasyioKey struct{} type Message struct{ Msg string } var CtxKey EasyioKey func (h Handler) OnOpen(c easyio.Conn) context.Context { return context.WithValue(context.Background(), CtxKey, Message{Msg: &amp;#34;helloword&amp;#34;}) } func (h Handler) OnRead(ctx context.</description>
			<content type="html"><![CDATA[<p>目前Go圈有很多款异步的网络框架:</p>
<ul>
<li><a href="https://github.com/tidwall/evio">https://github.com/tidwall/evio</a></li>
<li><a href="https://github.com/lesismal/nbio">https://github.com/lesismal/nbio</a></li>
<li><a href="https://github.com/panjf2000/gnet">https://github.com/panjf2000/gnet</a></li>
<li><a href="https://github.com/cloudwego/netpoll">https://github.com/cloudwego/netpoll</a></li>
<li>&hellip;&hellip;.</li>
</ul>
<p>排名不分先后。</p>
<p>这里面最早的实现是evio。evio也存在一些问题，之前也写过<a href="https://www.syst.top/posts/go/evio/">evio</a>文章介绍过。 其他比如nbio和gnet也写过一些源码分析。</p>
<p>为什么会出现这些框架？之前也提到过，由于标准库netpoll的一些特性:</p>
<ul>
<li>一个conn一个goroutine导致利用率低</li>
<li>用户无法感知conn状态</li>
<li>&hellip;..</li>
</ul>
<p>这些框架在应用层上做了很多优化，比如:Worker Pool,Buffer,Ring Buffer,NoCopy&hellip;&hellip;。</p>
<p>都分析了好几篇的代码了，那么咋么说也得自己动手搞一个来达成学习目的。</p>
<p>没错，这就是easyio的由来。</p>
<p>它是一个最小化的IO框架，只实现最核心的部分，加起来不超过500行代码。</p>
<p>也没有用户端上层应用的优化，且目前只实现了linux的epoll，以及只能运行tcp协议。</p>
<p>大概结构如下，具体可以看代码～～，</p>
<p><img src="https://cdn.syst.top/%E6%88%AA%E5%B1%8F2023-06-11%2010.19.57.png" alt="截屏2023-06-03 23.28.59"></p>
<p>简单的demo，</p>
<p>服务端:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os/signal&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;syscall&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/easyio&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">_</span> <span class="nx">easyio</span><span class="p">.</span><span class="nx">EventHandler</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">Handler</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">EasyioKey</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Message</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">Msg</span> <span class="kt">string</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">CtxKey</span> <span class="nx">EasyioKey</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">Handler</span><span class="p">)</span> <span class="nf">OnOpen</span><span class="p">(</span><span class="nx">c</span> <span class="nx">easyio</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">CtxKey</span><span class="p">,</span> <span class="nx">Message</span><span class="p">{</span><span class="nx">Msg</span><span class="p">:</span> <span class="s">&#34;helloword&#34;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">Handler</span><span class="p">)</span> <span class="nf">OnRead</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span> <span class="nx">easyio</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">CtxKey</span><span class="p">).(</span><span class="nx">Message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;err:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;[Handler] read data:&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">Handler</span><span class="p">)</span> <span class="nf">OnClose</span><span class="p">(</span><span class="nx">_</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span> <span class="nx">easyio</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;[Handler] closed&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Fd</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">easyio</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8090&#34;</span><span class="p">,</span><span class="nx">easyio</span><span class="p">.</span><span class="nf">WithNumPoller</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nx">easyio</span><span class="p">.</span><span class="nf">WithEventHandler</span><span class="p">(</span><span class="nx">Handler</span><span class="p">{}))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGTERM</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGQUIT</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGINT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">&lt;-</span><span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面的代码，初始化一个easyio，启动一个tcp服务，监听端口8090，options里面设置epoll的数量，以及设置事件处理器。</p>
<p>当一个新连接到来时会回调 OnOpen函数，此时你可以设置自定义的ctx，那么当对应连接读事件到来OnRead回调，你可以拿到之前设置的ctx，调用conn.Read读取数据，且通过Write向对端写数据。</p>
<p>这里需要注意的是，一个连接如果数据没读完，当OnRead执行结束，下一轮会继续触发回调代码，因为底层epoll采用的是LT触发方式。</p>
<p>简单的客户端</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os/signal&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;syscall&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8090&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;read data:&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGHUP</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGINT</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGTERM</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGQUIT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>因为之前读者问过一些问题，我计划编写一个从零开始实现的 easyio 系列教程，希望能够帮助一些小白通过实践来加深对这个主题的理解，如果你对这个系列感兴趣，请在下方留言或点赞。</p>
<p>决定的话，整个系列大概可以拆分成5～6篇文章(当然不收费～)。</p>
<p>看懂和会写出来是完全不一样的概念。理论与实践是相辅相成的，只有理解了理论并将其应用于实践中，我们才能真正掌握知识。</p>
<p>最后让这个世界充满爱～～～</p>
<p>源码地址:https://github.com/wuqinqiang/easyio</p>
]]></content>
		</item>
		
		<item>
			<title>nbio原理解析</title>
			<link>https://www.syst.top/posts/go/nbio/</link>
			<pubDate>Thu, 23 Feb 2023 23:23:51 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/nbio/</guid>
			<description>之前更新的一系列，好久没更新了，差点烂尾，我不允许这样的事情在我身上发生(虽然已经烂尾好几次了😭)。
在上一篇文章中，我们探讨了基于 epoll 的 Go Netpoll 框架的早期实现——evio。我们还指出了它存在的一些问题。在本篇文章中，我们将继续深入分析另一个高性能的网络编程框架：nbio。
nbio项目里也包含了在nbio之上构建的nbhttp，这个不在我们讨论范围。
nbio同样采用了经典的Reactor模式，事实上，Go语言中的许多异步网络框架都是基于这种模式设计的。
老规矩，先运行nbio程序代码，
Server:
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/lesismal/nbio&amp;#34; ) func main() { g := nbio.NewGopher(nbio.Config{ Network: &amp;#34;tcp&amp;#34;, Addrs: []string{&amp;#34;:8888&amp;#34;}, MaxWriteBufferSize: 6 * 1024 * 1024, }) g.OnData(func(c *nbio.Conn, data []byte) { c.Write(append([]byte{}, data...)) }) err := g.Start() if err != nil { fmt.Printf(&amp;#34;nbio.Start failed: %v\n&amp;#34;, err) return } defer g.Stop() g.Wait() } 使用nbio.NewGopher()函数创建一个新的Engine实例。传入nbio.Config结构体来配置 Engine 实例，包括：
 Network: 使用的网络类型，这里是tcp。 Addrs: 服务器要监听的地址和端口，这里是 &amp;ldquo;:8888&amp;rdquo;（即监听本机的8888端口）。 MaxWriteBufferSize: 写缓冲区的最大大小，这里设置为 6MB。  其他配置可以自行查看。然后使用g.</description>
			<content type="html"><![CDATA[<p>之前更新的一系列，好久没更新了，差点烂尾，我不允许这样的事情在我身上发生(虽然已经烂尾好几次了😭)。</p>
<p>在上一篇文章中，我们探讨了基于 epoll 的 Go Netpoll 框架的早期实现——evio。我们还指出了它存在的一些问题。在本篇文章中，我们将继续深入分析另一个高性能的网络编程框架：nbio。</p>
<p>nbio项目里也包含了在nbio之上构建的nbhttp，这个不在我们讨论范围。</p>
<p>nbio同样采用了经典的Reactor模式，事实上，Go语言中的许多异步网络框架都是基于这种模式设计的。</p>
<p>老规矩，先运行nbio程序代码，</p>
<p>Server:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/lesismal/nbio&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">g</span> <span class="o">:=</span> <span class="nx">nbio</span><span class="p">.</span><span class="nf">NewGopher</span><span class="p">(</span><span class="nx">nbio</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Network</span><span class="p">:</span>            <span class="s">&#34;tcp&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Addrs</span><span class="p">:</span>              <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;:8888&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MaxWriteBufferSize</span><span class="p">:</span> <span class="mi">6</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">g</span><span class="p">.</span><span class="nf">OnData</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">nbio</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nb">append</span><span class="p">([]</span><span class="kt">byte</span><span class="p">{},</span> <span class="nx">data</span><span class="o">...</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;nbio.Start failed: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">g</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">g</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>使用nbio.NewGopher()函数创建一个新的Engine实例。传入nbio.Config结构体来配置 Engine 实例，包括：</p>
<ul>
<li>Network: 使用的网络类型，这里是tcp。</li>
<li>Addrs: 服务器要监听的地址和端口，这里是 &ldquo;:8888&rdquo;（即监听本机的8888端口）。</li>
<li>MaxWriteBufferSize: 写缓冲区的最大大小，这里设置为 6MB。</li>
</ul>
<p>其他配置可以自行查看。然后使用g.OnData()方法为 Engine实例注册一个数据接收回调函数。这个回调函数在收到数据时被调用。回调函数接收两个参数：连接对象c和收到的数据 data。在回调函数内部，我们使用c.Write()方法将收到的数据原样写回给客户端。</p>
<p>Client:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;bytes&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;math/rand&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/lesismal/nbio&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/lesismal/nbio/logging&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ret</span>    <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">		<span class="nx">buf</span>    <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">addr</span>   <span class="p">=</span> <span class="s">&#34;localhost:8888&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ctx</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">60</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">logging</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">logging</span><span class="p">.</span><span class="nx">LevelInfo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">rand</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">g</span> <span class="o">:=</span> <span class="nx">nbio</span><span class="p">.</span><span class="nf">NewGopher</span><span class="p">(</span><span class="nx">nbio</span><span class="p">.</span><span class="nx">Config</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">g</span><span class="p">.</span><span class="nf">OnData</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">nbio</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">data</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">ret</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Start failed: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">g</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">nbio</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Dial failed: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">g</span><span class="p">.</span><span class="nf">AddConn</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="nx">logging</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;timeout&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">logging</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;success&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>乍一看有点麻烦。其实是服务端和客户端共用了一套结构。</p>
<p>客户端通过nbio.Dial连接服务端，连接成功封装成nbio.Conn，这里的nbio.Conn是实现了标准库的net.Conn 接口的。最后AddConn这个conn。调用Write往服务端写数据，当服务端接收到数据后，Server端的处理逻辑是把数据原样发送给客户端，当客户端接收到数据一样OnData会被回调，上面OnData判断接受到的数据和发送的数据是不是长度一样，最后客户端主动关闭这个连接。</p>
<p>下面来看几个主要结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Engine</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">//..
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//..
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">mux</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wgConn</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">network</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">addrs</span>     <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">listen</span>    <span class="kd">func</span><span class="p">(</span><span class="nx">network</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">pollerNum</span>                    <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">readBufferSize</span>               <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">maxWriteBufferSize</span>           <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">maxConnReadTimesPerEventLoop</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">udpReadTimeout</span>               <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</span></span><span class="line"><span class="cl">	<span class="nx">epollMod</span>                     <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="o">/</span><span class="p">..</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">connsStd</span>  <span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">Conn</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">connsUnix</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Conn</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">listeners</span> <span class="p">[]</span><span class="o">*</span><span class="nx">poller</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pollers</span>   <span class="p">[]</span><span class="o">*</span><span class="nx">poller</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">onOpen</span>            <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">onClose</span>           <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">onRead</span>            <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">onData</span>            <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">onReadBufferAlloc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="nx">onReadBufferFree</span>  <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">buffer</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>Engine本质上就是核心管理器。会管理所有的listener poller 和worker poller。</p>
<p>这两种poller有什么区别吗？</p>
<p>区别在职责上。</p>
<p>listener poller只负责accept新的连接，当一个新的客户端conn到来时，会从pollers挑选一个worker poller，然后把conn加入到对应的worker poller，之后worker poller负责处理此conn的读写事件。</p>
<p>所以当我们启动程序的时候，如果只监听一个地址的情况下，那么程序的poll数= 1(listener poller) + pollerNum。</p>
<p>从上面的字段也可以看出，你可以自定义一些配置和回调。比如你可以设置当新连接到来时的回调函数onOpen，也可以设置一个conn数据到来时的回调函数onData等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Conn</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mux</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="o">*</span><span class="nx">poller</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fd</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">writeBuffer</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">typ</span>      <span class="nx">ConnType</span>
</span></span><span class="line"><span class="cl">	<span class="nx">closed</span>   <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="nx">isWAdded</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="nx">closeErr</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">lAddr</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Addr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rAddr</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Addr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ReadBuffer</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">DataHandler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Conn结构体，用于表示一个网络连接。一个conn只属于一个poller。对应的writeBuffer:当数据一次没写完时，剩下的先存在writeBuffer，等待下次可写事件到来继续写入。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">poller</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">g</span> <span class="o">*</span><span class="nx">Engine</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">epfd</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">evtfd</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">index</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">shutdown</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">listener</span>     <span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span>
</span></span><span class="line"><span class="cl">	<span class="nx">isListener</span>   <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="nx">unixSockAddr</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ReadBuffer</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">pollType</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>至于poller结构，这里就是一个抽象的概念，用于管理底层的多路复用 I/O（如linux的epoll、darwin上的kqueue 等）</p>
<p>注意这里的pollType，nbio默认epoll采用的是水平触发(LT)，当然用户也可以设置成边缘触发(ET)。</p>
<p>介绍完基本的结构，接下来进入代码的流程。</p>
<p>上面服务端的代码，当你调用Start启动程序，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Engine</span><span class="p">)</span> <span class="nf">Start</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">//....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">switch</span> <span class="nx">g</span><span class="p">.</span><span class="nx">network</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">//第一部分 初始化listener
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">case</span> <span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;tcp4&#34;</span><span class="p">,</span> <span class="s">&#34;tcp6&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">g</span><span class="p">.</span><span class="nx">addrs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// listener poller
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">ln</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newPoller</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">g</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nf">stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">g</span><span class="p">.</span><span class="nx">addrs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">listener</span><span class="p">.</span><span class="nf">Addr</span><span class="p">().</span><span class="nf">String</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">g</span><span class="p">.</span><span class="nx">listeners</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">listeners</span><span class="p">,</span> <span class="nx">ln</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">    <span class="c1">//.....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">//第二部分 初始化一定数量poller
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">g</span><span class="p">.</span><span class="nx">pollerNum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// rw poller
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newPoller</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">listeners</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">g</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nf">stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">g</span><span class="p">.</span><span class="nx">pollers</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nf">stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">g</span><span class="p">.</span><span class="nx">pollers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//第三部分 启动所有的worker poller
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">g</span><span class="p">.</span><span class="nx">pollerNum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">g</span><span class="p">.</span><span class="nx">pollers</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">ReadBuffer</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">g</span><span class="p">.</span><span class="nx">readBufferSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">g</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nx">g</span><span class="p">.</span><span class="nx">pollers</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">start</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 第四部分 启动所有的listenr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">g</span><span class="p">.</span><span class="nx">listeners</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">g</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nx">l</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//...忽略udp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>代码还是易懂的，整体看就四个部分。</p>
<p><strong>第一部分：初始化 listener</strong></p>
<p>根据 <code>g.network</code> 的值（如 &ldquo;unix&rdquo;, &ldquo;tcp&rdquo;, &ldquo;tcp4&rdquo;, &ldquo;tcp6&rdquo;），为每个要监听的地址（<code>g.addrs</code>）创建一个新的 <code>poller</code>。这里的 <code>poller</code>主要用于管理监听套接字上的事件。如果创建 <code>poller</code> 时出错，将停止之前创建的所有监听器并返回错误。</p>
<p><strong>第二部分：初始化一定数量的 poller</strong></p>
<p>根据pollerNum创建对应个数的worker poller。这些 <code>poller</code> 用于处理已连接套接字上的读/写事件。如果在创建过程中遇到错误，将停止所有监听器和之前创建的工作 <code>poller</code>，然后返回错误。</p>
<p><strong>第三部分：启动所有的 worker poller</strong></p>
<p>为每个工作 <code>poller</code> 分配一个读缓冲区（由 <code>g.readBufferSize</code> 决定大小），并发地启动这些 <code>poller</code>。</p>
<p><strong>第四部分：启动所有的 listener</strong></p>
<p>启动所有之前创建的监听器。开始监听对应地址的连接请求。</p>
<p>至于poller的启动，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">poller</span><span class="p">)</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">isListener</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">.</span><span class="nf">acceptorLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">syscall</span><span class="p">.</span><span class="nf">Close</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">epfd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">syscall</span><span class="p">.</span><span class="nf">Close</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">evtfd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">.</span><span class="nf">readWriteLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>分为两种，如果是一个listener poller，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">poller</span><span class="p">)</span> <span class="nf">acceptorLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//如果想要当前g不被调度到其他的操作线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">lockListener</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">runtime</span><span class="p">.</span><span class="nf">LockOSThread</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">UnlockOSThread</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">listener</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">NBConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">pollers</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nf">Hash</span><span class="p">()</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">pollers</span><span class="p">)].</span><span class="nf">addConn</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kd">var</span> <span class="nx">ne</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Error</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">As</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">ne</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">ne</span><span class="p">.</span><span class="nf">Timeout</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">logging</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;NBIO[%v][%v_%v] Accept failed: temporary error, retrying...&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">pollType</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">logging</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;NBIO[%v][%v_%v] Accept failed: %v, exit...&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">pollType</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>listener poller 就是等待新连接，然后通过NBConn封装成nbio conn结构，最后通过取模操作获取其中一个woker poller。把连接加入到对应的poller中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">poller</span><span class="p">)</span> <span class="nf">addConn</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">c</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">typ</span> <span class="o">!=</span> <span class="nx">ConnTypeUDPServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">onOpen</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">fd</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span>
</span></span><span class="line"><span class="cl">   <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">connsUnix</span><span class="p">[</span><span class="nx">fd</span><span class="p">]</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">   <span class="nx">err</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">addRead</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">connsUnix</span><span class="p">[</span><span class="nx">fd</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">      <span class="nx">c</span><span class="p">.</span><span class="nf">closeWithError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">logging</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;[%v] add read event failed: %v&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里一个有趣的设计，在管理conns上，结构是slice，作者直接使用的conn的fd来作为下标。</p>
<p>这样还是有好处的,</p>
<ul>
<li>连接超多的情况下，GC的时候负担会比map小。</li>
<li>能防止串号问题。</li>
</ul>
<p>最后通过调用addRead把对应的conn fd加入到epoll。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">poller</span><span class="p">)</span> <span class="nf">addRead</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">epollMod</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">EPOLLET</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">EpollCtl</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">epfd</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="nx">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">EpollEvent</span><span class="p">{</span><span class="nx">Fd</span><span class="p">:</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">fd</span><span class="p">),</span> <span class="nx">Events</span><span class="p">:</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLERR</span> <span class="p">|</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLHUP</span> <span class="p">|</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLRDHUP</span> <span class="p">|</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLPRI</span> <span class="p">|</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLIN</span> <span class="p">|</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLET</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">EpollCtl</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">epfd</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="nx">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">EpollEvent</span><span class="p">{</span><span class="nx">Fd</span><span class="p">:</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">fd</span><span class="p">),</span> <span class="nx">Events</span><span class="p">:</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLERR</span> <span class="p">|</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLHUP</span> <span class="p">|</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLRDHUP</span> <span class="p">|</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLPRI</span> <span class="p">|</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLIN</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里没有注册写事件是合理的，因为在新连接上还没有收到任何数据，所以暂时没有需要发送的数据。这种做法可以避免一些不必要的系统调用，从而提高程序的性能。</p>
<p>如果是worker poller的启动，它的工作就是等待加入的那些conns的事件到来，进行对应的处理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">poller</span><span class="p">)</span> <span class="nf">readWriteLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">//....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">msec</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">  <span class="nx">events</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">EpollEvent</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">for</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">EpollWait</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">epfd</span><span class="p">,</span> <span class="nx">events</span><span class="p">,</span> <span class="nx">msec</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINTR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">msec</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// runtime.Gosched()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">continue</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">msec</span> <span class="p">=</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="c1">// 遍历事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ev</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">events</span><span class="p">[:</span><span class="nx">n</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">fd</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">ev</span><span class="p">.</span><span class="nx">Fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">switch</span> <span class="nx">fd</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="nx">p</span><span class="p">.</span><span class="nx">evtfd</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">         <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nx">c</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">getConn</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">Events</span><span class="o">&amp;</span><span class="nx">epollEventsError</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="nx">c</span><span class="p">.</span><span class="nf">closeWithError</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="k">continue</span>
</span></span><span class="line"><span class="cl">               <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">               <span class="c1">// 说明可写 刷数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">Events</span><span class="o">&amp;</span><span class="nx">epollEventsWrite</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="nx">c</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">               <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">               <span class="c1">//读事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">Events</span><span class="o">&amp;</span><span class="nx">epollEventsRead</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">onRead</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                     <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">maxConnReadTimesPerEventLoop</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="nx">buffer</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">borrow</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="nx">rc</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ReadAndGetConn</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                           <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">onData</span><span class="p">(</span><span class="nx">rc</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                        <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">payback</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                           <span class="k">break</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                     <span class="p">}</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                     <span class="nx">p</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">onRead</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">               <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="nx">syscall</span><span class="p">.</span><span class="nf">Close</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="c1">// p.deleteEvent(fd)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这段代码也很好理解。等待事件到来，遍历对应的事件列表，判断事件类型，相对应的处理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">EpollWait</span><span class="p">(</span><span class="nx">epfd</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">events</span> <span class="p">[]</span><span class="nx">EpollEvent</span><span class="p">,</span> <span class="nx">msec</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span></code></pre></div><p>EpollWait中只有msec是可以用户动态修改的，通常情况下，我们主动调用EpollWait都会设置msec=-1，msce=-1会使得函数一直等待，直到至少有一个事件发生，否则的话一直阻塞。这种方法在事件发生较少的情况下非常有用，因为它可以最大限度地减少 CPU占用率。</p>
<p>如果希望尽可能快速响应事件，可以将msec设置为 0。这将使 EpollWait立即返回，不等待任何事件。这种情况下，你的程序可能会更频繁地调用EpollWait，但能够在事件发生后立即处理它们。当然，这就会导致CPU占用率较高。</p>
<p>如果你的程序可以承受一定的延迟，并希望减少 CPU占用率，可以将msec设置为一个正数。这将使得EpollWait在指定的时间内等待事件。如果在这段时间内没有事件发生，函数将返回，你可以选择在稍后再次调用EpollWait。这种方法可以降低 CPU占用率，但可能会导致较长的响应时间。</p>
<p>nbio对应这个值的调整策略是:当事件数量大于0时，msec=20(这个20应该是作者测试后综合考量?)。</p>
<p>字节跳动的netpoll代码是这样的，如果事件数量大于0，会设置msec为0。如果事件小于等于0，设置msec=-1，然后调用Gosched()使得当前Goroutine主动让出P。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">msec</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">EpollWait</span><span class="p">(</span><span class="nx">epfd</span><span class="p">,</span> <span class="nx">events</span><span class="p">,</span> <span class="nx">msec</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">msec</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">      <span class="nx">runtime</span><span class="p">.</span><span class="nf">Gosched</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">msec</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">   <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然而，nbio 中主动切换的代码已经被注释掉了。根据作者在 issue 中的解释，最初他参考了字节的方法加入了主动切换。</p>
<p>但在对 nbio 进行性能测试时，发现加入与不加入主动切换对性能没有明显区别，因此最终决定将其移除。</p>
<p>事件的处理部分，</p>
<p>如果是可读事件，你可以通过内置或者自定义的内存分配器来得到相应的buffer，然后调用ReadAndGetConn读取数据，而不需要每次都申请一遍buffer。</p>
<p>如果是可写事件的话，会调用flush把buffer里未发送的数据发送出去。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">)</span> <span class="nf">flush</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//.....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">writeBuffer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">doWrite</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINTR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//.....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">left</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span> <span class="o">-</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 说明没写完，把剩下的存进writeBuffer下次写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">left</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">writeBuffer</span> <span class="p">=</span> <span class="nx">mempool</span><span class="p">.</span><span class="nf">Malloc</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nb">copy</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">,</span> <span class="nx">old</span><span class="p">[</span><span class="nx">n</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl">			<span class="nx">mempool</span><span class="p">.</span><span class="nf">Free</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// c.modWrite()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mempool</span><span class="p">.</span><span class="nf">Free</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">writeBuffer</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">wTimer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">wTimer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">wTimer</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 说明写完了，先把conn重置为只有读事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">resetRead</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mux</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>逻辑也很简单，写多少是多少，写不进去把剩下的重新放入writeBuffer，下轮epollWait触发再写。</p>
<p>如果写完了，那就没数据可写了，重置这个conn的事件为读事件。</p>
<p>主逻辑就差不多是这样了。</p>
<p>等等，我们一开始说一个新连接进来的时候，我们对一个连接只注册了读事件，没注册写事件，写事件是什么时候注册的？</p>
<p>当然是你调用conn.Write的时候，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">g</span> <span class="o">:=</span> <span class="nx">nbio</span><span class="p">.</span><span class="nf">NewGopher</span><span class="p">(</span><span class="nx">nbio</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Network</span><span class="p">:</span>            <span class="s">&#34;tcp&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Addrs</span><span class="p">:</span>              <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;:8888&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MaxWriteBufferSize</span><span class="p">:</span> <span class="mi">6</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">g</span><span class="p">.</span><span class="nf">OnData</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">nbio</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nb">append</span><span class="p">([]</span><span class="kt">byte</span><span class="p">{},</span> <span class="nx">data</span><span class="o">...</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span></code></pre></div><p>当conn的数据到来时，底层读完数据，会回调OnData函数，此时你可以调用Write向对端发送数据，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINTR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//.....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">wTimer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">wTimer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">wTimer</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 说明还有数据没写完，加入写事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">modWrite</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//.....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Conn</span><span class="p">)</span> <span class="nf">write</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">doWrite</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINTR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//.....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">		<span class="nx">left</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">-</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//还没写完，剩下的放入writeBuffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">left</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">ConnTypeTCP</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">writeBuffer</span> <span class="p">=</span> <span class="nx">mempool</span><span class="p">.</span><span class="nf">Malloc</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nb">copy</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">,</span> <span class="nx">b</span><span class="p">[</span><span class="nx">n</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nf">modWrite</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果本身writeBuffer还有数据没写入，那新的数据也append进来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">writeBuffer</span> <span class="p">=</span> <span class="nx">mempool</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">,</span> <span class="nx">b</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当数据没写完，就把剩余数据放入到writeBuffer，这样就会触发执行modWrite，就会把conn的写事件注册到epoll中。</p>
<p>总结</p>
<p>相较于evio，nbio不会出现惊群效应。</p>
<p>evio是通过不断无效的唤醒epoll，来达到逻辑的正确性。而nbio是尽可能的减少系统调用，减少无谓的开销。</p>
<p>易用性上，nbio实现了标准库net.Conn，同时很多设置可配置化，用户可以自由定制，自由度较高。</p>
<p>读写上会使用预先分配的buffer，提高应用性能。</p>
<p>总之，nbio是一款不错的高性能非阻塞的网络框架。</p>
]]></content>
		</item>
		
		<item>
			<title>HelloWord一个go开发的学习英语单词工具</title>
			<link>https://www.syst.top/posts/go/helloword/</link>
			<pubDate>Tue, 21 Feb 2023 18:23:51 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/helloword/</guid>
			<description>图片拍摄于2023年02月19日 杭州玉鸟集
背景 Hello Word是我在背单词过程中产生的一个想法。
在学习英语时，词汇量是非常重要的。但是仅仅死记硬背单词，没有语境感，效率是很低的。
虽然一些应用程序可以根据单词的多个词义为单词组成一小段句子，稍微增强语境感。但是单词仍然过于零散。
因此，我们是否可以将每天背诵的多个单词组合成一段小短文，以便复习这一批单词呢？这就是Hello Word的初衷。
当然，ChatGPT API暂时是实现这个想法的工具。 除此之外，程序还配套了几个周边小游戏。
单词短语推送器 指定单词数量，随机选择单词，生成一段小短文，推送到用户指定平台。
这个脚本有以下可选项：
 files：默认导入 CET4.txt 单词文件，你可以通过逗号同时导入多个单词文件，它们都存储在 library 文件夹下。 spec：表示推送频率设置，默认为每小时生成一个新的短语，具体时间规则使用的是 robif/cron 库，请参考该库的文档自行设置。 word-number：表示生成一次短语使用的单词数量，默认为 5 个，最多不超过 10 个  效果
单词选择规则，
 默认:随机 最近最少推送(todo)  单词游戏 单词接龙 这是一个单词接龙游戏，游戏开始时系统会随机选择一个单词。玩家需要以该单词的最后一个字母为开头输入一个新单词，接着程序又以玩家输入单词的最后一个字母为开头输出新单词。游戏会持续进行，直到有一方出现错误。
在一局游戏中，每个单词只能被使用一次。
使用
效果
后续规划
 单词正确性校验，是否是合法的英语单词(todo) 超时控制，用户每个回合指定时间内未输出，游戏结束(todo) 错误机会，一局游戏可以错误次数(todo)  其他游戏 单词拼写(todo)、单词填空(todo) 项目地址在: https://github.com/wuqinqiang/helloword
觉得不错可以点个star，感兴趣可以一起开发。</description>
			<content type="html"><![CDATA[<p><img src="https://cdn.syst.top/WechatIMG92.jpeg" alt="img"></p>
<p>图片拍摄于2023年02月19日 杭州玉鸟集</p>
<h3 id="背景">背景</h3>
<p><a href="https://github.com/wuqinqiang/helloword">Hello Word</a>是我在背单词过程中产生的一个想法。</p>
<p>在学习英语时，词汇量是非常重要的。但是仅仅死记硬背单词，没有语境感，效率是很低的。</p>
<p>虽然一些应用程序可以根据单词的多个词义为单词组成一小段句子，稍微增强语境感。但是单词仍然过于零散。</p>
<p>因此，我们是否可以将每天背诵的多个单词组合成一段小短文，以便复习这一批单词呢？这就是Hello Word的初衷。</p>
<p>当然，ChatGPT API暂时是实现这个想法的工具。 除此之外，程序还配套了几个周边小游戏。</p>
<h3 id="单词短语推送器">单词短语推送器</h3>
<p>指定单词数量，随机选择单词，生成一段小短文，推送到用户指定平台。</p>
<p><img src="https://cdn.syst.top/hello1.png" alt="img"></p>
<p>这个脚本有以下可选项：</p>
<ul>
<li>files：默认导入 CET4.txt 单词文件，你可以通过逗号同时导入多个单词文件，它们都存储在 library 文件夹下。</li>
<li>spec：表示推送频率设置，默认为每小时生成一个新的短语，具体时间规则使用的是 robif/cron 库，请参考该库的文档自行设置。</li>
<li>word-number：表示生成一次短语使用的单词数量，默认为 5 个，最多不超过 10 个</li>
</ul>
<p>效果</p>
<p><img src="https://cdn.syst.top/hello2.png" alt="img"></p>
<p>单词选择规则，</p>
<ul>
<li>默认:随机</li>
<li>最近最少推送(todo)</li>
</ul>
<h3 id="单词游戏">单词游戏</h3>
<h3 id="单词接龙">单词接龙</h3>
<p>这是一个单词接龙游戏，游戏开始时系统会随机选择一个单词。玩家需要以该单词的最后一个字母为开头输入一个新单词，接着程序又以玩家输入单词的最后一个字母为开头输出新单词。游戏会持续进行，直到有一方出现错误。</p>
<p>在一局游戏中，每个单词只能被使用一次。</p>
<p>使用</p>
<p><img src="https://cdn.syst.top/hello3.png" alt="img"></p>
<p>效果</p>
<p><img src="https://cdn.syst.top/hello4.png" alt="img"></p>
<p>后续规划</p>
<ul>
<li>单词正确性校验，是否是合法的英语单词(todo)</li>
<li>超时控制，用户每个回合指定时间内未输出，游戏结束(todo)</li>
<li>错误机会，一局游戏可以错误次数(todo)</li>
</ul>
<h3 id="其他游戏">其他游戏</h3>
<h3 id="单词拼写todo单词填空todo">单词拼写(todo)、单词填空(todo)</h3>
<p>项目地址在: <a href="https://github.com/wuqinqiang/helloword">https://github.com/wuqinqiang/helloword</a></p>
<p>觉得不错可以点个star，感兴趣可以一起开发。</p>
]]></content>
		</item>
		
		<item>
			<title>发现conc并发库一个有趣的问题</title>
			<link>https://www.syst.top/posts/go/conc/</link>
			<pubDate>Tue, 10 Jan 2023 18:23:51 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/conc/</guid>
			<description>上周看到一个新库conc，
 better structured concurrency for go
 这个库的目标是，
 更难出现goroutine泄漏 优雅处理panic 使并发的代码更易读  我们一条条细说。
Make it harder to leak goroutines goroutine泄漏还是很常见的。
日常我们使用go的时候直接go func开启一个goroutine，写上对应的逻辑，g会进入到某个p的本地队列，最终由p绑定的m执行这个goroutine。
你能保证一个goroutine在某个时刻一定会结束它的生命周期吗？
搜了下著名开源项目etcd，goroutine leak还真不少。
看其中一个简单的泄漏bug。
done是一个无缓冲的chan，一开始接收动作在最下面，因为中间还有一些没展开的代码可能会导致程序不会执行到&amp;lt;-done，然后goroutine就会发生泄漏，解决方法就是通过defer保证一定会执行&amp;lt;-done。
那么conc是如何做的？
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/sourcegraph/conc&amp;#34; ) func main() { var wg conc.WaitGroup wg.Go(func() { fmt.Println(&amp;#34;g1&amp;#34;) }) wg.Go(func() { fmt.Println(&amp;#34;g2&amp;#34;) }) wg.Wait() } ps:这个结构是不是超级熟悉。
conc的理念是程序中的每一个goroutine由一个owner创建，归属于owner。一个owner确保它拥有的所有goroutine正常退出，这里的owner也就是conc.WaitGroup。
但是这真的能像他说的那样Make it harder to leak goroutines吗？
goroutine的泄漏问题取决于用户对goroutine能正确退出的逻辑保证，和你如何封装没关系吧？
在我看来conc和标准库的sync.WaitGroup一样，等待所有goroutine执行完毕，可以检测到这个行为。
要是goroutine里面含有泄漏的bug，该泄漏还得泄漏，Wait该等待还得老实等待。
Handle panics gracefully 如果直接使用go func,那么可能每一个goroutine都得写上recover，所以一般我们在使用goroutine的时候，都是自己封装一个GoSafe函数。这样就可以在里面统一捕获panic，然后打包调用栈一些信息，进一步处理。
conc里面因为每个goroutine有owner概念，所以是由owner捕获goroutine的panic。</description>
			<content type="html"><![CDATA[<p>上周看到一个新库conc，</p>
<blockquote>
<p>better structured concurrency for go</p>
</blockquote>
<p>这个库的目标是，</p>
<ul>
<li>更难出现goroutine泄漏</li>
<li>优雅处理panic</li>
<li>使并发的代码更易读</li>
</ul>
<p>我们一条条细说。</p>
<h4 id="make-it-harder-to-leak-goroutines">Make it harder to leak goroutines</h4>
<p>goroutine泄漏还是很常见的。</p>
<p>日常我们使用go的时候直接go func开启一个goroutine，写上对应的逻辑，g会进入到某个p的本地队列，最终由p绑定的m执行这个goroutine。</p>
<p>你能保证一个goroutine在某个时刻一定会结束它的生命周期吗？</p>
<p>搜了下著名开源项目etcd，goroutine leak还真不少。</p>
<p><img src="https://cdn.syst.top/conc1.png" alt="conc"></p>
<p>看其中一个简单的泄漏bug。</p>
<p><img src="https://cdn.syst.top/conc2.png" alt="conc"></p>
<p>done是一个无缓冲的chan，一开始接收动作在最下面，因为中间还有一些没展开的代码可能会导致程序不会执行到&lt;-done，然后goroutine就会发生泄漏，解决方法就是通过defer保证一定会执行&lt;-done。</p>
<p>那么conc是如何做的？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/sourcegraph/conc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">conc</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;g1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;g2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>ps:这个结构是不是超级熟悉。</p>
<p>conc的理念是程序中的每一个goroutine由一个owner创建，归属于owner。一个owner确保它拥有的所有goroutine正常退出，这里的owner也就是conc.WaitGroup。</p>
<p>但是这真的能像他说的那样Make it harder to leak goroutines吗？</p>
<p>goroutine的泄漏问题取决于用户对goroutine能正确退出的逻辑保证，和你如何封装没关系吧？</p>
<p>在我看来conc和标准库的sync.WaitGroup一样，等待所有goroutine执行完毕，可以检测到这个行为。</p>
<p>要是goroutine里面含有泄漏的bug，该泄漏还得泄漏，Wait该等待还得老实等待。</p>
<h4 id="handle-panics-gracefully">Handle panics gracefully</h4>
<p>如果直接使用go func,那么可能每一个goroutine都得写上recover，所以一般我们在使用goroutine的时候，都是自己封装一个GoSafe函数。这样就可以在里面统一捕获panic，然后打包调用栈一些信息，进一步处理。</p>
<p>conc里面因为每个goroutine有owner概念，所以是由owner捕获goroutine的panic。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Catcher</span><span class="p">)</span> <span class="nf">tryRecover</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">val</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rp</span> <span class="o">:=</span> <span class="nf">NewRecoveredPanic</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">.</span><span class="nx">recovered</span><span class="p">.</span><span class="nf">CompareAndSwap</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">rp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>只会记录第一个panic的goroutine堆栈信息。然后在Wait操作的时候，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Propagate a panic if we caught one from a child goroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">pc</span><span class="p">.</span><span class="nf">Repanic</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Catcher</span><span class="p">)</span> <span class="nf">Repanic</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">val</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Recovered</span><span class="p">();</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>超级粗暴。当conc.WaitGroup里面任何一个goroutine发生panic，调用wg.Wait()的时候就会panic，把goroutine panic的堆栈信息作为panic的值。</p>
<p>写这篇文章的时候已经看到他们在issue上讨论添加一个类似WaitSafe()函数了。</p>
<h4 id="make-concurrent-code-easier-to-read">Make concurrent code easier to read</h4>
<p>这个还是节省了一些工作的，作者给了几个例子。</p>
<p>上面我们看到的WaitGroup，不再需要用户执行Add和Done操作了。同时内部捕获panic，虽然处理有点粗暴。</p>
<p><img src="https://cdn.syst.top/conc3.png" alt="conc"></p>
<p>比如控制并发goroutine数量来并发处理批量数据的例子。</p>
<p><img src="https://cdn.syst.top/conc4.png" alt="conc"></p>
<p><img src="https://cdn.syst.top/conc5.png" alt="conc"></p>
<p>可以看出，确实省了很多的操作，其他例子可以自行查看。</p>
<p>上面我们说到pool，其实就是一个并发执行任务的worker池，之前文章也介绍过这种模式。</p>
<p>conc里面有几个类型的pool:ContextPool，ErrorPool，ResultPool，ResultContextPool，ResultErrorPool。</p>
<p>它们都基于最基础的Pool结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Pool</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">handle</span>   <span class="nx">conc</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">limiter</span>  <span class="nx">limiter</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tasks</span>    <span class="kd">chan</span> <span class="kd">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">initOnce</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>limiter就是一个很简单的用chan控制worker goroutine数量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">limiter</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="nx">limiter</span><span class="p">)</span> <span class="nf">limit</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="nx">limiter</span><span class="p">)</span> <span class="nf">release</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">l</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">&lt;-</span><span class="nx">l</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>核心逻辑也很简单，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">.</span><span class="nf">init</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">limiter</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// No limit on the number of goroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">p</span><span class="p">.</span><span class="nx">tasks</span> <span class="o">&lt;-</span> <span class="nx">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// A goroutine was available to handle the task.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// No goroutine was available to handle the task.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// Spawn a new one and send it the task.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">handle</span><span class="p">.</span><span class="nf">Go</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">worker</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">p</span><span class="p">.</span><span class="nx">tasks</span> <span class="o">&lt;-</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">p</span><span class="p">.</span><span class="nx">limiter</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// If we are below our limit, spawn a new worker rather
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// than waiting for one to become available.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">handle</span><span class="p">.</span><span class="nf">Go</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">worker</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// We know there is at least one worker running, so wait
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// for it to become available. This ensures we never spawn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// more workers than the number of tasks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">tasks</span> <span class="o">&lt;-</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">p</span><span class="p">.</span><span class="nx">tasks</span> <span class="o">&lt;-</span> <span class="nx">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// A worker is available and has accepted the task.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果没有设置limiter，那么优先找空闲的worker。否则就创建一个新worker，然后投递任务进去。</p>
<p>设置了limiter，</p>
<p>如果达到了limter worker数量上限，那就只能把任务投递给空闲的worker，没有空闲就阻塞等着。</p>
<p>没有达到上限，空闲worker也存在，那就由select随机选择，否则的话就创建一个新的worker。</p>
<h4 id="彩蛋">彩蛋</h4>
<p>看代码的时候发现这里面有个问题，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">deref</span><span class="p">()</span> <span class="nx">Pool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">Pool</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">limiter</span><span class="p">:</span> <span class="nx">p</span><span class="p">.</span><span class="nx">limiter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个函数会返回一个新的Pool，上面我说过limiter是一个chan结构，在go中chan是一个引用类型，所以这里对limiter就是一个浅拷贝。</p>
<p>因此，下面这段代码，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TestErrorPool</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">().</span><span class="nf">WithMaxGoroutines</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">.</span><span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{})</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//p.limiter长度是1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">require</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">limiter</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">  <span class="c1">//新的ErrorPool:里面的pool是调用p.deref得到的.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ep</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">WithErrors</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">require</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ep</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nx">limiter</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">  <span class="c1">//这里的ep.limiter的长度也是1，尽管ep没有调用一次ep.Go()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>正因为这种“特性”,如果我们写了下面的代码，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">pool</span><span class="p">.</span><span class="nf">New</span><span class="p">().</span><span class="nf">WithMaxGoroutines</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">.</span><span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;g1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">.</span><span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;g2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//p.Wait()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ep</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">WithErrors</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ep</span><span class="p">.</span><span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//这段代码永远没机会执行,泄漏
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;with err &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ep</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果我们把p.Wait() 放在ep.Wait()之后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">p</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>ep.Go里面的逻辑永远都没机会执行。</p>
<p>原因就在于，第一个loop创建的时候限制了goroutine数量。然后执行两次p.Go，这样就会创建两个只属于p的workers，同时也让limiter到达限制数。</p>
<p>当ep想要执行ep.Go的时候，只能执行p.tasks &lt;- f，但是这时候ep还没有机会创建属于自己的worker，所以会阻塞到死。</p>
<p>我提了一个pr，其实就是把上面的浅拷贝换成深拷贝。</p>
<p><img src="https://cdn.syst.top/conc6.png" alt="conc"></p>
<p>但是作者回复说，</p>
<blockquote>
<p>Currently calling any configuration methods on the pool after calling pool.Go() is unsupported because the configuration methods take ownership of and mutate the pool. This might not be ideal though since ownership can&rsquo;t actually be enforced with Go. It would be less of a footgun to just return a fully copy each time.</p>
</blockquote>
<p>我理解的意思就是目前不支持我这么玩，简单的说不支持在执行pool.Go()后调用这些操作😂。</p>
]]></content>
		</item>
		
		<item>
			<title>evio原理解析～有彩蛋</title>
			<link>https://www.syst.top/posts/go/evio/</link>
			<pubDate>Fri, 06 Jan 2023 19:23:51 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/evio/</guid>
			<description>之前分析过go自带的netpoll，以及自建的网络框架gnet。
当然这类框架还有:evio、gev、nbio、cloudwego/netpoll(字节的)。
为什么会出现这么多自建框架?
我觉得逃不过三点，
  自带的netpoll满足不了一些特殊场景。
  其他实现设计存在局限性，存在优化空间。
  程序员都喜欢自己造轮子。
  另外，这类框架都是基于syscall epoll实现的事件驱动框架。主要区别我觉得在于，
 对连接conn的管理 对读写数据管理  带着这些问题，我打算把这些框架都看一遍。学习里面优秀的设计以及对比他们的不同点，可以的话，做个整体的性能测试。
这几个框架中，evio是最早的开源实现，开源于2017年。
有意思的是，看到几篇文章说evio存在当loopWrite在内核缓冲区满，无法一次写入时，会出现写入数据丢失的bug。
仔细阅读了代码，evio并不存在这个bug。也不存在是作者后来修复了这个bug，而是evio本身不存在这个bug。
下面会说明。
原理解析 根据代码画了个简易架构图说明evio架构。
简单解释一下，evio启动的时候可以指定loops个数，即多少个epoll实例。同时可以启动多个监听地址，比如图中监听了两个端口。
程序会把每个Listener fd加入到每个epoll并注册这些fd的读事件。每个epoll会开启一个goroutine等待事件到来。
当客户端发起对应端口连接，程序会根据策略选择一个epoll，并把conn fd 也加入到此epoll并注册读写事件。
当一个conn fd读事件ready，那么对应的epoll会被唤醒，然后执行相应的操作。
以上就是整理的流程，接下来我们来深入一些细节。
在此之前，根据上面所描述的，需要先提几个问题，
 当一个新的客户端连接到来时，会发生什么？ 读写数据是如何流动的？ 同一个epoll里多个fd读写事件ready，程序是如何处理的？  看完下面，再回来回答这三个问题。
代码细节 运行一个简单demo，
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/tidwall/evio&amp;#34; &amp;#34;log&amp;#34; ) func main() { var events evio.Events events.NumLoops = 3 events.Serving = func(srv evio.Server) (action evio.Action) { log.</description>
			<content type="html"><![CDATA[<p>之前分析过go自带的netpoll，以及自建的网络框架gnet。</p>
<p>当然这类框架还有:evio、gev、nbio、cloudwego/netpoll(字节的)。</p>
<p>为什么会出现这么多自建框架?</p>
<p>我觉得逃不过三点，</p>
<ul>
<li>
<p>自带的netpoll满足不了一些特殊场景。</p>
</li>
<li>
<p>其他实现设计存在局限性，存在优化空间。</p>
</li>
<li>
<p>程序员都喜欢自己造轮子。</p>
</li>
</ul>
<p>另外，这类框架都是基于syscall epoll实现的事件驱动框架。主要区别我觉得在于，</p>
<ul>
<li>对连接conn的管理</li>
<li>对读写数据管理</li>
</ul>
<p>带着这些问题，我打算把这些框架都看一遍。学习里面优秀的设计以及对比他们的不同点，可以的话，做个整体的性能测试。</p>
<p>这几个框架中，evio是最早的开源实现，开源于2017年。</p>
<p>有意思的是，看到几篇文章说evio存在当loopWrite在内核缓冲区满，无法一次写入时，会出现写入数据丢失的bug。</p>
<p><img src="https://cdn.syst.top/evio3.png" alt=""></p>
<p>仔细阅读了代码，evio并不存在这个bug。也不存在是作者后来修复了这个bug，而是evio本身不存在这个bug。</p>
<p>下面会说明。</p>
<h4 id="原理解析">原理解析</h4>
<p>根据代码画了个简易架构图说明evio架构。</p>
<p><img src="https://cdn.syst.top/evio1.png" alt=""></p>
<p>简单解释一下，evio启动的时候可以指定loops个数，即多少个epoll实例。同时可以启动多个监听地址，比如图中监听了两个端口。</p>
<p>程序会把每个Listener fd加入到每个epoll并注册这些fd的读事件。每个epoll会开启一个goroutine等待事件到来。</p>
<p>当客户端发起对应端口连接，程序会根据策略选择一个epoll，并把conn fd 也加入到此epoll并注册读写事件。</p>
<p>当一个conn fd读事件ready，那么对应的epoll会被唤醒，然后执行相应的操作。</p>
<p>以上就是整理的流程，接下来我们来深入一些细节。</p>
<p>在此之前，根据上面所描述的，需要先提几个问题，</p>
<ul>
<li>当一个新的客户端连接到来时，会发生什么？</li>
<li>读写数据是如何流动的？</li>
<li>同一个epoll里多个fd读写事件ready，程序是如何处理的？</li>
</ul>
<p>看完下面，再回来回答这三个问题。</p>
<h5 id="代码细节">代码细节</h5>
<p>运行一个简单demo，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/tidwall/evio&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">events</span> <span class="nx">evio</span><span class="p">.</span><span class="nx">Events</span>
</span></span><span class="line"><span class="cl">	<span class="nx">events</span><span class="p">.</span><span class="nx">NumLoops</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">	<span class="nx">events</span><span class="p">.</span><span class="nx">Serving</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">srv</span> <span class="nx">evio</span><span class="p">.</span><span class="nx">Server</span><span class="p">)</span> <span class="p">(</span><span class="nx">action</span> <span class="nx">evio</span><span class="p">.</span><span class="nx">Action</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;echo server started&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">events</span><span class="p">.</span><span class="nx">Data</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">evio</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">in</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">out</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">action</span> <span class="nx">evio</span><span class="p">.</span><span class="nx">Action</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;receiver data:&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">in</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">out</span> <span class="p">=</span> <span class="nx">in</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">evio</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">events</span><span class="p">,</span> <span class="s">&#34;tcp://:8089&#34;</span><span class="p">,</span> <span class="s">&#34;tcp://:8088&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们指定NumLoops的数量是3，然后传入了两个地址。</p>
<p>上面还有两个闭包函数，当服务启动的时候会回调events.Serving函数，然后返回一个Action。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// None indicates that no action should occur following an event.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">None</span> <span class="nx">Action</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Detach detaches a connection. Not available for UDP connections.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Detach</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Close closes the connection.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Close</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Shutdown shutdowns the server.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Shutdown</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>比如当你返回一个Shutdown的action，那么程序就直接退出了。</p>
<p>当有客户端数据到来时，回调events.Data函数，返回out和action，out表示要发送的数据。</p>
<p>最终调用 evio.Serve函数，传入两个地址，启动服务。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Serve</span><span class="p">(</span><span class="nx">events</span> <span class="nx">Events</span><span class="p">,</span> <span class="nx">addr</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">lns</span> <span class="p">[]</span><span class="o">*</span><span class="nx">listener</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ln</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lns</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ln</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">addr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">ln</span> <span class="nx">listener</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ln</span><span class="p">.</span><span class="nx">network</span><span class="p">,</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">_</span><span class="p">=</span> <span class="nf">parseAddr</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">network</span> <span class="o">==</span> <span class="s">&#34;unix&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">os</span><span class="p">.</span><span class="nf">RemoveAll</span><span class="p">(</span><span class="nx">ln</span><span class="p">.</span><span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">network</span> <span class="o">==</span> <span class="s">&#34;udp&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">reusePort</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">ln</span><span class="p">.</span><span class="nx">pconn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">reuseportListenPacket</span><span class="p">(</span><span class="nx">ln</span><span class="p">.</span><span class="nx">network</span><span class="p">,</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">ln</span><span class="p">.</span><span class="nx">pconn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ListenPacket</span><span class="p">(</span><span class="nx">ln</span><span class="p">.</span><span class="nx">network</span><span class="p">,</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">reusePort</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">ln</span><span class="p">.</span><span class="nx">ln</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">reuseportListen</span><span class="p">(</span><span class="nx">ln</span><span class="p">.</span><span class="nx">network</span><span class="p">,</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">ln</span><span class="p">.</span><span class="nx">ln</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="nx">ln</span><span class="p">.</span><span class="nx">network</span><span class="p">,</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">pconn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ln</span><span class="p">.</span><span class="nx">lnaddr</span> <span class="p">=</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">pconn</span><span class="p">.</span><span class="nf">LocalAddr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ln</span><span class="p">.</span><span class="nx">lnaddr</span> <span class="p">=</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">ln</span><span class="p">.</span><span class="nf">Addr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lns</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">lns</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">ln</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">serve</span><span class="p">(</span><span class="nx">events</span><span class="p">,</span> <span class="nx">lns</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我删除了一些无关代码。</p>
<p>Serve 函数里面遍历传入的地址识别协议，执行对应listen操作。udp返回一个PacketConn，而tcp返回一个Listener。最终用自定义的listener统一表示。最终调用serve。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">serve</span><span class="p">(</span><span class="nx">events</span> <span class="nx">Events</span><span class="p">,</span> <span class="nx">listeners</span> <span class="p">[]</span><span class="o">*</span><span class="nx">listener</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// figure out the correct number of loops/goroutines to use.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">numLoops</span> <span class="o">:=</span> <span class="nx">events</span><span class="p">.</span><span class="nx">NumLoops</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">numLoops</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">numLoops</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">numLoops</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">numLoops</span> <span class="p">=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">server</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">events</span> <span class="p">=</span> <span class="nx">events</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">lns</span> <span class="p">=</span> <span class="nx">listeners</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">cond</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">balance</span> <span class="p">=</span> <span class="nx">events</span><span class="p">.</span><span class="nx">LoadBalance</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">tch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//println(&#34;-- server starting&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">Serving</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">svr</span> <span class="nx">Server</span>
</span></span><span class="line"><span class="cl">		<span class="nx">svr</span><span class="p">.</span><span class="nx">NumLoops</span> <span class="p">=</span> <span class="nx">numLoops</span>
</span></span><span class="line"><span class="cl">		<span class="nx">svr</span><span class="p">.</span><span class="nx">Addrs</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">net</span><span class="p">.</span><span class="nx">Addr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">listeners</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ln</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">listeners</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">svr</span><span class="p">.</span><span class="nx">Addrs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">lnaddr</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">action</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nf">Serving</span><span class="p">(</span><span class="nx">svr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="nx">action</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">Shutdown</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// wait on a signal for shutdown
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nf">waitForShutdown</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// notify all loops to close by closing all listeners
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">loops</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">l</span><span class="p">.</span><span class="nx">poll</span><span class="p">.</span><span class="nf">Trigger</span><span class="p">(</span><span class="nx">errClosing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// wait on all loops to complete reading events
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// close loops and all outstanding connections
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">loops</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">l</span><span class="p">.</span><span class="nx">fdconns</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">loopCloseConn</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">l</span><span class="p">.</span><span class="nx">poll</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//println(&#34;-- server stopped&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// create loops locally and bind the listeners.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">numLoops</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">loop</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">idx</span><span class="p">:</span>     <span class="nx">i</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">poll</span><span class="p">:</span>    <span class="nx">internal</span><span class="p">.</span><span class="nf">OpenPoll</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">			<span class="nx">packet</span><span class="p">:</span>  <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mh">0xFFFF</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fdconns</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">conn</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ln</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">listeners</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">l</span><span class="p">.</span><span class="nx">poll</span><span class="p">.</span><span class="nf">AddRead</span><span class="p">(</span><span class="nx">ln</span><span class="p">.</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">loops</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">loops</span><span class="p">,</span> <span class="nx">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// start loops in background
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">loops</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">loops</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nf">loopRun</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个函数逻辑:</p>
<p>1.先初始化一个自定义server结构，确定负载均衡算法。</p>
<p>2.回调自定义的serving闭包函数。</p>
<p>3.根据numloops值，创建对应数量的epoll封装在自定义结构loop中。并把每一个listener对应的fd加入到每一个epoll同时注册fd的读事件，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ln</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">listeners</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">l</span><span class="p">.</span><span class="nx">poll</span><span class="p">.</span><span class="nf">AddRead</span><span class="p">(</span><span class="nx">ln</span><span class="p">.</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Poll</span><span class="p">)</span> <span class="nf">AddRead</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">EpollCtl</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="nx">fd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="o">&amp;</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">EpollEvent</span><span class="p">{</span><span class="nx">Fd</span><span class="p">:</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">fd</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Events</span><span class="p">:</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPOLLIN</span><span class="p">,</span> <span class="c1">//读事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>4.遍历loops,每个loop都用一个g执行loopRun函数。</p>
<p>至于loopRun函数，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">loopRun</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">server</span><span class="p">,</span> <span class="nx">l</span> <span class="o">*</span><span class="nx">loop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//fmt.Println(&#34;-- loop stopped --&#34;, l.idx)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nf">signalShutdown</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">Tick</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nf">loopTicker</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//fmt.Println(&#34;-- loop started --&#34;, l.idx)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">l</span><span class="p">.</span><span class="nx">poll</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">note</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">fd</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopNote</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">note</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">fdconns</span><span class="p">[</span><span class="nx">fd</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopAccept</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">opened</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopOpened</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopWrite</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">c</span><span class="p">.</span><span class="nx">action</span> <span class="o">!=</span> <span class="nx">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopAction</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopRead</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>每个loop都会调用epoll.Wait函数阻塞等待事件到来，参数时一个闭包函数，每一个到达的事件都会回调此闭包执行相应操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Poll</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">(</span><span class="nx">iter</span> <span class="kd">func</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">note</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">events</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">EpollEvent</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">EpollWait</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">events</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINTR</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">notes</span><span class="p">.</span><span class="nf">ForEach</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">note</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">iter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">note</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 正常的客户端fd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">fd</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">events</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Fd</span><span class="p">);</span> <span class="nx">fd</span> <span class="o">!=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">wfd</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">iter</span><span class="p">(</span><span class="nx">fd</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">fd</span> <span class="o">==</span> <span class="nx">p</span><span class="p">.</span><span class="nx">wfd</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="kd">var</span> <span class="nx">data</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">				<span class="nx">syscall</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">wfd</span><span class="p">,</span> <span class="nx">data</span><span class="p">[:])</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>回到上一步，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">l</span><span class="p">.</span><span class="nx">poll</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">note</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">fd</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopNote</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">note</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">fdconns</span><span class="p">[</span><span class="nx">fd</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopAccept</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">opened</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopOpened</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopWrite</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">c</span><span class="p">.</span><span class="nx">action</span> <span class="o">!=</span> <span class="nx">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopAction</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">loopRead</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span></code></pre></div><p>注意这里是每个loop都会调用自己的epoll.Wait。当对应的Listener来了一个新客户端连接，所有的epoll都会被“惊醒”，这就是惊群效应。</p>
<blockquote>
<p>惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么它就会唤醒等待的所有进程（或者线程）</p>
</blockquote>
<p>然后所有的loop都会执行loopAccept函数，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">loopAccept</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">server</span><span class="p">,</span> <span class="nx">l</span> <span class="o">*</span><span class="nx">loop</span><span class="p">,</span> <span class="nx">fd</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ln</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lns</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 确实是哪个listener fd 事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">fd</span> <span class="o">==</span> <span class="nx">fd</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">loops</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">switch</span> <span class="nx">s</span><span class="p">.</span><span class="nx">balance</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nx">LeastConnections</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">               <span class="nx">n</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">lp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">loops</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="c1">// 对比其他的loop，有比自己连接数少的，自己就不连接了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="k">if</span> <span class="nx">lp</span><span class="p">.</span><span class="nx">idx</span> <span class="o">!=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">idx</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                     <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lp</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">return</span> <span class="kc">nil</span> <span class="c1">// do not accept
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="p">}</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">               <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nx">RoundRobin</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">               <span class="nx">idx</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">accepted</span><span class="p">))</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">loops</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="c1">//还没轮到我，也不能连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="k">if</span> <span class="nx">idx</span> <span class="o">!=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">idx</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="k">return</span> <span class="kc">nil</span> <span class="c1">// do not accept
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="p">}</span>
</span></span><span class="line"><span class="cl">               <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">accepted</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="c1">// udp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">pconn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">loopUDPRead</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="nx">nfd</span><span class="p">,</span> <span class="nx">sa</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Accept</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="c1">//设置 conn fd 为非阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">SetNonblock</span><span class="p">(</span><span class="nx">nfd</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">conn</span><span class="p">{</span><span class="nx">fd</span><span class="p">:</span> <span class="nx">nfd</span><span class="p">,</span> <span class="nx">sa</span><span class="p">:</span> <span class="nx">sa</span><span class="p">,</span> <span class="nx">lnidx</span><span class="p">:</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">loop</span><span class="p">:</span> <span class="nx">l</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="nx">c</span><span class="p">.</span><span class="nx">out</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">         <span class="nx">l</span><span class="p">.</span><span class="nx">fdconns</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">]</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">         <span class="c1">//把conn fd 注册到此epoll，且监听读写事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="nx">l</span><span class="p">.</span><span class="nx">poll</span><span class="p">.</span><span class="nf">AddReadWrite</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">break</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>loopAccept做了几件事：</p>
<p>1.确定就绪的fd是哪个listener</p>
<p>2.如果loops大于1，通过策略选择其中一个loop,包装conn fd且设置conn fd为非阻塞(思考下如果让conn fd保持阻塞状态，会影响到什么？)</p>
<p>3.最后把这个conn fd加入到当前epoll并且注册读写事件</p>
<p>因此当一个新的客户端连接到来时，会发生什么？</p>
<p>会产生惊群效应。</p>
<p>那如果是已存在的conn fd的可读事件，会发生惊群效应吗？</p>
<p>不会，因为一个conn fd只会加入到其中一个epoll中。</p>
<p>因为evio创建epoll的时候默认是水平触发LT(level-triggered)，当加入的conn fd包含写事件时，如果此时内核写缓冲区空间未满，那么epoll会再次被唤醒。此时通过f.fdconns[fd]会找到对应的conn，由于连接初始化并未设置opened的直，因此会进入loopOpened函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">loopOpened</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">server</span><span class="p">,</span> <span class="nx">l</span> <span class="o">*</span><span class="nx">loop</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">opened</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">addrIndex</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">lnidx</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">localAddr</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lns</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">lnidx</span><span class="p">].</span><span class="nx">lnaddr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">remoteAddr</span> <span class="p">=</span> <span class="nx">internal</span><span class="p">.</span><span class="nf">SockaddrToAddr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">sa</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">Opened</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">out</span><span class="p">,</span> <span class="nx">opts</span><span class="p">,</span> <span class="nx">action</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nf">Opened</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">out</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">byte</span><span class="p">{},</span> <span class="nx">out</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">action</span> <span class="p">=</span> <span class="nx">action</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">reuse</span> <span class="p">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">ReuseInputBuffer</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">TCPKeepAlive</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lns</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">lnidx</span><span class="p">].</span><span class="nx">ln</span><span class="p">.(</span><span class="o">*</span><span class="nx">net</span><span class="p">.</span><span class="nx">TCPListener</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">internal</span><span class="p">.</span><span class="nf">SetKeepAlive</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">opts</span><span class="p">.</span><span class="nx">TCPKeepAlive</span><span class="o">/</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 没有可写的数据，并且也未设置连接的action，重新修改此conn只有read事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">action</span> <span class="o">==</span> <span class="nx">None</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nx">poll</span><span class="p">.</span><span class="nf">ModRead</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>无非是一些简单赋值操作，如果设置了Opened闭包函数，那么回调它。</p>
<p>最后如果out没有可发送的事件，那么就重新把此conn fd修改成读事件。</p>
<p>想象一下，如果在没有可写数据的情况下，加入epoll的conn fd注册含有写事件，那么只要内核写缓存区未满，此epoll会不断被唤醒，我称它是空转。</p>
<p>如果上面你设置了Opened闭包函数且最终action设置了值，那么就还是保持此conn fd的读写事件。</p>
<p>这时候再次唤醒的epoll会执行loopAction，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">loopAction</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">server</span><span class="p">,</span> <span class="nx">l</span> <span class="o">*</span><span class="nx">loop</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">switch</span> <span class="nx">c</span><span class="p">.</span><span class="nx">action</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="nx">c</span><span class="p">.</span><span class="nx">action</span> <span class="p">=</span> <span class="nx">None</span>
</span></span><span class="line"><span class="cl">   <span class="k">case</span> <span class="nx">Close</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nf">loopCloseConn</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">case</span> <span class="nx">Shutdown</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">errClosing</span>
</span></span><span class="line"><span class="cl">   <span class="k">case</span> <span class="nx">Detach</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nf">loopDetachConn</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">action</span> <span class="o">==</span> <span class="nx">None</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">l</span><span class="p">.</span><span class="nx">poll</span><span class="p">.</span><span class="nf">ModRead</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面代码很简单。</p>
<p>当client发送数据，epoll被唤醒，执行loopRead。</p>
<pre tabindex="0"><code>func loopRead(s *server, l *loop, c *conn) error {
   var in []byte
   // 读数据
   n, err := syscall.Read(c.fd, l.packet)
   if n == 0 || err != nil {
      if err == syscall.EAGAIN {
         return nil
      }
      return loopCloseConn(s, l, c, err)
   }
   in = l.packet[:n]
   if !c.reuse {
      in = append([]byte{}, in...)
   }
   // 回调data闭包函数
   if s.events.Data != nil {
      out, action := s.events.Data(c, in)
      c.action = action
      // 表示要发送的数据
      if len(out) &gt; 0 {
         c.out = append(c.out[:0], out...)
      }
   }
   // 说明有数据要发送，重新注册读写事件
   if len(c.out) != 0 || c.action != None {
      l.poll.ModReadWrite(c.fd)
   }
   return nil
}
</code></pre><p>先读取数据，如果有数据要发送，又会修改conn fd为读写事件。当epoll再次被唤醒，且c.out不为空时，执行loopWrite。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">loopWrite</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">server</span><span class="p">,</span> <span class="nx">l</span> <span class="o">*</span><span class="nx">loop</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">PreWrite</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nf">PreWrite</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">loopCloseConn</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 说明一次就写完数据了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// release the connection output page if it goes over page size,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// otherwise keep reusing existing page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 不让out无限增长空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">4096</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">out</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 重置nil，复用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">out</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//没写完，留着后面没写的部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">out</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">[</span><span class="nx">n</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 全写完了，重新调整为读事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">action</span> <span class="o">==</span> <span class="nx">None</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nx">poll</span><span class="p">.</span><span class="nf">ModRead</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果一次写完数据，那么说明暂时没有可写的数据了，重新修改conn fd为读事件。</p>
<p>如果一次没写完，那么保留未写完的数据，下次epoll唤醒的时候继续写。</p>
<p>上面提到，一些文章提到，evio存在 loopWrite在内核缓冲区满，无法一次写入时，会出现写入数据丢失的bug。</p>
<p>给的理由是，当内核写缓冲区满了，可数据并未写完。此时另一个conn读事件ready，会执行loopRead。</p>
<p>loopRead有这么一段代码，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">Data</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">out</span><span class="p">,</span> <span class="nx">action</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nf">Data</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">action</span> <span class="p">=</span> <span class="nx">action</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 表示要发送的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 之前这里是:c.out = append([]byte{}, out...)，效果是一样的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">out</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">out</span><span class="p">[:</span><span class="mi">0</span><span class="p">],</span> <span class="nx">out</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><p>那么此时之前未发送完的数据就会被覆盖，导致数据丢失。</p>
<p>但是我仔细看了代码，并不存在这个bug。</p>
<p>因为如果第一次没写完，假设此时同一个epoll下的另一个conn读事件ready，由于out还有未写完的数据，只会执行loopWrite分支， 并不会走到默认分支loopRead，也就不存在写数据被覆盖导致丢失的问题了。</p>
<p>有趣的是，这样的情况会导致空转。因为执行loopWrite逻辑，由于内核写缓冲区已满，导致写不进去数据，会出现syscall.EAGAIN直接返回。又因此时还有可读的数据没读，会不断唤醒epoll。</p>
<p>调用epoll_wait会陷入内核态，所以会导致不断的在用户态和内核态切换。直到写完数据，才能读其他conn数据。</p>
<p>到这里，核心的代码已经分析完了。</p>
<h4 id="evio存在的问题">Evio存在的问题</h4>
<p><strong>惊群效应</strong>。</p>
<p><strong>串行化</strong></p>
<p>从上面的分析可以看出，如果一个epoll有两个fd可读事件ready，那么第二个fd必须等第一个执行完毕，才开始执行。</p>
<p>换句话说，如果这个闭包函数里有外部依赖调用，第二个就得一直等。</p>
<p>不能在Data函数里用go func吗？</p>
<p>还真不能，要是这样的话又会涉及到数据并发问题，数据会发生错乱。</p>
<p>同一个epoll下的conn是共享数据结构的，如果使用异步，必然又涉及到锁的问题。</p>
<p><strong>数据copy问题</strong></p>
<p>evio采用的是同步处理buffer数据，直接通过syscall读写操作存在copy开销，这是cpu直接参与的。看字节的netpoll使用的zero-copy的技术，后面再看源码。</p>
<p><strong>频繁唤醒epoll</strong></p>
<p>evio会通过不断修改conn fd的事件来唤醒epoll，达到逻辑上的正确性。频繁唤醒的方式并不是很妥，这种方式是存在开销的。</p>
<p>这篇文章到这里就结束了，分析完go自建netpoll &ldquo;鼻祖&rdquo; evio，以及它存在局限性，就可以继续学习后续其他框架的设计了。</p>
]]></content>
		</item>
		
		<item>
			<title>easycar更新日记</title>
			<link>https://www.syst.top/posts/go/easycar2/</link>
			<pubDate>Sun, 06 Nov 2022 10:11:22 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/easycar2/</guid>
			<description>开篇 又拖更了一个多月，在思考人生的意义。
上一次介绍了新开发的一个分布式的事务框架easycar，这篇就当是对easycar的更新日记了。
服务注册与发现
由于easycar底层基于gRPC, 通过自定义Resolver接口还是很容易实现的。
负载均衡
客户端负载均衡，目前支持
  round-robin
  random
  power of 2 random choice
  consistent hash
  ip-hash
  least-load
  架构图
上次提到，参与的一组分布式事务可能部分操作存在先后顺序的问题。
我举了个例子，我们需要保证必须先执行account扣减余额和stock扣减库存服务成功后，才能创建订单order的服务。同时account和stock服务并不需要保证他们的执行顺序。下图，
以这个例子，那么实际在easycar中整个流程，
成功
失败
在easycar中，client负责和easycar(TC)端交互。主要负责注册分支，触发执行分布式事务以及查看状态等。
它并不会和RM产生联系。也就是说它不会负责去请求RM的第一阶段，这是和其他平台不同的一点。
TC全程接管和更新RM状态。
分支状态
项目地址:
Easycar: https://github.com/wuqinqiang/easycar
Client-go: https://github.com/easycar/client-go
Examples： https://github.com/easycar/examples</description>
			<content type="html"><![CDATA[<h4 id="开篇">开篇</h4>
<p>又拖更了一个多月，在思考人生的意义。</p>
<p>上一次介绍了新开发的一个分布式的事务框架easycar，这篇就当是对easycar的更新日记了。</p>
<p><strong>服务注册与发现</strong></p>
<p>由于easycar底层基于gRPC, 通过自定义Resolver接口还是很容易实现的。</p>
<p><strong>负载均衡</strong></p>
<p>客户端负载均衡，目前支持</p>
<ul>
<li>
<p><code>round-robin</code></p>
</li>
<li>
<p><code>random</code></p>
</li>
<li>
<p><code>power of 2 random choice</code></p>
</li>
<li>
<p><code>consistent hash</code></p>
</li>
<li>
<p><code>ip-hash</code></p>
</li>
<li>
<p><code>least-load</code></p>
</li>
</ul>
<p>架构图</p>
<p><img src="https://cdn.syst.top/easycar2.jpg" alt="easycar"></p>
<p>上次提到，参与的一组分布式事务可能部分操作存在先后顺序的问题。</p>
<p>我举了个例子，我们需要保证必须先执行account扣减余额和stock扣减库存服务成功后，才能创建订单order的服务。同时account和stock服务并不需要保证他们的执行顺序。下图，</p>
<p><img src="https://cdn.syst.top/servers.png" alt="global">以这个例子，那么实际在easycar中整个流程，</p>
<p><strong>成功</strong></p>
<p><img src="https://cdn.syst.top/success2.png" alt="success"></p>
<p><strong>失败</strong></p>
<p><img src="https://cdn.syst.top/failed2.png" alt="failed"></p>
<p>在easycar中，client负责和easycar(TC)端交互。主要负责注册分支，触发执行分布式事务以及查看状态等。</p>
<p>它并不会和RM产生联系。也就是说它不会负责去请求RM的第一阶段，这是和其他平台不同的一点。</p>
<p>TC全程接管和更新RM状态。</p>
<p>分支状态</p>
<p><img src="https://cdn.syst.top/state3.png" alt="global"></p>
<p>项目地址:</p>
<p>Easycar: <a href="https://github.com/wuqinqiang/easycar">https://github.com/wuqinqiang/easycar</a></p>
<p>Client-go: <a href="https://github.com/easycar/client-go">https://github.com/easycar/client-go</a></p>
<p>Examples： <a href="https://github.com/easycar/examples">https://github.com/easycar/examples</a></p>
]]></content>
		</item>
		
		<item>
			<title>一个用go实现的分布式事务框架</title>
			<link>https://www.syst.top/posts/go/easycar/</link>
			<pubDate>Mon, 12 Sep 2022 18:11:22 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/easycar/</guid>
			<description>开篇 对分布式事务一直感兴趣，之前一直被其他事情(懒)耽搁了，最近终于动手了。
easycar是什么 easycar 是一个用go实现的支持两阶段提交协议的分布式事务框架。目前还只支持TCC,SAGA 模式，其他模式待开发。
在介绍easycar 之前，先简单介绍几个角色。
Transaction Coordinator(TC) 负责全局事务的管理，所有参与分布式事务的分支都会注册到coordinator，回给每个分布式事务分配一个唯一id，
当然还包括驱动全局 begin / commit /abort(我喜欢称rollback)。
Transaction Manager (TM) 有些时候也叫 Transaction Client，当然不同的实现也许都会换个名字，但是职责都大差不差。
一般通过TM对每个参与的RM发起一阶段的请求，如果一阶段的RM全部成功，那么TM会向TC发起commit请求，否则发起rollback。
Resource Manager(RM) 用户维度的角色，管理本地事务处理的资源。其实你可以这么理解，假设你的订单服务部分接口参与了分布式事务，无论是第一阶段TM调用接口，还是TC第二阶段调用接口，你的订单服务都会去负责本地的事务修改。
那么 easycar 上述角色有什么不同吗？
有的。既然TC负责的就是全局事务的管理，那么我把职责都给了它。即由TC像每个参与的RM发起一阶段的请求，然后再根据一阶段的结果，发起二阶段的请求。由TC接管整个分布式事务的生命周期。
是的，我弱化了上面TM的能力。在我眼里，TM本质上就是一个客户端。客户端只需要做一些数据封装，简便化操作即可。所以即使没有客户端，其他语言的用户也可以直接通过http请求easycar服务接口。
所以理论上，大部分模式下，不需要客户端也是可以直接使用easycar服务的。
支持协议和事务模式同时混用 参与分布式事务的服务往往由不同的多个部门维护，或者部分新老项目交错，可能无法保证服务的协议是一致的。
另外，不同的服务所采用的事务模式具体是由：业务场景以及构造的成本来决定的。所以参与分布式事务之间所使用的事务模式不一定是统一的。
在这些基础上，easycar支持协议混用(目前支持http和原生的grpc服务)，支持部分事务模式混用(目前支持TCC,Saga)。
支持并发执行 假如现在有 order，account以及stock三个服务。
由这三个服务组成一个分布式事务。 当用户下单时，需要经过这三个服务中内部一些接口(account 扣钱，stock减库存，order 创建订单)。
如果只是同步执行第一阶段，那么第一阶段总执行时间= (account+stock+order)。
很多场景下，分布式事务之间并不会存在执行依赖先后的关系。所以多个子事务一阶段可以同时并发执行。
流程就像这样：
上图我们需要保证创建订单前必须先执行account扣减余额和stock扣减库存服务，才能创建订单order的服务。同时account和stock服务并不需要保证他们的执行顺序。
那么我们一阶段总执行耗时可以粗略=max(account,stock)+order。
因此，easycar是支持分层并发执行的。 对参与的RM通过设置的权重做分层，同一层的RM可以并发调用，一层处理完毕再接下一层。在这个基础上，当某个RM发生调用错误时，那么后面一层也不会执行了，整个分布式事务需要回滚。
异常处理 分布式事务中会出现一些问题，比如
  空补偿： Cancel请求到来时，Try还没有执行，这时候这样的请求我们不能执行，理应直接返回。
  悬挂： Try执行时，Cancel已执行完成，不能执行，直接返回。
  幂等： 所有操作的接口都存在这个问题。
  这些问题需要用户自己去解决，框架不会自动帮你处理。
在我看来，这些问题本身就是服务的必要工作，而不是通过外部服务来帮你保证。
换句话说，前端说它参数做了校验，难道后端就不校验接口了吗？</description>
			<content type="html"><![CDATA[<h3 id="开篇">开篇</h3>
<p>对分布式事务一直感兴趣，之前一直被其他事情(懒)耽搁了，最近终于动手了。</p>
<h3 id="easycar是什么">easycar是什么</h3>
<p>easycar 是一个用go实现的支持两阶段提交协议的分布式事务框架。目前还只支持TCC,SAGA 模式，其他模式待开发。</p>
<p>在介绍easycar 之前，先简单介绍几个角色。</p>
<h4 id="transaction-coordinatortc">Transaction Coordinator(TC)</h4>
<p>负责全局事务的管理，所有参与分布式事务的分支都会注册到coordinator，回给每个分布式事务分配一个唯一id，</p>
<p>当然还包括驱动全局 begin / commit /abort(我喜欢称rollback)。</p>
<h4 id="transaction-manager-tm">Transaction Manager (TM)</h4>
<p>有些时候也叫 Transaction Client，当然不同的实现也许都会换个名字，但是职责都大差不差。</p>
<p>一般通过TM对每个参与的RM发起一阶段的请求，如果一阶段的RM全部成功，那么TM会向TC发起commit请求，否则发起rollback。</p>
<h4 id="resource-managerrm">Resource Manager(RM)</h4>
<p>用户维度的角色，管理本地事务处理的资源。其实你可以这么理解，假设你的订单服务部分接口参与了分布式事务，无论是第一阶段TM调用接口，还是TC第二阶段调用接口，你的订单服务都会去负责本地的事务修改。</p>
<p>那么 easycar 上述角色有什么不同吗？</p>
<p>有的。既然TC负责的就是全局事务的管理，那么我把职责都给了它。即由TC像每个参与的RM发起一阶段的请求，然后再根据一阶段的结果，发起二阶段的请求。由TC接管整个分布式事务的生命周期。</p>
<p>是的，我弱化了上面TM的能力。在我眼里，TM本质上就是一个客户端。客户端只需要做一些数据封装，简便化操作即可。所以即使没有客户端，其他语言的用户也可以直接通过http请求easycar服务接口。</p>
<p>所以理论上，大部分模式下，不需要客户端也是可以直接使用easycar服务的。</p>
<h4 id="支持协议和事务模式同时混用">支持协议和事务模式同时混用</h4>
<p>参与分布式事务的服务往往由不同的多个部门维护，或者部分新老项目交错，可能无法保证服务的协议是一致的。</p>
<p>另外，不同的服务所采用的事务模式具体是由：业务场景以及构造的成本来决定的。所以参与分布式事务之间所使用的事务模式不一定是统一的。</p>
<p>在这些基础上，easycar支持协议混用(目前支持http和原生的grpc服务)，支持部分事务模式混用(目前支持TCC,Saga)。</p>
<h4 id="支持并发执行">支持并发执行</h4>
<p>假如现在有 order，account以及stock三个服务。</p>
<p>由这三个服务组成一个分布式事务。
当用户下单时，需要经过这三个服务中内部一些接口(account 扣钱，stock减库存，order 创建订单)。</p>
<p>如果只是同步执行第一阶段，那么第一阶段总执行时间= (account+stock+order)。</p>
<p>很多场景下，分布式事务之间并不会存在执行依赖先后的关系。所以多个子事务一阶段可以同时并发执行。</p>
<p>流程就像这样：</p>
<p><img src="https://cdn.syst.top/servers.png" alt="global"></p>
<p>上图我们需要保证创建订单前必须先执行account扣减余额和stock扣减库存服务，才能创建订单order的服务。同时account和stock服务并不需要保证他们的执行顺序。</p>
<p>那么我们一阶段总执行耗时可以粗略=max(account,stock)+order。</p>
<p>因此，easycar是支持分层并发执行的。 对参与的RM通过设置的权重做分层，同一层的RM可以并发调用，一层处理完毕再接下一层。在这个基础上，当某个RM发生调用错误时，那么后面一层也不会执行了，整个分布式事务需要回滚。</p>
<h4 id="异常处理">异常处理</h4>
<p>分布式事务中会出现一些问题，比如</p>
<ul>
<li>
<p><strong>空补偿：</strong> Cancel请求到来时，Try还没有执行，这时候这样的请求我们不能执行，理应直接返回。</p>
</li>
<li>
<p><strong>悬挂：</strong> Try执行时，Cancel已执行完成，不能执行，直接返回。</p>
</li>
<li>
<p><strong>幂等：</strong> 所有操作的接口都存在这个问题。</p>
</li>
</ul>
<p>这些问题需要用户自己去解决，框架不会自动帮你处理。</p>
<p>在我看来，这些问题本身就是服务的必要工作，而不是通过外部服务来帮你保证。</p>
<p>换句话说，前端说它参数做了校验，难道后端就不校验接口了吗？</p>
<h4 id="重试">重试</h4>
<p>这一块暂时还没决定最终方案。</p>
<p>我眼中的重试有两种模式：同步和异步。</p>
<p>同步的意思是说，当请求RM服务发生错误的时候(网络、服务本身挂了、或者服务里的中间件挂了)，通过固定次数固定时间重试，这个时间通常很短，比如一秒。问题是服务挂的情况下，短时间大概率好不了，重试几乎可能是无用功。整个过程，客户端是阻塞等待的，白白耗费时间。</p>
<p>异步重试采用指数退避算法之类的逻辑，比如第一次重试1分钟后，第二次2分钟&hellip;..，限制一个上限值，比如最多延迟一个小时还是不行的话，那只能发告警，线下处理了。</p>
<p>这样的弊端是，</p>
<ul>
<li>首先用户不能实时获取本次分布式事务结果了(正在重试中)，只能等到真正执行完毕的时候通过回调的方式异步通知用户分布式事务最终结果。</li>
<li>退避时间越长，就意味着数据不一致的时间越长。但是如果人工直接干预又存在极大的风险。比如在你人工干预的同时，正好逻辑已经开始执行了，可能会造成新的数据不一致。</li>
</ul>
<h4 id="状态流转图">状态流转图</h4>
<p>global 状态流转图</p>
<p><img src="https://cdn.syst.top/global.png" alt="global"></p>
<h3 id="最后">最后</h3>
<p>easycar 开发不是很久，它还有好多工作需要去完成。感兴趣的可以一起加入。</p>
<p>项目地址：https://github.com/wuqinqiang/easycar</p>
]]></content>
		</item>
		
		<item>
			<title>Gnet原理解析</title>
			<link>https://www.syst.top/posts/go/gnet/</link>
			<pubDate>Tue, 07 Jun 2022 16:23:51 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/gnet/</guid>
			<description>距离上次写文章过了一月有余，这段时间着实太躺了。以至于昨晚做了一个噩梦，醒来的时候狠狠的抽了自己两巴掌，不能这么躺了。
上面当然是个笑话。
开篇 上一篇我们分析了Go原生网络模型以及部分源码，绝大部分场景下(99%)，使用原生netpoll已经足够了。
但是在一些海量并发连接下，原生netpoll会为每一个连接都开启一个goroutine处理，也就是1千万的连接就会创建一千万个goroutine。这就给了这些特殊场景下的优化空间，这也是像gnet和cloudwego/netpoll诞生的原因之一吧。
本质上他们的底层核心都是一样的，都是基于epoll(linux)实现的。
只是对事件发生后，每个库的处理方式会有所不同。
本篇文章主要分析gnet的。至于使用姿势就不发了，gnet有对应的demo库，可以自行体验。
架构 直接引用gnet官网的一张图
gnet采用的是『主从多 Reactors』。也就是一个主线程负责监听端口连接，当一个客户端连接到来时，就把这个连接根据负载均衡算法分配给其中一个sub线程，由对应的sub线程去处理这个连接的读写事件以及管理它的死亡。
下面这张图就更清晰了。
核心结构 我们先解释gnet的一些核心结构。
engine就是程序最上层的结构了。
  ln对应的listener就是服务启动后对应监听端口的监听器。
  lb对应的loadBalancer就是负载均衡器。也就是当客户端连接服务时，负载均衡器会选择一个sub线程，把连接交给此线程处理。
  mainLoop 就是我们的主线程了，对应的结构eventloop。当然我们的sub线程结构也是eventloop。结构相同，不同的是职责。主线程负责的是监听端口发生的客户端连接事件，然后再由负载均衡器把连接分配给一个sub线程。而sub线程负责的是绑定分配给他的连接(不止一个)，且等待自己管理的所有连接后续读写事件，并进行处理。
  接着看eventloop。
 netpoll.Poller:每一个 eventloop都对应一个epoll或者kqueue。 buffer用来作为读消息的缓冲区。 connCoun记录当前eventloop存储的tcp连接数。 udpSockets和connetcions分别管理着这个eventloop下所有的udp socket和tcp连接，注意他们的结构map。这里的int类型存储的就是fd。  对应conn结构，
这里面有几个字段介绍下，
 buffer:存储当前conn对端(client)发送的最新数据，比如发送了三次，那个此时buffer存储的是第三次的数据,代码里有。 inboundBuffer:存储对端发送的且未被用户读取的剩余数据，还是个Ring Buffer。 outboundBuffer:存储还未发送给对端的数据。(比如服务端响应客户端的数据，由于conn fd是不阻塞的，调用write返回不可写的时候，就可以先把数据放到这里)  conn相当于每个连接都会有自己独立的缓存空间。这样做是为了减少集中式管理内存带来的锁问题。使用Ring buffer是为了增加空间的复用性。
整体结构就这些。
核心逻辑 当程序启动时，
会根据用户设置的options明确eventloop循环的数量，也就是有多少个sub线程。再进一步说，在linux环境就是会创建多少个epoll对象。
那么整个程序的epoll对象就是count(sub)+1(main Listener)。
上图就是我说的，会根据设置的数量创建对应的eventloop,把对应的eventloop 注册到负载均衡器中。
当新连接到来时，就可以根据一定的算法(gnet提供了轮询、最少连接以及hash)挑选其中一个eventloop把连接分配给它。
我们先来看主线程，(由于我使用的是mac,所以后面关于IO多路复用，实现部分就是kqueue代码了，当然原理是一样的)
Polling就是等待网络事件到来，传递了一个闭包参数，更确切的说是一个事件到来时的回调函数，从名字可以看出，就是处理新连接的。
至于Polling函数，
逻辑很简单，一个for循环等待事件到来，然后处理事件。
主线程的事件分两种，
一种是正常的fd发生网络连接事件，
一种是通过NOTE_TRIGGER立即激活的事件。
通过NOTE_TRIGGER触发告诉你队列里有task任务，去执行task任务。
如果是正常的网络事件到来，就处理闭包函数，主线程处理的就是上面的accept连接函数。
accept连接逻辑很简单，拿到连接的fd。设置fd非阻塞模式(想想连接是阻塞的会咋么样?),然后根据负载均衡算法选择一个sub 线程，通过register函数把此连接分配给它。
register做了两件事，首先需要把当前连接注册到当前sub 线程的epoll or kqueue 对象中,新增read的flag。</description>
			<content type="html"><![CDATA[<p>距离上次写文章过了一月有余，这段时间着实太躺了。以至于昨晚做了一个噩梦，醒来的时候狠狠的抽了自己两巴掌，不能这么躺了。</p>
<p>上面当然是个笑话。</p>
<h3 id="开篇">开篇</h3>
<p>上一篇我们分析了Go原生网络模型以及部分源码，绝大部分场景下(99%)，使用原生netpoll已经足够了。</p>
<p>但是在一些海量并发连接下，原生netpoll会为每一个连接都开启一个goroutine处理，也就是1千万的连接就会创建一千万个goroutine。这就给了这些特殊场景下的优化空间，这也是像gnet和cloudwego/netpoll诞生的原因之一吧。</p>
<p>本质上他们的底层核心都是一样的，都是基于epoll(linux)实现的。</p>
<p>只是对事件发生后，每个库的处理方式会有所不同。</p>
<p>本篇文章主要分析gnet的。至于使用姿势就不发了，gnet有对应的demo库，可以自行体验。</p>
<h3 id="架构">架构</h3>
<p>直接引用gnet官网的一张图</p>
<p><img src="https://cdn.syst.top/net1.png" alt="截屏2022-06-02 15.03.18"></p>
<p>gnet采用的是『主从多 Reactors』。也就是一个主线程负责监听端口连接，当一个客户端连接到来时，就把这个连接根据负载均衡算法分配给其中一个sub线程，由对应的sub线程去处理这个连接的读写事件以及管理它的死亡。</p>
<p>下面这张图就更清晰了。</p>
<p><img src="https://cdn.syst.top/net2.png" alt="图片来源gnet官网"></p>
<h3 id="核心结构">核心结构</h3>
<p>我们先解释gnet的一些核心结构。</p>
<p><img src="https://cdn.syst.top/net4.png" alt="image-20220602153051260"></p>
<p>engine就是程序最上层的结构了。</p>
<ul>
<li>
<p>ln对应的listener就是服务启动后对应监听端口的监听器。</p>
</li>
<li>
<p>lb对应的loadBalancer就是负载均衡器。也就是当客户端连接服务时，负载均衡器会选择一个sub线程，把连接交给此线程处理。</p>
</li>
<li>
<p>mainLoop 就是我们的主线程了，对应的结构eventloop。当然我们的sub线程结构也是eventloop。结构相同，不同的是职责。主线程负责的是监听端口发生的客户端连接事件，然后再由负载均衡器把连接分配给一个sub线程。而sub线程负责的是绑定分配给他的连接(不止一个)，且等待自己管理的所有连接后续读写事件，并进行处理。</p>
</li>
</ul>
<p>接着看eventloop。</p>
<p><img src="https://cdn.syst.top/net5.png" alt="image-20220602154501439"></p>
<ul>
<li>netpoll.Poller:每一个 eventloop都对应一个epoll或者kqueue。</li>
<li>buffer用来作为读消息的缓冲区。</li>
<li>connCoun记录当前eventloop存储的tcp连接数。</li>
<li>udpSockets和connetcions分别管理着这个eventloop下所有的udp socket和tcp连接，注意他们的结构map。这里的int类型存储的就是fd。</li>
</ul>
<p>对应conn结构，</p>
<p><img src="https://cdn.syst.top/net5-1.png" alt="image-20220608175339906"></p>
<p>这里面有几个字段介绍下，</p>
<ul>
<li>buffer:存储当前conn对端(client)发送的最新数据，比如发送了三次，那个此时buffer存储的是第三次的数据,代码里有。</li>
<li>inboundBuffer:存储对端发送的且未被用户读取的剩余数据，还是个Ring Buffer。</li>
<li>outboundBuffer:存储还未发送给对端的数据。(比如服务端响应客户端的数据，由于conn fd是不阻塞的，调用write返回不可写的时候，就可以先把数据放到这里)</li>
</ul>
<p>conn相当于每个连接都会有自己独立的缓存空间。这样做是为了减少集中式管理内存带来的锁问题。使用Ring buffer是为了增加空间的复用性。</p>
<p>整体结构就这些。</p>
<h3 id="核心逻辑">核心逻辑</h3>
<p>当程序启动时，</p>
<p><img src="https://cdn.syst.top/net3.png" alt="net3"></p>
<p>会根据用户设置的options明确eventloop循环的数量，也就是有多少个sub线程。再进一步说，在linux环境就是会创建多少个epoll对象。</p>
<p>那么整个程序的epoll对象就是count(sub)+1(main Listener)。</p>
<p><img src="https://cdn.syst.top/net6.png" alt="image-20220608164415565"></p>
<p>上图就是我说的，会根据设置的数量创建对应的eventloop,把对应的eventloop 注册到负载均衡器中。</p>
<p>当新连接到来时，就可以根据一定的算法(gnet提供了轮询、最少连接以及hash)挑选其中一个eventloop把连接分配给它。</p>
<p>我们先来看主线程，(由于我使用的是mac,所以后面关于IO多路复用，实现部分就是kqueue代码了，当然原理是一样的)</p>
<p><img src="https://cdn.syst.top/net7.png" alt="image-20220608165350443"></p>
<p>Polling就是等待网络事件到来，传递了一个闭包参数，更确切的说是一个事件到来时的回调函数，从名字可以看出，就是处理新连接的。</p>
<p>至于Polling函数，</p>
<p><img src="https://cdn.syst.top/net8.png" alt="image-20220608170912204"></p>
<p>逻辑很简单，一个for循环等待事件到来，然后处理事件。</p>
<p>主线程的事件分两种，</p>
<p>一种是正常的fd发生网络连接事件，</p>
<p>一种是通过NOTE_TRIGGER立即激活的事件。</p>
<p><img src="https://cdn.syst.top/net9.png" alt="image-20220608171537730"></p>
<p>通过NOTE_TRIGGER触发告诉你队列里有task任务，去执行task任务。</p>
<p>如果是正常的网络事件到来，就处理闭包函数，主线程处理的就是上面的accept连接函数。</p>
<p><img src="https://cdn.syst.top/net10.png" alt="image-20220608172333749"></p>
<p>accept连接逻辑很简单，拿到连接的fd。设置fd非阻塞模式(想想连接是阻塞的会咋么样?),然后根据负载均衡算法选择一个sub 线程，通过register函数把此连接分配给它。</p>
<p><img src="https://cdn.syst.top/net11.png" alt="image-20220608173157607"></p>
<p>register做了两件事，首先需要把当前连接注册到当前sub 线程的epoll or kqueue 对象中,新增read的flag。</p>
<p>接着就是把当前连接放入到connections的map结构中 fd-&gt;conn。</p>
<p>这样当对应的sub线程事件到来时，可以通过事件的fd找到是哪个连接，进行相应的处理。</p>
<p><img src="https://cdn.syst.top/net12.png" alt="image-20220608174647390"></p>
<p>如果是可读事件，</p>
<p><img src="https://cdn.syst.top/net13.png" alt="image-20220608182813931"></p>
<p>到这里分析差不多就结束了。</p>
<h3 id="总结">总结</h3>
<p>在gnet里面，你可以看到，基本上所有的操作都无锁的。</p>
<p>那是因为事件到来时，采取的都是非阻塞的操作，且是串行处理对应的每个fd(conn)。每个conn操作的都是自身持有的缓存空间。同时处理完一轮触发的所有事件才会循环进入下一次等待，在此层面上解决了并发问题。</p>
<p>当然这样用户在使用的时候也需要注意一些问题，比如用户在自定义EventHandler中，如果要异步处理逻辑，就不能像下面这样开一个g然后在里面获取本次数据，</p>
<p><img src="https://cdn.syst.top/net14.png" alt="image-20220608184718192"></p>
<p>而应该先拿到数据，再异步处理。</p>
<p><img src="https://cdn.syst.top/net15.png" alt="image-20220608184937855"></p>
<p>issues上有提到，连接是使用map[int]*conn存储的。gnet本身的场景就是海量并发连接，内存会很大。进而big map存指针会对 GC造成很大的负担，毕竟它不像数组一样，是连续内存空间，易于GC扫描。</p>
<p>还有一点，在处理buffer数据的时候，就像上面看到的，本质上是将buffer数据copy给用户一份，那么就存在大量copy开销,在这一点上，字节的netpoll实现了Nocopy Buffer，改天研究一下。</p>
]]></content>
		</item>
		
		<item>
			<title>Go netpoll大解析</title>
			<link>https://www.syst.top/posts/go/netpoll/</link>
			<pubDate>Thu, 14 Apr 2022 10:23:51 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/netpoll/</guid>
			<description>开篇 之前简单看过一点go原生netpoll，没注意太多细节。最近从头到尾看了一遍，特写篇文章记录下。文章很长，请耐心看完，一定有所收获。
用户空间和内核空间 在linux中，经常能看到两个词语:User space(用户空间)和Kernel space (内核空间)。
简单的说， Kernel space是linux内核运行的空间，User space是用户程序运行的空间。它们之间是相互隔离的。
现代操作系统都是采用虚拟存储器。那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。空间分配如下图所示：
Kernel space可以调用系统的一切资源。User space 不能直接调用系统资源，在 Linux系统中，所有的系统资源管理都是在内核空间中完成的。比如读写磁盘文件、分配回收内存、从网络接口读写数据等等。应用程序无法直接进行这样的操作，但是用户程序可以通过内核提供的接口来完成这样的任务。比如像下面这样，
应用程序要读取磁盘上的一个文件，它可以向内核发起一个 “系统调用” 告诉内核：”我要读取磁盘上的某某文件”。其实就是通过一个特殊的指令让进程从用户态进入到内核态，在内核空间中，CPU 可以执行任何的指令，当然也包括从磁盘上读取数据。具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并且拿到了想要的数据，继续往下执行用户空间执行逻辑。
这样的话，一旦涉及到对I/O的处理，就必然会涉及到在用户态和内核态之间来回切换。
io模型 网上有太多关于I/O模型的文章，看着看着有可能就跑偏了，所以我还是从 &amp;laquo;UNIX 网络编程&amp;raquo; 中总结的5中I/O模型说起吧。
Unix可用的5种I/O模型。
 阻塞I/O 非阻塞I/O I/O复用 信号驱动式I/O(SIGIO) 异步I/O(POSIX的aio_系列函数)  阻塞I/O 阻塞式I/O下，进程调用recvfrom，直到数据到达且被复制到应用程序的缓冲区中或者发生错误才返回，在整个过程进程都是被阻塞的。
非阻塞I/O 从图中可以看出，前三次调用recvfrom中没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用程序缓冲区，于是recvfrom成功返回。
当一个应用程序像这样对一个非阻塞描述符循环调用recvfrom时，我们通常称为轮询(polling)，持续轮询内核，以这种方式查看某个操作是否就绪。
I/O多路复用 有了I/O多路复用(I/O multiplexing)，我们就可以调用 select 或者 poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。
上面这句话难理解是吧，说白了这里指的是，在第一步中，我们只是阻塞在select调用上，直到数据报套接字变为可读，返回可读条件，这里并没有发生I/O事件，所以说这一步，并没有阻塞在真正的I/O系统调用上。
其他两种就不过多介绍了。
还有一点，我们会经常提到同步I/O和异步I/O。
POSIX 把这两种术语定义如下:
 同步I/O操作(synchronous I/O opetation) 导致请求进程被阻塞，直到I/O操作完成。 异步I/O(asynchronous opetation) 不导致请求进程被阻塞。  基于上面的定义，
异步I/O的关键在于第二步的recrfrom是否会阻塞住用户进程，如果不阻塞，那它就是异步I/O。从上面汇总图中可以看出，只有异步I/O满足POSIX中对异步I/O的定义。
Go netpoller Go netpoller 底层就是对I/O多路复用的封装。不同平台对I/O多路复用有不同的实现方式。比如Linux的select、poll和epoll(具体差别不是很明白可以看这篇)。在MacOS则是kqueue,而Windows是基于异步I/O实现的icop&amp;hellip;&amp;hellip;，基于这些背景，Go针对不同的平台调用实现了多版本的netpoller。
下面我们通过一个demo开始讲解。
很简单一个demo，开启一个tcp服务。然后每来一个连接，就启动一个g去处理连接。处理完毕，关闭连接。
而且我们使用的是同步的模式去编写异步的逻辑，一个连接对应一个g处理，极其简单和易于理解。go标准库中的http.server也是这么干的。</description>
			<content type="html"><![CDATA[<h3 id="开篇">开篇</h3>
<p>之前简单看过一点go原生netpoll，没注意太多细节。最近从头到尾看了一遍，特写篇文章记录下。文章很长，请耐心看完，一定有所收获。</p>
<h3 id="用户空间和内核空间">用户空间和内核空间</h3>
<p>在linux中，经常能看到两个词语:User space(用户空间)和Kernel space (内核空间)。</p>
<p>简单的说， Kernel space是linux内核运行的空间，User space是用户程序运行的空间。它们之间是相互隔离的。</p>
<p>现代操作系统都是采用虚拟存储器。那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。空间分配如下图所示：</p>
<p><img src="https://cdn.syst.top/19223008-e9e63cbdacf24562a462656c7985f638.png" alt="19223008-e9e63cbdacf24562a462656c7985f638"></p>
<p>Kernel space可以调用系统的一切资源。User space 不能直接调用系统资源，在 Linux系统中，所有的系统资源管理都是在内核空间中完成的。比如读写磁盘文件、分配回收内存、从网络接口读写数据等等。应用程序无法直接进行这样的操作，但是用户程序可以通过内核提供的接口来完成这样的任务。<img src="https://cdn.syst.top/bg2016120201-2.png" alt="bg2016120201-2"></p>
<p>比如像下面这样，</p>
<p><img src="https://cdn.syst.top/20220414115147.png" alt="截屏2022-04-14 下午11.51.47"></p>
<p>应用程序要读取磁盘上的一个文件，它可以向内核发起一个 “系统调用” 告诉内核：”我要读取磁盘上的某某文件”。其实就是通过一个特殊的指令让进程从用户态进入到内核态，在内核空间中，CPU 可以执行任何的指令，当然也包括从磁盘上读取数据。具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并且拿到了想要的数据，继续往下执行用户空间执行逻辑。</p>
<p>这样的话，一旦涉及到对I/O的处理，就必然会涉及到在用户态和内核态之间来回切换。</p>
<h3 id="io模型">io模型</h3>
<p>网上有太多关于I/O模型的文章，看着看着有可能就跑偏了，所以我还是从 &laquo;UNIX 网络编程&raquo; 中总结的5中I/O模型说起吧。</p>
<p>Unix可用的5种I/O模型。</p>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>I/O复用</li>
<li>信号驱动式I/O(SIGIO)</li>
<li>异步I/O(POSIX的aio_系列函数)</li>
</ul>
<h5 id="阻塞io">阻塞I/O</h5>
<p><img src="https://cdn.syst.top/20220409102931.png" alt="截屏2022-04-09 上午10.29.31"></p>
<p>阻塞式I/O下，进程调用recvfrom，直到数据到达且被复制到应用程序的缓冲区中或者发生错误才返回，在整个过程进程都是被阻塞的。</p>
<h5 id="非阻塞io">非阻塞I/O</h5>
<p><img src="https://cdn.syst.top/20220409103942.png" alt="截屏2022-04-09 上午10.39.42"></p>
<p>从图中可以看出，前三次调用recvfrom中没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用程序缓冲区，于是recvfrom成功返回。</p>
<p>当一个应用程序像这样对一个非阻塞描述符循环调用recvfrom时，我们通常称为轮询(polling)，持续轮询内核，以这种方式查看某个操作是否就绪。</p>
<h5 id="io多路复用">I/O多路复用</h5>
<p><img src="https://cdn.syst.top/20220409103948.png" alt="截屏2022-04-09 上午10.39.48"></p>
<p>有了I/O多路复用(I/O multiplexing)，我们就可以调用 select 或者 poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。</p>
<p>上面这句话难理解是吧，说白了这里指的是，在第一步中，我们只是阻塞在select调用上，直到数据报套接字变为可读，返回可读条件，这里并没有发生I/O事件，所以说这一步，并没有阻塞在真正的I/O系统调用上。</p>
<p>其他两种就不过多介绍了。</p>
<p>还有一点，我们会经常提到同步I/O和异步I/O。</p>
<p>POSIX 把这两种术语定义如下:</p>
<ul>
<li>同步I/O操作(synchronous I/O opetation) 导致请求进程被阻塞，直到I/O操作完成。</li>
<li>异步I/O(asynchronous opetation) 不导致请求进程被阻塞。</li>
</ul>
<p>基于上面的定义，</p>
<p><img src="https://cdn.syst.top/20220409110643.png" alt="截屏2022-04-09 上午11.06.43"></p>
<p>异步I/O的关键在于第二步的recrfrom是否会阻塞住用户进程，如果不阻塞，那它就是异步I/O。从上面汇总图中可以看出，只有异步I/O满足POSIX中对异步I/O的定义。</p>
<h3 id="go-netpoller">Go netpoller</h3>
<p>Go netpoller 底层就是对I/O多路复用的封装。不同平台对I/O多路复用有不同的实现方式。比如Linux的select、poll和epoll(具体差别不是很明白可以看这篇)。在MacOS则是kqueue,而Windows是基于异步I/O实现的icop&hellip;&hellip;，基于这些背景，Go针对不同的平台调用实现了多版本的netpoller。</p>
<p><img src="https://cdn.syst.top/2022040983928.png" alt="截屏2022-04-09 下午8.39.28"></p>
<p>下面我们通过一个demo开始讲解。</p>
<p><img src="https://cdn.syst.top/demo.png" alt="demo"></p>
<p>很简单一个demo，开启一个tcp服务。然后每来一个连接，就启动一个g去处理连接。处理完毕，关闭连接。</p>
<p>而且我们使用的是同步的模式去编写异步的逻辑，一个连接对应一个g处理，极其简单和易于理解。go标准库中的http.server也是这么干的。</p>
<p><img src="https://cdn.syst.top/carbon14.png" alt="carbon (14)"></p>
<p>针对上面的tcp服务demo，我们需要关注这段代码底层都发生了什么。</p>
<p>上面代码中主要涉及底层的一些结构。</p>
<p><img src="https://cdn.syst.top/2022040982429.png" alt="截屏2022-04-09 下午8.24.29"></p>
<p>先简单解释一波。</p>
<ul>
<li>TCPListener:我们开启的是一个TCP服务，那当然就是TCP服务的网络监听器。</li>
<li>netFD:网络描述符。Go中所有的网络操作都是以netFD实现的，它和底层FD做绑定。</li>
<li>FD:文件描述符。net和os包把这个类型作为一个网络连接或者操作系统文件。其中里面一个字段Sysfd就是具体文件描述符值。</li>
<li>pollDesc:I/O轮询器。说白了它就是底层事件驱动的封装。其中的runtimeCtx是一个指针类型，具体指向runtime/netpoll 中的pollDesc.</li>
</ul>
<p>当然图上面结构字段都是阉割版的，但是不影响我们这篇文章。</p>
<p>还有一个问题，为什么结构上需要一层一层嵌入呢？</p>
<p>我的理解是每下一层都是更加抽象的一层。它是可以作为上一层具体的一种应用体现。</p>
<p>是不是跟没说一样？哈哈。</p>
<p>举例，比如这里的netFD表示网络描述符。</p>
<p>它的上一层可以是用于TCP的网络监听器TCPListener，那么对应的接口我们能想到的有两个Accept以及close。</p>
<p>对于Accept 动作，一定是返回一个连接类型 Conn ，针对这个连接，它本身也存在一个自己的netFD，那么可想而知一定会有 Write和Read两个操作。</p>
<p>而所有的网络操作都是以netFD实现的。这样，netFD在这里就有两种不用的上层应用体现了。</p>
<p>好了,我们需要搞清楚几件事：</p>
<ul>
<li>一般我们用其他语言写一个tcp服务，必然会写这几步：socket-&gt;bind-&gt;listen，但是Go就一个Listen，那就意味着底层包装了这些操作。它是在哪一步完成的？</li>
<li>Go是在什么时候初始化netpoll的，比如linux下初始化epoll实例。</li>
<li>当对应fd没有可读或者可写的IO事件而对应被挂起的g，是如何知道fd上的I/O事件已ready，又是如何唤醒对应的g的？</li>
</ul>
<h3 id="listen解析">Listen解析</h3>
<p>带着这些问题，我们接着看流程。</p>
<p><img src="https://cdn.syst.top/Xnip2022-04-11_22-02-31.jpg" alt="Xnip2022-04-11_22-02-31"></p>
<p>上图已经把当你调用Listen操作的完整流程全部罗列出来了。就像我上面列出的结构关系一样，从结构层次来说，每调用下一层，都是为了创建并获取下一层的依赖，因为内部的高度抽象与封装，才使得使用者往往只需调用极少数简单的API接口。</p>
<p>现在我们已经知道事例代码涉及到的结构以及对应流程了。</p>
<p>在传统印象中，创建一个网络服务。需要经过:创建一个socket、bind 、listen这基本的三大步。</p>
<p>前面我们说过，Go中所有的网络操作都是以netFD实现的。go也是在这一层封装这三大步的。所以我们直接从netFD逻辑开始说。</p>
<p>上图是在调用socket函数这一步返回的netFD，可想而之核心逻辑都在这里面。</p>
<p><img src="https://cdn.syst.top/2022041294936.png" alt="截屏2022-04-12 下午9.49.36"></p>
<p>我们可以把这个函数核心点看成三步。</p>
<ul>
<li>调用sysSocket函数创建一个socket，返回一个文件描述符(file descriptor)，简称fd下文。</li>
<li>通过sysSocket返回的fd，调用newFD函数创建一个新的netFD。</li>
<li>调用netFD自身的方法listenStream函数，做初始化动作，具体详情下面再说。</li>
</ul>
<p>在sysSocket函数中，首先会通过socketFunc来创建一个socket，通过层层查看，最终是通过system call来完成这一步。当获取到对应fd时，会通过syscall.SetNonblock函数把当前这个fd设置成非阻塞模式，这样当这个Listener调用accept函数就不会被阻塞了。</p>
<p><img src="https://cdn.syst.top/Xnip2022-04-12_21-38-10.jpg" alt="Xnip2022-04-12_21-38-10"></p>
<p>第二步，通过第一步创建socket拿到的fd，创建一个新的netFD。这段代码没啥好解释的。</p>
<p>第三步，也就是最核心的一步，调用netFD自身的listenStream方法。</p>
<p><img src="https://cdn.syst.top/20220412101207.png" alt="截屏2022-04-12 下午10.12.07"></p>
<p>listenStream里面也有核心的三步:</p>
<ul>
<li>通过syscall.Bind 完成绑定</li>
<li>通过listenFunc 完成监听</li>
<li>调用netFD自身init完成初始化操作:netFD.init -&gt;poll.FD.init-&gt;FD.pollDesc.init</li>
</ul>
<p>我们主要看fd.init逻辑。</p>
<p><img src="https://cdn.syst.top/Xnip2022-04-12_22-32-11.jpg" alt="Xnip2022-04-12_22-32-11"></p>
<p>最终是调用的pollDesc的init函数。这个函数有重要的两步。</p>
<ul>
<li>runtime_pollServerInit：主要会根据不同的平台去调用对应平台的netpollInit函数来创建I/O多路复用的实例。比如linux下创建epoll。</li>
<li>runtime_pollOpen(uintptr(fd.Sysfd))：主要将已经创建完的Listener fd注册到上述实例当中，比如将fd注册到epoll中，底层通过syscall调用epoll_ctl。</li>
</ul>
<p>更具体的流程，</p>
<p>首先serviceInit.Do 保证当中的runtime_pollServerInit只会初始化一次。这很好理解，类似epoll实例全局初始化一次即可。</p>
<p>接着我们看下runtime_pollServerInit函数，</p>
<p><img src="https://cdn.syst.top/20220412104034.png" alt="截屏2022-04-12 下午10.40.34"></p>
<p>这是咋回事，和我们平常看过的函数长的不太一样，执行体呢？</p>
<p>其实这个函数是通过 <strong>go:linkname</strong>连接到具体实现的函数poll_runtime_pollServerInit。找起来也很简单，</p>
<p><img src="https://cdn.syst.top/20220412104257.png" alt="截屏2022-04-12 下午10.42.57"></p>
<p>看到poll_runtime_pollServerInit()上面的 <strong>//go:linkname xxx</strong> 了吗？不了解的可以看看Go官方文档`go:linkname。</p>
<p>所以最终runtime_pollServerInit调用的是，</p>
<p><img src="https://cdn.syst.top/20220412104719.png" alt="截屏2022-04-12 下午10.47.19"></p>
<p>通过调用poll_runtime_pollServerInit-&gt;netpollGenericInit，netpollGenericInit里调用netpollinit函数完成初始化。</p>
<p>注意。这里的netpollinit，是基于当前系统来调用对应系统的netpollinit函数的。</p>
<p>什么意思？</p>
<p>文章开始有提到Go底层网络模型是基于I/O多路复用。</p>
<p>不同平台对I/O多路复用有不同的实现方式。比如Linux的epoll，MacOS的kqueue,而Windows的icop。</p>
<p>所以对应，如果你当前是Linux，那么最终调用的是<code>src/runtime/netpoll_epoll.go</code>下的 netpollinit函数，然后会创建一个epoll实例，并把值赋给epfd，作为整个runtime中唯一的event-loop使用。</p>
<p><img src="https://cdn.syst.top/2022041393222.png" alt="截屏2022-04-13 下午9.32.22"></p>
<p>其他的，比如MacOS下的kqueue,也存在netpollinit函数。</p>
<p><img src="https://cdn.syst.top/20220412110331.png" alt="截屏2022-04-12 下午11.03.31"></p>
<p>以及Windows下的icop。</p>
<p><img src="https://cdn.syst.top/20220412110441.png" alt="截屏2022-04-12 下午11.04.41"></p>
<p>我们回到pollDesc.init 操作，</p>
<!-- raw HTML omitted -->
<p>完成第一步初始化操作后，第二步就是调用runtime_pollOpen。</p>
<p>老套路通过**//go:linkname**找到对应的实现，实际上是调用的poll_runtime_pollOpen函数，这个函数里面再调用netpollopen函数，netpollopen函数和上面的netpollinit函数一样，不同平台都有它的实现。linux平台下，</p>
<p><img src="https://cdn.syst.top/20220413945402.png" alt="截屏2022-04-13 下午9.45.40 2"></p>
<p>netpollopen函数，首先会通过指针把pollDesc保存到epollevent的一个字节数组data里。</p>
<p>然后会把传递进来的fd(刚才初始化完成的那个Listener监听器)注册到epoll当中，且通过指定 _EPOLLET将epoll设置为边缘触发(Edge Triggered)模式。如果让我用一句话来说明epoll水平触发和边缘触发的区别，那就是,</p>
<p>水平触发下epoll_wait在文件描述符没有读写完会一直触发，而边缘触发只在是在变成可读写时触发一次。</p>
<p>到这里整个Listen 动作也就结束了，然后层层返回。最终到业务返回的是一个 Listener，按照本篇的例子，本质上还是一个TCPListener。</p>
<h3 id="accept解析">Accept解析</h3>
<p>接着当我们调用listen.Accept的时候，</p>
<p><img src="https://cdn.syst.top/Xnip2022-04-13_22-50-09.jpg" alt="Xnip2022-04-13_22-50-09"></p>
<p>最终netFD的accept函数。netFD中通过调用fd.pfd(实际上是FD)的Accept函数获取到socket fd。通过这个fd创建新的netFD表示这是一个新连接的fd。并且会和Listen时一样调用netFD.init做初始化，因为当前epoll已经初始化一次了，所以这次只是把这个新连接的fd也加入到epoll事件队列当中，用于监听conn fd的读写I/O事件。</p>
<p>具体我们看FD.Accept是咋么执行的。</p>
<p><img src="https://cdn.syst.top/Xnip2022-04-13_22-57-56.jpg" alt="Xnip2022-04-13_22-57-56"></p>
<p>首先是一个死循环for，死循环里调用了accept函数，本质上通过systcall调用系统accept接收新连接。当有新连接时，最终返回一个文件描述符fd。当accept获取到一个fd，会调用systcall.SetNonblock把这个fd设置成非阻塞的I/O。然后返回这个连接fd。</p>
<p>因为我们在Listen的时候已经把对应的Listener fd设置成非阻塞I/O了。所以调用accept这一步是不会阻塞的。只是下面会进行判断，根据判断 err ==syscall.EAGAIN 来调用fd.pd.waitRead阻塞住用户程序。</p>
<p>直到I/O事件ready，被阻塞在fd.pd.waitRead的代码会继续执行continue，重新一轮的accept, 此时对应fd上的 I/O已然ready，最终就返回一个conn类型的fd。</p>
<p>我刚才说的调用fd.pd.waitRead会被阻塞，直到对应I/O事件ready。我们来看它具体逻辑，</p>
<p><img src="https://cdn.syst.top/carbon15.png" alt="carbon (15)"></p>
<p>最终到runtime_pollWait函数，老套路了，我们找到具体的实现函数。</p>
<p><img src="https://cdn.syst.top/carbon5.png" alt="carbon (3)"></p>
<p>poll_runtime_pollWait 里的for循环就是为了等待对应的I/O ready才会返回，否则的话一直调用netpollblock函数。pollDesc结构我们之前提到，它就是底层事件驱动的封装。其中有两个重要字段: rg和wg，都是指针类型，实际这两个字段存储的就是Go底层的g，更具体点是等待i/O ready的g。</p>
<p>比如当创建完一个Listener，调用Accept开始接收客户端连接。如果没有对应的请求，那么最终会把g放入到pollDesc的rg。</p>
<p>如果是一个conn类型的fd等待可写I/O，那么会把g放入到pollDesc的wg中。</p>
<p>具体就是根据mode来判断当前是什么类型的等待事件。</p>
<p>netpollblock里也有一个for循环，如果已经ready了，那么直接返回给上一层就行了。否则的话，设置gpp为等待状态pdWait。</p>
<p>这里还有一点atomic.Loaduintptr(gpp)，这是为了防止异常情况下出现死循环问题。比如如果gpp的值不是pdReady也不是0，那么意味着值是pdWait，那就成了double wait，必然导致死循环。</p>
<p>如果gpp未ready且成功设置成pdWait，正常情况下，最终会调用gopark，会挂起g且把对应的g放入到pollDesc 的wg|rg 当中。</p>
<p>进入gopark。</p>
<p><img src="https://cdn.syst.top/carbon6.png" alt="carbon (6)"></p>
<p>这一块代码不是很难懂，基本的字段打了备注，核心还是要看park_m这个函数。</p>
<p><img src="https://cdn.syst.top/carbon9.png" alt="carbon (8)"></p>
<p>park_m函数中，首先会通过CAS并发安全的修改g的状态。然后调用dropg解绑g和m的关系，也就是m把当前运行的g置空，g把当前绑定的m置空。</p>
<p>后面的代码是根据当前场景来解释的。我们知道此时m的waitunlockf 其实就是netpollblockcommit。</p>
<p><img src="https://cdn.syst.top/carbon7.png" alt="carbon (7)"></p>
<p>netpollblockcommit会把当前已经是_Gwaiting状态下的g赋值给gpp。如果赋值成功，netpollWaiters会加1。这个全局变量表示当前等待I/O事件ready的g数量，调度器再进行调度的时候可以根据此变量判断是否存在等待I/O事件的g。</p>
<p>如果此时当前gpp下的fd的I/O已经ready。那么gpp的状态必然已不是pdWait，赋值失败。返回false。</p>
<p>回到park_m，</p>
<p>如果netpollblockcommit返回true，那么直接触发新一轮的调度。</p>
<p>如果netpollblockcommit返回false，意味着当前g已经不需要被挂起了，所以需要把状态调整为_Grunnable，然后安排g还是在当前m上执行。</p>
<p>当I/O事件ready，会一层层返回，获取到新的socket fd，创建conn类型的netFD，初始化netFD(其实就是把这个conn类型的fd也加入epoll事件队列，用于监听)，最终最上游会获取到一个Conn类型的网络连接，就可以基于这个连接做Read、Write等操作了。</p>
<p><img src="https://cdn.syst.top/carbon10.png" alt="carbon (10)"></p>
<h3 id="readwrite-解析">Read/Write 解析</h3>
<p>后续的Conn.Read 和 Conn.Write 原理和Accept 类似。</p>
<p><img src="https://cdn.syst.top/carbon11.png" alt="carbon (11)"></p>
<p>给出了Write操作，可以看出核心部分和accept操作时一样的。对于Read操作，就不再重复了。</p>
<p>从上面的分析中我们已经知道，Go的netpoller底层通过对epoll|kqueue|iocp的封装，使用同步的编程手法达到异步执行的效果，无论是一个Listener还是一个Conn，它的核心都是netFD，netFD又和底层的PollDesc结构绑定，当读写出现EAGAIN错误时，会通过调用gopark把当前g给park住，同时会将当前的g存储到对应netFD的PollDesc的wg|rg当中， 直到这个netFD再次发生对应的读写事件，才会重新把当前g放入到调度系统进行调度。</p>
<p>还有最后一个问题，我们咋么知道哪些FD发生读写事件了？</p>
<h3 id="io已就绪">I/O已就绪</h3>
<p>答案就是netpoll()函数。</p>
<p><img src="https://cdn.syst.top/carbon12.png" alt="carbon (12)"></p>
<p>此函数会调用epollwait函数，本质上就是Linux中epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)。</p>
<p>在之前调用epoll_ctl，注册fd对应的I/O事件到epoll实例当中。这里的epoll_wait实际上会阻塞监听epoll实例上所有fd的I/O事件，通过传入的第二个参数(用户内存地址events)。</p>
<p>当有对应的I/O事件到来时，内核就会把发生事件对应的fd复制到这块用户内存地址(events)。解除阻塞，然后我们遍历这个events，去获取到对应的事件类型、pollDesc，再通过调用netpollready函数获取到pollDesc对应被gopark的g，最终把这些g加入到一个链表当中，返回。</p>
<p>也就是说只要调用这个函数，我们就能获取到之前因为I/O未ready而被gopark挂起，现在I/O已ready的g链表了。</p>
<p>我们可以找到四个调用处，如下，</p>
<ul>
<li>startTheWorldWithSema</li>
<li>findrunnable</li>
<li>pollWork</li>
<li>sysmon</li>
</ul>
<p>这和go的调度有关，当然这不是本章的内容。当这四种方法调用netpoll函数得到一个可运行的g链表时，都会调用同一个函数injectglist。这个函数本质上就是把链表中所有g的状态从_Gwaiting-&gt;_Grunnable。然后按照策略，把这些g推送到本地处理器p或者全家运行队列中等待被调度器执行。</p>
<p><img src="https://cdn.syst.top/carbon13.png" alt="carbon (13)"></p>
<p>到这里，整个流程就已经剖析完毕。不能再写了。</p>
<h3 id="最后">最后</h3>
<p>Go netpoller通过在底层对epoll/kqueue/iocp这些不同平台下对I/O多路复用实现的封装，加上自带的goroutine(上文我一直用g表达)，从而实现了使用同步编程模式达到异步执行的效果。 代码很长，涉及到的模块也很多，整体看完代码还是非常爽的。</p>
<p>另外早有人提出，由于一个连接对应一个goroutine，瞬时并发场景下，大量的goroutine会被不断创建。且原生netpoller无法提供足够的性能和控制力，如无法感知连接状态、连接数量多导致利用率低、无法控制协程数量等。针对这些问题，可以参考下gnet以及 KiteX 这两个项目的网络模型。</p>
<h4 id="参考资料">参考资料</h4>
<ul>
<li><a href="http://man7.org/linux/man-pages/man7/epoll.7.html">http://man7.org/linux/man-pages/man7/epoll.7.html</a></li>
<li>&laquo;UNIX网络编程:卷1&raquo;</li>
<li><a href="https://github.com/panjf2000/gnet">https://github.com/panjf2000/gnet</a></li>
<li><a href="https://strikefreedom.top/go-netpoll-io-multiplexing-reactor">https://strikefreedom.top/go-netpoll-io-multiplexing-reactor</a></li>
<li><a href="https://mp.weixin.qq.com/s/wSaJYg-HqnYY4SdLA2Zzaw">https://mp.weixin.qq.com/s/wSaJYg-HqnYY4SdLA2Zzaw</a></li>
<li><a href="https://ninokop.github.io/2018/02/18/go-net/">https://ninokop.github.io/2018/02/18/go-net/</a></li>
<li><a href="https://github.com/cloudwego/kitex">https://github.com/cloudwego/kitex</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>一个用go实现的有限状态机 </title>
			<link>https://www.syst.top/posts/go/easyfsm/</link>
			<pubDate>Sun, 06 Mar 2022 17:37:22 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/easyfsm/</guid>
			<description>easyfsm 之前看过新亮老哥的go-fsm-order，感觉还不错。最近在迁移项目的时候，发现有多处业务存在一些状态的流转，所以就基于go-fsm-order做了重改，让它可以在不同的业务场景下使用。
为什么不使用looplab/fsm，star挺多的啊。
不是特别喜欢，每次实例化fsm都需要重新传递对应events(虽然我们可以统一封装)，我更期望在项目启动时把此项目涉及到不同业务状态机流转注册到fsm，对应:不同业务-&amp;gt;[状态]-&amp;gt;[事件]-&amp;gt;处理事件主体(包含handler、params、hooks、observers等)。
当你开始进行状态流转时，只需要
fsm:=NewFsm(&amp;#34;业务名称&amp;#34;,&amp;#34;当前状态&amp;#34;) currentState,err:=fsm.Call(&amp;#34;事件名称&amp;#34;,&amp;#34;对应事件所需参数可选项&amp;#34;) 为什么需要区分业务？
因为绝大多数业务的状态值都是从数据库中获取的，比如订单表的订单状态，商品表中的商品状态，有可能值是相同的。
同一个业务同一属性对应状态值表达单一，不同业务下属性状态可能会出现值相同，但所表达的含义是不同的。
整体设计:
简单解释一下：
 业务:比如有商品状态业务、订单状态业务&amp;hellip;.. 状态：订单待付款、待发货&amp;hellip;. 事件：对应状态仅可达事件集合。比如待付款状态的可达事件仅有:支付事件和取消事件(取决于自己的业务) 执行事件主体：执行自定义的事件函数,如果有需要，还可以自定义执行事件前后hook，事件订阅者(比如支付事件发生后，异步通知用户等)  使用姿势 go get -u github.com/wuqinqiang/easyfsm 首先自定义业务、状态、事件。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/wuqinqiang/easyfsm&amp;#34; ) var ( // 业务 	businessName easyfsm.BusinessName = &amp;#34;order&amp;#34; // 对应状态 	initState easyfsm.State = 1 // 初始化 	paidState easyfsm.State = 2 // 已付款 	canceled easyfsm.State = 3 // 已取消  //对应事件 	paymentOrderEvent easyfsm.EventName = &amp;#34;paymentOrderEvent&amp;#34; cancelOrderEvent easyfsm.</description>
			<content type="html"><![CDATA[<h3 id="easyfsm">easyfsm</h3>
<p>之前看过新亮老哥的go-fsm-order，感觉还不错。最近在迁移项目的时候，发现有多处业务存在一些状态的流转，所以就基于go-fsm-order做了重改，让它可以在不同的业务场景下使用。</p>
<p>为什么不使用looplab/fsm，star挺多的啊。</p>
<p>不是特别喜欢，每次实例化fsm都需要重新传递对应events(虽然我们可以统一封装)，我更期望在项目启动时把此项目涉及到不同业务状态机流转注册到fsm，对应:不同业务-&gt;[状态]-&gt;[事件]-&gt;处理事件主体(包含handler、params、hooks、observers等)。</p>
<p>当你开始进行状态流转时，只需要</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">fsm</span><span class="o">:=</span><span class="nf">NewFsm</span><span class="p">(</span><span class="s">&#34;业务名称&#34;</span><span class="p">,</span><span class="s">&#34;当前状态&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">currentState</span><span class="p">,</span><span class="nx">err</span><span class="o">:=</span><span class="nx">fsm</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;事件名称&#34;</span><span class="p">,</span><span class="s">&#34;对应事件所需参数可选项&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>为什么需要区分业务？</p>
<p>因为绝大多数业务的状态值都是从数据库中获取的，比如订单表的订单状态，商品表中的商品状态，有可能值是相同的。</p>
<p>同一个业务同一属性对应状态值表达单一，不同业务下属性状态可能会出现值相同，但所表达的含义是不同的。</p>
<p>整体设计:</p>
<p><img src="https://cdn.syst.top/easyfsm.png" alt="fsm"></p>
<p>简单解释一下：</p>
<ul>
<li>业务:比如有商品状态业务、订单状态业务&hellip;..</li>
<li>状态：订单待付款、待发货&hellip;.</li>
<li>事件：对应状态仅可达事件集合。比如待付款状态的可达事件仅有:支付事件和取消事件(取决于自己的业务)</li>
<li>执行事件主体：执行自定义的事件函数,如果有需要，还可以自定义执行事件前后hook，事件订阅者(比如支付事件发生后，异步通知用户等)</li>
</ul>
<h3 id="使用姿势">使用姿势</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">go</span> <span class="nx">get</span> <span class="o">-</span><span class="nx">u</span>  <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">wuqinqiang</span><span class="o">/</span><span class="nx">easyfsm</span>
</span></span></code></pre></div><p>首先自定义业务、状态、事件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/easyfsm&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 业务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">businessName</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">BusinessName</span> <span class="p">=</span> <span class="s">&#34;order&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 对应状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">initState</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">paidState</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// 已付款
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">canceled</span>  <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="mi">3</span> <span class="c1">// 已取消
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">//对应事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">paymentOrderEvent</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">EventName</span> <span class="p">=</span> <span class="s">&#34;paymentOrderEvent&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cancelOrderEvent</span>  <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">EventName</span> <span class="p">=</span> <span class="s">&#34;cancelOrderEvent&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>自定义事件主体，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 订单业务所需参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">orderParam</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">OrderNo</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// 支付订单事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">entity</span> <span class="o">:=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewEventEntity</span><span class="p">(</span><span class="nx">paymentOrderEvent</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kd">func</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">)</span> <span class="p">(</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">param</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="nx">orderParam</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;param err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;param:%+v\n&#34;</span><span class="p">,</span> <span class="nx">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 处理核心业务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="nx">paidState</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 取消订单事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cancelEntity</span> <span class="o">:=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewEventEntity</span><span class="p">(</span><span class="nx">cancelOrderEvent</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kd">func</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">)</span> <span class="p">(</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 处理核心业务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">param</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="nx">orderParam</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;param err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;param:%+v\n&#34;</span><span class="p">,</span> <span class="nx">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">canceled</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  
</span></span></code></pre></div><p>注册到easyfsm。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="c1">// 注册到fsm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">easyfsm</span><span class="p">.</span><span class="nf">RegisterStateMachine</span><span class="p">(</span><span class="nx">businessName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">initState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">entity</span><span class="p">,</span> <span class="nx">cancelEntity</span><span class="p">)</span>
</span></span></code></pre></div><p>开始使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">  <span class="c1">// 正常操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第一步根据业务，以及当前状态生成fsm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fsm</span> <span class="o">:=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewFSM</span><span class="p">(</span><span class="nx">businessName</span><span class="p">,</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 第二步 调用具体事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">currentState</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fsm</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nx">cancelOrderEvent</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">easyfsm</span><span class="p">.</span><span class="nf">WithData</span><span class="p">(</span><span class="nx">orderParam</span><span class="p">{</span><span class="nx">OrderNo</span><span class="p">:</span> <span class="s">&#34;wuqinqiang050@gmail.com&#34;</span><span class="p">}))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[Success]call cancelOrderEvent err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[Success]call cancelOrderEvent state:%v\n&#34;</span><span class="p">,</span> <span class="nx">currentState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="c1">// 结束
</span></span></span></code></pre></div><p>示例代码如下，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/easyfsm&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 业务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">businessName</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">BusinessName</span> <span class="p">=</span> <span class="s">&#34;order&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 对应状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">initState</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">paidState</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// 已付款
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">canceled</span>  <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="mi">3</span> <span class="c1">// 已取消
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">//对应事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">paymentOrderEventName</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">EventName</span> <span class="p">=</span> <span class="s">&#34;paymentOrderEventName&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cancelOrderEventName</span>  <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">EventName</span> <span class="p">=</span> <span class="s">&#34;cancelOrderEventName&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">orderParam</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">OrderNo</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 支付订单事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">entity</span> <span class="o">:=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewEventEntity</span><span class="p">(</span><span class="nx">paymentOrderEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kd">func</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">)</span> <span class="p">(</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">param</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="nx">orderParam</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;param err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;param:%+v\n&#34;</span><span class="p">,</span> <span class="nx">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 处理核心业务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="nx">paidState</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 取消订单事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cancelEntity</span> <span class="o">:=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewEventEntity</span><span class="p">(</span><span class="nx">cancelOrderEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kd">func</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">)</span> <span class="p">(</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 处理核心业务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">param</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="nx">orderParam</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;param err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;param:%+v\n&#34;</span><span class="p">,</span> <span class="nx">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">canceled</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 注册订单状态机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">easyfsm</span><span class="p">.</span><span class="nf">RegisterStateMachine</span><span class="p">(</span><span class="nx">businessName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">initState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">entity</span><span class="p">,</span> <span class="nx">cancelEntity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 正常操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 第一步根据业务，以及当前状态生成fsm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fsm</span> <span class="o">:=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewFSM</span><span class="p">(</span><span class="nx">businessName</span><span class="p">,</span> <span class="nx">initState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 第二步 调用具体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">currentState</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fsm</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nx">cancelOrderEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">easyfsm</span><span class="p">.</span><span class="nf">WithData</span><span class="p">(</span><span class="nx">orderParam</span><span class="p">{</span><span class="nx">OrderNo</span><span class="p">:</span> <span class="s">&#34;wuqinqiang050@gmail.com&#34;</span><span class="p">}))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[Success]call cancelOrderEventName err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[Success]call cancelOrderEventName state:%v\n&#34;</span><span class="p">,</span> <span class="nx">currentState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//异常情况1，没有定义goods业务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fsm</span> <span class="p">=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewFSM</span><span class="p">(</span><span class="s">&#34;goods&#34;</span><span class="p">,</span> <span class="nx">paidState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">currentState</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fsm</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nx">cancelOrderEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">easyfsm</span><span class="p">.</span><span class="nf">WithData</span><span class="p">(</span><span class="nx">orderParam</span><span class="p">{</span><span class="nx">OrderNo</span><span class="p">:</span> <span class="s">&#34;wuqinqiang050@gmail.com&#34;</span><span class="p">}))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[UnKnowBusiness]faild :%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[UnKnowBusiness]faild state:%v\n&#34;</span><span class="p">,</span> <span class="nx">currentState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//异常情况1,没有定义状态:2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fsm</span> <span class="p">=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewFSM</span><span class="p">(</span><span class="nx">businessName</span><span class="p">,</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">currentState</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fsm</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nx">cancelOrderEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">easyfsm</span><span class="p">.</span><span class="nf">WithData</span><span class="p">(</span><span class="nx">orderParam</span><span class="p">{</span><span class="nx">OrderNo</span><span class="p">:</span> <span class="s">&#34;wuqinqiang050@gmail.com&#34;</span><span class="p">}))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[UnKnowState]faild :%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[UnKnowState]faild state:%v\n&#34;</span><span class="p">,</span> <span class="nx">currentState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//异常情况2:没有定义状态1对应的发货事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fsm</span> <span class="p">=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewFSM</span><span class="p">(</span><span class="nx">businessName</span><span class="p">,</span> <span class="nx">initState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">currentState</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fsm</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;shippingEvent&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">easyfsm</span><span class="p">.</span><span class="nf">WithData</span><span class="p">(</span><span class="nx">orderParam</span><span class="p">{</span><span class="nx">OrderNo</span><span class="p">:</span> <span class="s">&#34;wuqinqiang050@gmail.com&#34;</span><span class="p">}))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[UnKnowEvent]faild :%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[UnKnowEvent]faild state:%v\n&#34;</span><span class="p">,</span> <span class="nx">currentState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="hook">Hook</h3>
<p>如果想在处理事件函数的前后执行一些hook，或者在事件执行完毕，异步执行一些其他业务，easyfsm定义了这两个接口，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">EventObserver</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Receive</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">Param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">EventHook</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Before</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">Param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">After</span><span class="p">(</span><span class="nx">opt</span> <span class="nx">Param</span><span class="p">,</span> <span class="nx">state</span> <span class="nx">State</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>我们可以实现这两个接口，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">NotifyExample</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">HookExample</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">HookExample</span><span class="p">)</span> <span class="nf">Before</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;事件执行前&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">HookExample</span><span class="p">)</span> <span class="nf">After</span><span class="p">(</span><span class="nx">opt</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">,</span> <span class="nx">state</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;事件执行后&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="nx">NotifyExample</span><span class="p">)</span> <span class="nf">Receive</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;接收到事件变动,发送消息&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>完整代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/easyfsm&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 业务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">businessName</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">BusinessName</span> <span class="p">=</span> <span class="s">&#34;order&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 对应状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">initState</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">paidState</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// 已付款
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">canceled</span>  <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="mi">3</span> <span class="c1">// 已取消
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">//对应事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">paymentOrderEventName</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">EventName</span> <span class="p">=</span> <span class="s">&#34;paymentOrderEventName&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cancelOrderEventName</span>  <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">EventName</span> <span class="p">=</span> <span class="s">&#34;cancelOrderEventName&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">orderParam</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">OrderNo</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">EventObserver</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">NotifyExample</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">EventHook</span>     <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">HookExample</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">NotifyExample</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">HookExample</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">HookExample</span><span class="p">)</span> <span class="nf">Before</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;事件执行前&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">HookExample</span><span class="p">)</span> <span class="nf">After</span><span class="p">(</span><span class="nx">opt</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">,</span> <span class="nx">state</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;事件执行后&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="nx">NotifyExample</span><span class="p">)</span> <span class="nf">Receive</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;接收到事件变动,发送消息&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 支付订单事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">entity</span> <span class="o">:=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewEventEntity</span><span class="p">(</span><span class="nx">paymentOrderEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kd">func</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">)</span> <span class="p">(</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">param</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="nx">orderParam</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;param err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;param:%+v\n&#34;</span><span class="p">,</span> <span class="nx">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 处理核心业务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="nx">paidState</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">WithHook</span><span class="p">(</span><span class="nx">HookExample</span><span class="p">{}),</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">WithObservers</span><span class="p">(</span><span class="nx">NotifyExample</span><span class="p">{}))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 取消订单事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cancelEntity</span> <span class="o">:=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewEventEntity</span><span class="p">(</span><span class="nx">cancelOrderEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kd">func</span><span class="p">(</span><span class="nx">opt</span> <span class="o">*</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">Param</span><span class="p">)</span> <span class="p">(</span><span class="nx">easyfsm</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 处理核心业务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">param</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="nx">orderParam</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;param err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;param:%+v\n&#34;</span><span class="p">,</span> <span class="nx">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">canceled</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">WithHook</span><span class="p">(</span><span class="nx">HookExample</span><span class="p">{}))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 注册订单状态机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">easyfsm</span><span class="p">.</span><span class="nf">RegisterStateMachine</span><span class="p">(</span><span class="nx">businessName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">initState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">entity</span><span class="p">,</span> <span class="nx">cancelEntity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 正常操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 第一步根据业务，以及当前状态生成fsm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fsm</span> <span class="o">:=</span> <span class="nx">easyfsm</span><span class="p">.</span><span class="nf">NewFSM</span><span class="p">(</span><span class="nx">businessName</span><span class="p">,</span> <span class="nx">initState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 第二步 调用具体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">currentState</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fsm</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nx">paymentOrderEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">easyfsm</span><span class="p">.</span><span class="nf">WithData</span><span class="p">(</span><span class="nx">orderParam</span><span class="p">{</span><span class="nx">OrderNo</span><span class="p">:</span> <span class="s">&#34;wuqinqiang050@gmail.com&#34;</span><span class="p">}))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[Success]call paymentOrderEventName err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[Success]call paymentOrderEventName state:%v\n&#34;</span><span class="p">,</span> <span class="nx">currentState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="结束">结束</h3>
<p>如果有其他不一样的需求，欢迎大家在issue留言。</p>
<p>GitHub:<a href="https://github.com/wuqinqiang/easyfsm">easyfsm</a></p>
]]></content>
		</item>
		
		<item>
			<title>你还不体验泛型吗</title>
			<link>https://www.syst.top/posts/go/generics/</link>
			<pubDate>Sun, 02 Jan 2022 18:32:00 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/generics/</guid>
			<description>介绍 之前有看过官方发布的一些泛型文章，但是自己没动手玩过。还有没有没玩过的，那么最后一班车了。
不管学什么入门先从官网拿例子。
这段代码很简单，定义两个函数，计算对应传入的map值的和。两个函数最大的不同在于函数参数类型有所不同，一个map的值类型为int64,一个为float64，对应返回参数也有所不同。
在没有泛型的情况下，每种类型都不得不重新定义一个函数。
有人可能会说，上面的代码你可以这样写在一个函数里，
你确认这真的好吗？
泛型函数 但是，有了泛型之后，那就简单多了。
上面这段代码中，
定义了一个新函数SumIntsOrFloats，该函数声明两个类型参数 [K comparable, V int64 | float64]。其中K指定了类型必须为可比较(即可以用作比较符 == 和 !=)。因为 go中规定map的key必须是可比较类型。
比如，我们不能这样声明一个map。
所以这里的K就不能使用any关键字。
另一个V参数指定了一个约束，该约束由int64和float64组成，使用 | 指定了联合类型。
所以这里m参数为map[K]V类型，K,V即为参数类型指定的类型。
那么，如果你传入的map值的类型为其他类型。比如下面这种就不行了。
类型约束 上面看到的是我们在方法上对参数做一些约束。当然我们也可以直接声明类型约束。
上面的代码声明了一个Number用做类型约束的接口类型。在接口里声明int64和float64联合类型。
在SumNumbers中如果约束类型为int64或者 float64，那么只需要使用Number类型约束即可，就不用每个不同函数写 int64 | float64，达到代码复用的效果。
但是如果我这样，
我们把map中的值类型调整为自定义的otherInt64类型，otherInt64的基础类型也是int64。但是，这段代码编译会报错。
原因是 int64 约束会将其限制为只能是该类型，也就是只能是 int64，不能是基于此类型定义的其他类型。
如果想使用otherInt64咋么办，很简单，只需要一个～符号，
使用带～xxtype会将其限制为基础类型为xxtype的所有类型。
应用 上面只是简单介绍了一下使用姿势，那么哪些场景下可以使用泛型呢？
比如日常开发中，像slice、map、channel的一些处理函数，可能逻辑相同但是类型不同导致copy多个不同函数，这时候可以用泛型解决。比如，
还有一些行为方面的。比如 go 中的排序，通过泛型，不需要每一个结构都实现(Len，Less，Swap)三个方法，而是抽象出依赖于三个方法的行为。那么想要实现排序只需要依赖定义的这个抽象就行了。
其他方面的应用可以自行体验。
总结 这篇文章主要带你们体验下泛型的基本使用，以及对应的类型约束，最后还简单实验了两个泛型的场景demo，感兴趣的可以自行体验。更多内容，欢迎留言区域交流。
附录  https://go.dev/doc/tutorial/generics https://teivah.medium.com/when-to-use-generics-in-go-36d49c1aeda https://github.com/mattn/go-generics-example  </description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>之前有看过官方发布的一些泛型文章，但是自己没动手玩过。还有没有没玩过的，那么最后一班车了。</p>
<p>不管学什么入门先从官网拿例子。</p>
<p><img src="https://cdn.syst.top/1.png" alt="image-20220102185612332"></p>
<p>这段代码很简单，定义两个函数，计算对应传入的map值的和。两个函数最大的不同在于函数参数类型有所不同，一个map的值类型为int64,一个为float64，对应返回参数也有所不同。</p>
<p>在没有泛型的情况下，每种类型都不得不重新定义一个函数。</p>
<p>有人可能会说，上面的代码你可以这样写在一个函数里，</p>
<p><img src="https://cdn.syst.top/2.png" alt="image-20220102190814109"></p>
<p>你确认这真的好吗？</p>
<h3 id="泛型函数">泛型函数</h3>
<p>但是，有了泛型之后，那就简单多了。</p>
<p><img src="https://cdn.syst.top/2-2.png" alt="image-20220102191445161"></p>
<p>上面这段代码中，</p>
<p>定义了一个新函数SumIntsOrFloats，该函数声明两个类型参数 [K comparable, V int64 | float64]。其中K指定了类型必须为可比较(即可以用作比较符 == 和 !=)。因为 go中规定map的key必须是可比较类型。</p>
<p>比如，我们不能这样声明一个map。</p>
<p><img src="https://cdn.syst.top/3.png" alt="image-20220102200928248"></p>
<p>所以这里的K就不能使用any关键字。</p>
<p>另一个V参数指定了一个约束，该约束由int64和float64组成，使用 | 指定了联合类型。</p>
<p>所以这里m参数为map[K]V类型，K,V即为参数类型指定的类型。</p>
<p>那么，如果你传入的map值的类型为其他类型。比如下面这种就不行了。</p>
<p><img src="https://cdn.syst.top/4.png" alt="image-20220102194519848"></p>
<h3 id="类型约束">类型约束</h3>
<p>上面看到的是我们在方法上对参数做一些约束。当然我们也可以直接声明类型约束。</p>
<p><img src="https://cdn.syst.top/4-4.png" alt="image-20220102202446122"></p>
<p>上面的代码声明了一个Number用做类型约束的接口类型。在接口里声明int64和float64联合类型。</p>
<p>在SumNumbers中如果约束类型为int64或者 float64，那么只需要使用Number类型约束即可，就不用每个不同函数写 int64 | float64，达到代码复用的效果。</p>
<p>但是如果我这样，</p>
<p><img src="https://cdn.syst.top/5.png" alt="image-20220102203657206"></p>
<p>我们把map中的值类型调整为自定义的otherInt64类型，otherInt64的基础类型也是int64。但是，这段代码编译会报错。</p>
<p>原因是 int64 约束会将其限制为只能是该类型，也就是只能是 int64，不能是基于此类型定义的其他类型。</p>
<p>如果想使用otherInt64咋么办，很简单，只需要一个～符号，</p>
<p><img src="https://cdn.syst.top/6.png" alt="image-20220102204212141"></p>
<p>使用带～xxtype会将其限制为基础类型为xxtype的所有类型。</p>
<h3 id="应用">应用</h3>
<p>上面只是简单介绍了一下使用姿势，那么哪些场景下可以使用泛型呢？</p>
<p>比如日常开发中，像slice、map、channel的一些处理函数，可能逻辑相同但是类型不同导致copy多个不同函数，这时候可以用泛型解决。比如，</p>
<p><img src="https://cdn.syst.top/8.png" alt="image-20220102231043331"></p>
<p>还有一些行为方面的。比如 go 中的排序，通过泛型，不需要每一个结构都实现(Len，Less，Swap)三个方法，而是抽象出依赖于三个方法的行为。那么想要实现排序只需要依赖定义的这个抽象就行了。</p>
<p><img src="https://cdn.syst.top/7.png" alt="image-20220102225615043"></p>
<p>其他方面的应用可以自行体验。</p>
<h3 id="总结">总结</h3>
<p>这篇文章主要带你们体验下泛型的基本使用，以及对应的类型约束，最后还简单实验了两个泛型的场景demo，感兴趣的可以自行体验。更多内容，欢迎留言区域交流。</p>
<h3 id="附录"><strong>附录</strong></h3>
<ul>
<li><a href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a></li>
<li><a href="https://teivah.medium.com/when-to-use-generics-in-go-36d49c1aeda">https://teivah.medium.com/when-to-use-generics-in-go-36d49c1aeda</a></li>
<li><a href="https://github.com/mattn/go-generics-example">https://github.com/mattn/go-generics-example</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>那些用Go实现的分布式事务框架</title>
			<link>https://www.syst.top/posts/go/transaction/</link>
			<pubDate>Wed, 08 Dec 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/transaction/</guid>
			<description>开篇 不知不觉竟然一个月没更新了，人一旦懒下来只会越来越懒。
最近对分布式事务产生了一些兴趣，查阅了一些文章以及论文。这篇文章主要介绍我看的两个项目，不涉及一些理论知识。
 阿里开源版本的Seata，主要看了Go实现的seata-golang(落后java版) 以及前段时间很多公众号都发的dtm。  Seata简介 Seata是由阿里开源的分布式事务服务，目前为用户提供了AT、TCC、SAGA、XA的事务模式，整体采用的是两阶段提交协议。Go版的seata-golang 目前好像只实现了mysql的AT、TCC模式，作者现在不咋更新了。
Seata 有几个核心角色：
 TC(Transaction Coordinator) -事务协调者。(维护全局和分支事务的状态，驱动全局事务提交或回滚) TM(Transaction Manager)-事务管理器。(定义全局事务的范围：开始全局事务、提交或回滚全局事务。) RM(Resource Manager)-资源管理器。(管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚)  当然这样看，可能还不是很理解，我拿一张官网的图加以解释。
从上图中可以看出，这三个角色所负责的工作如下，
TC
 维护全局和分支事务状态，需要进行存储。 当一个分布式事务处理结束，需要通知到每个RM是commit还是rollback。  TM
 向TC请求开启一个分布式事务，得到一个全局唯一的分布式id。 根据每个参与分布式事务的RM一阶段的反馈，决定二阶段向TC请求此次分布式事务是commit还是rollback(绝大部分场景下，一阶段任一RM失败，本次分布式事务失败)  RM
说的白一点就是管理参与分布式事务的各个服务(比如经典下单场景中涉及到的:订单服务、库存服务、营销服务等)
ps:个人感觉，这里的RM有点类似微服务中的中间处理层(专业术语他们管这叫bff-&amp;gt;backend for fronted)。
  一阶段 prepare 行为(主动)：每个RM调用 自定义 的 prepare 逻辑。
  二阶段 commit 行为(被动触发)：如果本次分布式事务第一阶段全部RM成功，TC处理完自身状态变更后，调用各个RM自定义 的 commit 逻辑。(一阶段RM全部成功)
  二阶段 rollback 行为(被动触发)：如果本次分布式事务第一阶段任一RM失败，TC处理完自身状态变更后，调用各个RM自定义 的 rollback 逻辑。(一阶段任意RM失败)
  好了。下面可以看看seata-golang 实现的一些细节了，seata-golang 底层采用gRPC进行通信。
seata-golang 我们先看RM部分结构。</description>
			<content type="html"><![CDATA[<h3 id="开篇">开篇</h3>
<p>不知不觉竟然一个月没更新了，人一旦懒下来只会越来越懒。</p>
<p>最近对分布式事务产生了一些兴趣，查阅了一些文章以及论文。这篇文章主要介绍我看的两个项目，不涉及一些理论知识。</p>
<ul>
<li>阿里开源版本的Seata，主要看了Go实现的seata-golang(落后java版)</li>
<li>以及前段时间很多公众号都发的dtm。</li>
</ul>
<h3 id="seata简介">Seata简介</h3>
<p>Seata是由阿里开源的分布式事务服务，目前为用户提供了AT、TCC、SAGA、XA的事务模式，整体采用的是两阶段提交协议。Go版的seata-golang 目前好像只实现了mysql的AT、TCC模式，作者现在不咋更新了。</p>
<p>Seata 有几个核心角色：</p>
<ul>
<li>TC(Transaction Coordinator) -事务协调者。(维护全局和分支事务的状态，驱动全局事务提交或回滚)</li>
<li>TM(Transaction Manager)-事务管理器。(定义全局事务的范围：开始全局事务、提交或回滚全局事务。)</li>
<li>RM(Resource Manager)-资源管理器。(管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚)</li>
</ul>
<p>当然这样看，可能还不是很理解，我拿一张官网的图加以解释。</p>
<p><img src="https://cdn.syst.top/transaction.png" alt="seata_tcc-1"></p>
<p>从上图中可以看出，这三个角色所负责的工作如下，</p>
<p>TC</p>
<ul>
<li>维护全局和分支事务状态，需要进行存储。</li>
<li>当一个分布式事务处理结束，需要通知到每个RM是commit还是rollback。</li>
</ul>
<p>TM</p>
<ul>
<li>向TC请求开启一个分布式事务，得到一个全局唯一的分布式id。</li>
<li>根据每个参与分布式事务的RM一阶段的反馈，决定二阶段向TC请求此次分布式事务是commit还是rollback(绝大部分场景下，一阶段任一RM失败，本次分布式事务失败)</li>
</ul>
<p>RM</p>
<p>说的白一点就是管理参与分布式事务的各个服务(比如经典下单场景中涉及到的:订单服务、库存服务、营销服务等)</p>
<p>ps:个人感觉，这里的RM有点类似微服务中的中间处理层(专业术语他们管这叫bff-&gt;backend for fronted)。</p>
<ul>
<li>
<p>一阶段 prepare 行为(主动)：每个RM调用 <strong>自定义</strong> 的 prepare 逻辑。</p>
</li>
<li>
<p>二阶段 commit 行为(被动触发)：如果本次分布式事务第一阶段全部RM成功，TC处理完自身状态变更后，调用各个RM<strong>自定义</strong> 的 commit 逻辑。(一阶段RM全部成功)</p>
</li>
<li>
<p>二阶段 rollback 行为(被动触发)：如果本次分布式事务第一阶段任一RM失败，TC处理完自身状态变更后，调用各个RM<strong>自定义</strong> 的 rollback 逻辑。(一阶段任意RM失败)</p>
</li>
</ul>
<p>好了。下面可以看看seata-golang 实现的一些细节了，seata-golang 底层采用gRPC进行通信。</p>
<h3 id="seata-golang">seata-golang</h3>
<p>我们先看RM部分结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ResourceManager</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">addressing</span>     <span class="kt">string</span> <span class="c1">//rm地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rpcClient</span>      <span class="nx">apis</span><span class="p">.</span><span class="nx">ResourceManagerServiceClient</span> <span class="c1">//rm rpc客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">managers</span>       <span class="kd">map</span><span class="p">[</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchSession_BranchType</span><span class="p">]</span><span class="nx">ResourceManagerInterface</span> <span class="c1">//存储rm事务模式（比如TCC、AT等）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">branchMessages</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchMessage</span> <span class="c1">//存储将要向TC响应的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ResourceManagerServiceClient</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 和 TC 流数据交互接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nf">BranchCommunicate</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">ResourceManagerService_BranchCommunicateClient</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 向TC 注册分支
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nf">BranchRegister</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">BranchRegisterRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">BranchRegisterResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//.....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>至于managers，保存支持的各大事务模式(TCC等)，每个模式只需要实现此接口即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ResourceManagerInterface</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分支提交
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">BranchCommit</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">request</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 分支回退
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">BranchRollback</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">request</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchRollbackRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchRollbackResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>再看TC部分结构(只保留会涉及的字段，其他细节可以自行查阅)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TransactionCoordinator</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">holder</span>             <span class="o">*</span><span class="nx">holder</span><span class="p">.</span><span class="nx">SessionHolder</span> <span class="c1">//数据存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">futures</span>            <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span> <span class="c1">//临时存储RM响应数据，有g在接受处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">callBackMessages</span>   <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span> <span class="c1">//临时存储TC即将向RM发送的消息,有格外g在发送数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SessionHolder</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">manager</span> <span class="nx">storage</span><span class="p">.</span><span class="nx">SessionManager</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// SessionManager stored the globalTransactions and branchTransactions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">SessionManager</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Add global session.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">AddGlobalSession</span><span class="p">(</span><span class="nx">session</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">GlobalSession</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Find global session.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">FindGlobalSession</span><span class="p">(</span><span class="nx">xid</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">GlobalSession</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Find global sessions list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">FindGlobalSessions</span><span class="p">(</span><span class="nx">statuses</span> <span class="p">[]</span><span class="nx">apis</span><span class="p">.</span><span class="nx">GlobalSession_GlobalStatus</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">GlobalSession</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>TC对数据的存储目前支持mysql和pgsql，即实现SessionManager接口，然后注入到SessionHolder的manager。</p>
<p>介绍完这两个基本结构，还记得我们上面说过他们之间的关系吗？</p>
<p>二阶段TC会根据当前事务状态去通知RM是commit还是rollback。</p>
<p>在初始化ResourceManager 的时候，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">InitResourceManager</span><span class="p">(</span><span class="nx">addressing</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">client</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">ResourceManagerServiceClient</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">defaultResourceManager</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ResourceManager</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">addressing</span><span class="p">:</span>     <span class="nx">addressing</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rpcClient</span><span class="p">:</span>      <span class="nx">client</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">managers</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchSession_BranchType</span><span class="p">]</span><span class="nx">ResourceManagerInterface</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">branchMessages</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchMessage</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GoWithRecover</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 会单独开启一个g调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">defaultResourceManager</span><span class="p">.</span><span class="nf">branchCommunicate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">manager</span> <span class="o">*</span><span class="nx">ResourceManager</span><span class="p">)</span> <span class="nf">branchCommunicate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="c1">//省略代码。。。。。。。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">manager</span><span class="p">.</span><span class="nx">rpcClient</span><span class="p">.</span><span class="nf">BranchCommunicate</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 省略代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>我们看到最终会调用TC一个 grpc 接口branchCommunicate。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nf">BranchCommunicate</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">ResourceManagerService_BranchCommunicateClient</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ResourceManagerService_BranchCommunicateClient</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Send</span><span class="p">(</span><span class="o">*</span><span class="nx">BranchMessage</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Recv</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">BranchMessage</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientStream</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对应到服务端。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">rpc</span> <span class="nf">BranchCommunicate</span><span class="p">(</span><span class="nx">stream</span> <span class="nx">BranchMessage</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">stream</span> <span class="nx">BranchMessage</span><span class="p">);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ResourceManagerService_BranchCommunicateServer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Send</span><span class="p">(</span><span class="o">*</span><span class="nx">BranchMessage</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Recv</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">BranchMessage</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">grpc</span><span class="p">.</span><span class="nx">ServerStream</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们知道gRPC有四种基础的通信模式。</p>
<ul>
<li>一元模式（Unary RPC）</li>
<li>服务器端流RPC（Server Sreaming RPC）</li>
<li>客户端流RPC（Client Streaming RPC）</li>
<li>双向流RPC（Bidirectional Streaming RPC）</li>
</ul>
<p>想要流的形式也很简单，只需要在proto方法定义中将对应的请求|响应 参数前加上stream标记，那么这个接口就是流式传送了。至于是哪种流，取决于你把stream加在哪边，如果请求和响应都加，那么就是双向流了。</p>
<p>客户端和服务端都可以通过stream.Send 发送请求，通过stream.Recv 读取响应。</p>
<p>当RM调用BranchCommunicate时，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">manager</span> <span class="o">*</span><span class="nx">ResourceManager</span><span class="p">)</span> <span class="nf">branchCommunicate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">AppendToOutgoingContext</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="s">&#34;addressing&#34;</span><span class="p">,</span> <span class="nx">manager</span><span class="p">.</span><span class="nx">addressing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 得到steam
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">manager</span><span class="p">.</span><span class="nx">rpcClient</span><span class="p">.</span><span class="nf">BranchCommunicate</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 即-&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">//      type ResourceManagerService_BranchCommunicateClient interface {
</span></span></span><span class="line"><span class="cl"><span class="c1">//       	Send(*BranchMessage) error
</span></span></span><span class="line"><span class="cl"><span class="c1">//	      Recv() (*BranchMessage, error)
</span></span></span><span class="line"><span class="cl"><span class="c1">//      	grpc.ClientStream
</span></span></span><span class="line"><span class="cl"><span class="c1">//       }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">continue</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 另开一个g用来响应消息给TC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">runtime</span><span class="p">.</span><span class="nf">GoWithRecover</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 死循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">               <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="k">return</span>
</span></span><span class="line"><span class="cl">               <span class="p">}</span>
</span></span><span class="line"><span class="cl">               <span class="c1">// 如果branchMessages 有数据，说明是处理完tc的响应数据，通过send响应给tc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">case</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">manager</span><span class="p">.</span><span class="nx">branchMessages</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">               <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="k">return</span>
</span></span><span class="line"><span class="cl">               <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 另一个死循环是用来接受从tc发送过来的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 接受数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="nx">msg</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// 判断tc发送数据的类型，是提交分支事务类型还是回滚类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">switch</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">BranchMessageType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// 如果是分支提交的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">case</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TypeBranchCommit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nx">request</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitRequest</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">data</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GetMessage</span><span class="p">().</span><span class="nf">GetValue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="nx">err</span> <span class="o">:=</span> <span class="nx">request</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="nx">log</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 处理分支提交，得到处理结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">response</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">manager</span><span class="p">.</span><span class="nf">BranchCommit</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="nx">content</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">MarshalAny</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="c1">// 再把处理完的结果包装一下塞到branchMessages等待发送出去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="nx">manager</span><span class="p">.</span><span class="nx">branchMessages</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchMessage</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                     <span class="nx">ID</span><span class="p">:</span>                <span class="nx">msg</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="nx">BranchMessageType</span><span class="p">:</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TypeBranchCommitResult</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="nx">Message</span><span class="p">:</span>           <span class="nx">content</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">               <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果是回滚的消息，本质上流程差不多
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">case</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TypeBranchRollback</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nx">request</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchRollbackRequest</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">data</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GetMessage</span><span class="p">().</span><span class="nf">GetValue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="nx">err</span> <span class="o">:=</span> <span class="nx">request</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="nx">log</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">response</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">manager</span><span class="p">.</span><span class="nf">BranchRollback</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="nx">content</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">MarshalAny</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="nx">manager</span><span class="p">.</span><span class="nx">branchMessages</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchMessage</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                     <span class="nx">ID</span><span class="p">:</span>                <span class="nx">msg</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="nx">BranchMessageType</span><span class="p">:</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TypeBranchRollBackResult</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="nx">Message</span><span class="p">:</span>           <span class="nx">content</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">               <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 关闭流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">err</span> <span class="p">=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">CloseSend</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">log</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最终处理分支事务调用manager.BranchCommit，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">manager</span> <span class="nx">ResourceManager</span><span class="p">)</span> <span class="nf">BranchCommit</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">request</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 根据事务模式调用对应的处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rm</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">manager</span><span class="p">.</span><span class="nx">managers</span><span class="p">[</span><span class="nx">request</span><span class="p">.</span><span class="nx">BranchType</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">rm</span><span class="p">.</span><span class="nf">BranchCommit</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitResponse</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ResultCode</span><span class="p">:</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">ResultCodeFailed</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Message</span><span class="p">:</span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;there is no resource manager for %s&#34;</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">BranchType</span><span class="p">.</span><span class="nf">String</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>相应的，当TC被RM调用BranchCommunicate 后，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">tc</span> <span class="o">*</span><span class="nx">TransactionCoordinator</span><span class="p">)</span> <span class="nf">BranchCommunicate</span><span class="p">(</span><span class="nx">stream</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">ResourceManagerService_BranchCommunicateServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">addressing</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Context</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">md</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">FromIncomingContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">//省略一些无关代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//............
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">addressing</span> <span class="p">=</span> <span class="nx">md</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;addressing&#34;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">//这里很好懂吧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">queue</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">tc</span><span class="p">.</span><span class="nx">callBackMessages</span><span class="p">.</span><span class="nf">LoadOrStore</span><span class="p">(</span><span class="nx">addressing</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchMessage</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">.(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchMessage</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// 单独一个g 运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 用来从callBackMessages中取数据发送给客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GoWithRecover</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 死循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果能拿到数据，说明有数据需要发送给客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">case</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">q</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 下面的死循环逻辑主要是从stearm 接受客户端响应数据，然后塞入到future中，根据唯一的branch_message_Id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">			<span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//有数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">branchMessage</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 要区分是什么响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 根据是 事务commit的响应，还是对rollback的响应,交给不同逻辑处理。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">switch</span> <span class="nx">branchMessage</span><span class="p">.</span><span class="nf">GetBranchMessageType</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 分支事务提交的响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">case</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TypeBranchCommitResult</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">response</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitResponse</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">data</span> <span class="o">:=</span> <span class="nx">branchMessage</span><span class="p">.</span><span class="nf">GetMessage</span><span class="p">().</span><span class="nf">GetValue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 解析数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">err</span> <span class="o">:=</span> <span class="nx">response</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">log</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="k">continue</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 说明发送commit的动作在等待响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">resp</span><span class="p">,</span> <span class="nx">loaded</span> <span class="o">:=</span> <span class="nx">tc</span><span class="p">.</span><span class="nx">futures</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">branchMessage</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">loaded</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 赋值响应数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">future</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.(</span><span class="o">*</span><span class="nx">common2</span><span class="p">.</span><span class="nx">MessageFuture</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">future</span><span class="p">.</span><span class="nx">Response</span> <span class="p">=</span> <span class="nx">response</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 通知数据到了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">future</span><span class="p">.</span><span class="nx">Done</span> <span class="o">&lt;-</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">					<span class="nx">tc</span><span class="p">.</span><span class="nx">futures</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">branchMessage</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 和上面差不多逻辑除了响应数据不同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">case</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TypeBranchRollBackResult</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">response</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchRollbackResponse</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">data</span> <span class="o">:=</span> <span class="nx">branchMessage</span><span class="p">.</span><span class="nf">GetMessage</span><span class="p">().</span><span class="nf">GetValue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="nx">err</span> <span class="o">:=</span> <span class="nx">response</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">log</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="k">continue</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">resp</span><span class="p">,</span> <span class="nx">loaded</span> <span class="o">:=</span> <span class="nx">tc</span><span class="p">.</span><span class="nx">futures</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">branchMessage</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">loaded</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">future</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.(</span><span class="o">*</span><span class="nx">common2</span><span class="p">.</span><span class="nx">MessageFuture</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">future</span><span class="p">.</span><span class="nx">Response</span> <span class="p">=</span> <span class="nx">response</span>
</span></span><span class="line"><span class="cl">					<span class="nx">future</span><span class="p">.</span><span class="nx">Done</span> <span class="o">&lt;-</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">					<span class="nx">tc</span><span class="p">.</span><span class="nx">futures</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">branchMessage</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面要发送给RM 通知commit 或者 rollback 数据是咋么来的呢？</p>
<p>当TC要通知RM进行分支commit 的时候，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">tc</span> <span class="o">*</span><span class="nx">TransactionCoordinator</span><span class="p">)</span> <span class="nf">branchCommit</span><span class="p">(</span><span class="nx">bs</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchSession</span><span class="p">)</span> <span class="p">(</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchSession_BranchStatus</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">request</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitRequest</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">XID</span><span class="p">:</span>             <span class="nx">bs</span><span class="p">.</span><span class="nx">XID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">BranchID</span><span class="p">:</span>        <span class="nx">bs</span><span class="p">.</span><span class="nx">BranchID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ResourceID</span><span class="p">:</span>      <span class="nx">bs</span><span class="p">.</span><span class="nx">ResourceID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">LockKey</span><span class="p">:</span>         <span class="nx">bs</span><span class="p">.</span><span class="nx">LockKey</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">BranchType</span><span class="p">:</span>      <span class="nx">bs</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ApplicationData</span><span class="p">:</span> <span class="nx">bs</span><span class="p">.</span><span class="nx">ApplicationData</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">content</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">MarshalAny</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">bs</span><span class="p">.</span><span class="nx">Status</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">message</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchMessage</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ID</span><span class="p">:</span>                <span class="nb">int64</span><span class="p">(</span><span class="nx">tc</span><span class="p">.</span><span class="nx">idGenerator</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">      <span class="nx">BranchMessageType</span><span class="p">:</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TypeBranchCommit</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">Message</span><span class="p">:</span>           <span class="nx">content</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="c1">//上面是封装数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">queue</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">tc</span><span class="p">.</span><span class="nx">callBackMessages</span><span class="p">.</span><span class="nf">LoadOrStore</span><span class="p">(</span><span class="nx">bs</span><span class="p">.</span><span class="nx">Addressing</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchMessage</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="nx">q</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">.(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchMessage</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 在这把数据塞到callBackMessages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">case</span> <span class="nx">q</span> <span class="o">&lt;-</span> <span class="nx">message</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">bs</span><span class="p">.</span><span class="nx">Status</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 这里创建了RM响应格式，根据 messageid，塞入到结果futures(sync.map中)，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">resp</span> <span class="o">:=</span> <span class="nx">common2</span><span class="p">.</span><span class="nf">NewMessageFuture</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nx">tc</span><span class="p">.</span><span class="nx">futures</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">tc</span><span class="p">.</span><span class="nx">streamMessageTimeout</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// RM响应超时了，GG
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="nx">tc</span><span class="p">.</span><span class="nx">futures</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">bs</span><span class="p">.</span><span class="nx">Status</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;wait branch commit response timeout&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 响应成功，解析数据处理。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">response</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Response</span><span class="p">.(</span><span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitResponse</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">log</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;rollback response: %v&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Response</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">bs</span><span class="p">.</span><span class="nx">Status</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;response type not right&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">response</span><span class="p">.</span><span class="nx">ResultCode</span> <span class="o">==</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">ResultCodeSuccess</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">BranchStatus</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">bs</span><span class="p">.</span><span class="nx">Status</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最后一个就是TM，没啥理解难度。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// tm request to  tc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">TransactionManagerInterface</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// GlobalStatus_Begin a new global transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Begin</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">timeout</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Global commit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Commit</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">xid</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">apis</span><span class="p">.</span><span class="nx">GlobalSession_GlobalStatus</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Global rollback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Rollback</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">xid</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">apis</span><span class="p">.</span><span class="nx">GlobalSession_GlobalStatus</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Get current status of the give transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">GetStatus</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">xid</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">apis</span><span class="p">.</span><span class="nx">GlobalSession_GlobalStatus</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Global report.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">GlobalReport</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">xid</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">globalStatus</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">GlobalSession_GlobalStatus</span><span class="p">)</span> <span class="p">(</span><span class="nx">apis</span><span class="p">.</span><span class="nx">GlobalSession_GlobalStatus</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TransactionManager</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">addressing</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rpcClient</span>  <span class="nx">apis</span><span class="p">.</span><span class="nx">TransactionManagerServiceClient</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">InitTransactionManager</span><span class="p">(</span><span class="nx">addressing</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">client</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TransactionManagerServiceClient</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">defaultTransactionManager</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">TransactionManager</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">addressing</span><span class="p">:</span> <span class="nx">addressing</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rpcClient</span><span class="p">:</span>  <span class="nx">client</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其实seat-golang还有别的可以提一提的。</p>
<p>比如说，它里面通过go反射实现的动态代理功能(虽然我觉得完全没必要?)，我懒得写了。</p>
<p>这篇文章再写就更长了，不继续写dtm了，感兴趣的留个言，我看看要不要写一篇dtm。</p>
]]></content>
		</item>
		
		<item>
			<title>那些用Go实现的分布式事务框架(2)</title>
			<link>https://www.syst.top/posts/go/transaction2/</link>
			<pubDate>Wed, 08 Dec 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/transaction2/</guid>
			<description>开篇 上一篇我们主要介绍的是seata-golang。一个对标seata的go语言实现，当然版本还是落后Java版很多的。
这次我们来介绍一下另一个go实现的分布式事务:dtm。
首先来看下dtm整体架构图(来源官网)。
再来看之前的seata架构图。
从架构上来看，大差不差。
seata中的TC对标dam的TM。
RM两边意思一致。
seata中的TM对标dtm事务SDK。作用都是一样:第一阶段开启一个全局事务,执行各RM分支事务，第二阶段根据RM第一阶段执行结果，决定调用TC(seata)|TM(dtm) commit或者rollback。
架构上，个人感觉只是因为模块名称以及图画不一样的差别。
当然在实现细节上还是有很大差别的。
我们先简单介绍下DTM各个模块。
TM TM 层在代码中是没有具体的主体结构的，开始都是函数之前的调用。
启动TM实际上开启了两个服务，http以及grpc这两个服务。
// StartSvr StartSvr func StartSvr() { app := common.GetGinApp() app = httpMetrics(app) addRoute(app) dtmimp.Logf(&amp;#34;dtmsvr listen at: %d&amp;#34;, common.DtmHttpPort) go app.Run(fmt.Sprintf(&amp;#34;:%d&amp;#34;, common.DtmHttpPort)) lis, err := net.Listen(&amp;#34;tcp&amp;#34;, fmt.Sprintf(&amp;#34;:%d&amp;#34;, common.DtmGrpcPort)) dtmimp.FatalIfError(err) s := grpc.NewServer( grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer( grpc.UnaryServerInterceptor(grpcMetrics), grpc.UnaryServerInterceptor(dtmgimp.GrpcServerLog)), )) dtmgimp.RegisterDtmServer(s, &amp;amp;dtmServer{}) dtmimp.Logf(&amp;#34;grpc listening at %v&amp;#34;, lis.Addr()) go func() { err := s.Serve(lis) dtmimp.FatalIfError(err) }() go updateBranchAsync() // 省略代码 } http路由，</description>
			<content type="html"><![CDATA[<h3 id="开篇">开篇</h3>
<p>上一篇我们主要介绍的是seata-golang。一个对标seata的go语言实现，当然版本还是落后Java版很多的。</p>
<p>这次我们来介绍一下另一个go实现的分布式事务:dtm。</p>
<p>首先来看下dtm整体架构图(来源官网)。</p>
<p><img src="https://cdn.syst.top/arch.8ecd5239.jpg" alt="arch.8ecd5239"></p>
<p>再来看之前的seata架构图。</p>
<p><img src="https://cdn.syst.top/transaction.png" alt="seata_tcc-1"></p>
<p>从架构上来看，大差不差。</p>
<p>seata中的TC对标dam的TM。</p>
<p>RM两边意思一致。</p>
<p>seata中的TM对标dtm事务SDK。作用都是一样:第一阶段开启一个全局事务,执行各RM分支事务，第二阶段根据RM第一阶段执行结果，决定调用TC(seata)|TM(dtm) commit或者rollback。</p>
<p>架构上，个人感觉只是因为模块名称以及图画不一样的差别。</p>
<p>当然在实现细节上还是有很大差别的。</p>
<p>我们先简单介绍下DTM各个模块。</p>
<h3 id="tm">TM</h3>
<p>TM 层在代码中是没有具体的主体结构的，开始都是函数之前的调用。</p>
<p>启动TM实际上开启了两个服务，http以及grpc这两个服务。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// StartSvr StartSvr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">StartSvr</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">	<span class="nx">app</span> <span class="o">:=</span> <span class="nx">common</span><span class="p">.</span><span class="nf">GetGinApp</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">app</span> <span class="p">=</span> <span class="nf">httpMetrics</span><span class="p">(</span><span class="nx">app</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">addRoute</span><span class="p">(</span><span class="nx">app</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dtmimp</span><span class="p">.</span><span class="nf">Logf</span><span class="p">(</span><span class="s">&#34;dtmsvr listen at: %d&#34;</span><span class="p">,</span> <span class="nx">common</span><span class="p">.</span><span class="nx">DtmHttpPort</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">app</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;:%d&#34;</span><span class="p">,</span> <span class="nx">common</span><span class="p">.</span><span class="nx">DtmHttpPort</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">	<span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;:%d&#34;</span><span class="p">,</span> <span class="nx">common</span><span class="p">.</span><span class="nx">DtmGrpcPort</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dtmimp</span><span class="p">.</span><span class="nf">FatalIfError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">UnaryInterceptor</span><span class="p">(</span><span class="nx">grpc_middleware</span><span class="p">.</span><span class="nf">ChainUnaryServer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="nx">grpc</span><span class="p">.</span><span class="nf">UnaryServerInterceptor</span><span class="p">(</span><span class="nx">grpcMetrics</span><span class="p">),</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">UnaryServerInterceptor</span><span class="p">(</span><span class="nx">dtmgimp</span><span class="p">.</span><span class="nx">GrpcServerLog</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">		<span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dtmgimp</span><span class="p">.</span><span class="nf">RegisterDtmServer</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">dtmServer</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dtmimp</span><span class="p">.</span><span class="nf">Logf</span><span class="p">(</span><span class="s">&#34;grpc listening at %v&#34;</span><span class="p">,</span> <span class="nx">lis</span><span class="p">.</span><span class="nf">Addr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dtmimp</span><span class="p">.</span><span class="nf">FatalIfError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">updateBranchAsync</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// 省略代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>http路由，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">addRoute</span><span class="p">(</span><span class="nx">engine</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/api/dtmsvr/newGid&#34;</span><span class="p">,</span> <span class="nx">common</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">newGid</span><span class="p">))</span> <span class="c1">//开启一个分布式事务，得到分布式事务唯一id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">engine</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/api/dtmsvr/prepare&#34;</span><span class="p">,</span> <span class="nx">common</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">prepare</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/api/dtmsvr/submit&#34;</span><span class="p">,</span> <span class="nx">common</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">submit</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/api/dtmsvr/abort&#34;</span><span class="p">,</span> <span class="nx">common</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">abort</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>gRPC接口，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// dtmServer is used to implement dtmgimp.DtmServer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">dtmServer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pb</span><span class="p">.</span><span class="nx">UnimplementedDtmServer</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">dtmServer</span><span class="p">)</span> <span class="nf">NewGid</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">emptypb</span><span class="p">.</span><span class="nx">Empty</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">dtmgimp</span><span class="p">.</span><span class="nx">DtmGidReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">dtmgimp</span><span class="p">.</span><span class="nx">DtmGidReply</span><span class="p">{</span><span class="nx">Gid</span><span class="p">:</span> <span class="nf">GenGid</span><span class="p">()},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">dtmServer</span><span class="p">)</span> <span class="nf">Submit</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">DtmRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptypb</span><span class="p">.</span><span class="nx">Empty</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">svcSubmit</span><span class="p">(</span><span class="nf">TransFromDtmRequest</span><span class="p">(</span><span class="nx">in</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">emptypb</span><span class="p">.</span><span class="nx">Empty</span><span class="p">{},</span> <span class="nx">dtmgimp</span><span class="p">.</span><span class="nf">Result2Error</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">dtmServer</span><span class="p">)</span> <span class="nf">Prepare</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">DtmRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptypb</span><span class="p">.</span><span class="nx">Empty</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">svcPrepare</span><span class="p">(</span><span class="nf">TransFromDtmRequest</span><span class="p">(</span><span class="nx">in</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">emptypb</span><span class="p">.</span><span class="nx">Empty</span><span class="p">{},</span> <span class="nx">dtmgimp</span><span class="p">.</span><span class="nf">Result2Error</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">dtmServer</span><span class="p">)</span> <span class="nf">Abort</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">DtmRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptypb</span><span class="p">.</span><span class="nx">Empty</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">svcAbort</span><span class="p">(</span><span class="nf">TransFromDtmRequest</span><span class="p">(</span><span class="nx">in</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">emptypb</span><span class="p">.</span><span class="nx">Empty</span><span class="p">{},</span> <span class="nx">dtmgimp</span><span class="p">.</span><span class="nf">Result2Error</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>即然提供了两个服务入口，那理所当然有公共处理核心业务的部分。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 提交事务请求操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">svcSubmit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TransGlobal</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span> <span class="o">:=</span> <span class="nf">dbGet</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nx">Status</span> <span class="p">=</span> <span class="nx">dtmcli</span><span class="p">.</span><span class="nx">StatusSubmitted</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">saveNew</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">errUniqueConflict</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dbt</span> <span class="o">:=</span> <span class="nf">transFromDb</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Gid</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">dbt</span><span class="p">.</span><span class="nx">Status</span> <span class="o">==</span> <span class="nx">dtmcli</span><span class="p">.</span><span class="nx">StatusPrepared</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">updates</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">setNextCron</span><span class="p">(</span><span class="nx">cronReset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">dbr</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Must</span><span class="p">().</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">TransGlobal</span><span class="p">{}).</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;gid=? and status=?&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Gid</span><span class="p">,</span> <span class="nx">dtmcli</span><span class="p">.</span><span class="nx">StatusPrepared</span><span class="p">).</span><span class="nf">Select</span><span class="p">(</span><span class="nb">append</span><span class="p">(</span><span class="nx">updates</span><span class="p">,</span> <span class="s">&#34;status&#34;</span><span class="p">)).</span><span class="nf">Updates</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">checkAffected</span><span class="p">(</span><span class="nx">dbr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">dbt</span><span class="p">.</span><span class="nx">Status</span> <span class="o">!=</span> <span class="nx">dtmcli</span><span class="p">.</span><span class="nx">StatusSubmitted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span><span class="s">&#34;dtm_result&#34;</span><span class="p">:</span> <span class="nx">dtmcli</span><span class="p">.</span><span class="nx">ResultFailure</span><span class="p">,</span> <span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;current status &#39;%s&#39;, cannot sumbmit&#34;</span><span class="p">,</span> <span class="nx">dbt</span><span class="p">.</span><span class="nx">Status</span><span class="p">)},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Process</span><span class="p">(</span><span class="nx">db</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 准备事务请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">svcPrepare</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TransGlobal</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nx">Status</span> <span class="p">=</span> <span class="nx">dtmcli</span><span class="p">.</span><span class="nx">StatusPrepared</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">saveNew</span><span class="p">(</span><span class="nf">dbGet</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">  <span class="c1">////.........
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 中断事务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">svcAbort</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TransGlobal</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span> <span class="o">:=</span> <span class="nf">dbGet</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dbt</span> <span class="o">:=</span> <span class="nf">transFromDb</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Gid</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 注册分支
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">svcRegisterBranch</span><span class="p">(</span><span class="nx">branch</span> <span class="o">*</span><span class="nx">TransBranch</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">rerr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nf">dbGet</span><span class="p">().</span><span class="nf">Transaction</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">DB</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dbt</span> <span class="o">:=</span> <span class="nf">transFromDb</span><span class="p">(</span><span class="nx">db</span><span class="p">,</span> <span class="nx">branch</span><span class="p">.</span><span class="nx">Gid</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">///.......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>TM对数据的存储管理并不是依赖于接口，而是依赖于common.DB 结构。根据配置文件中DB.driver 的值决定底层数据库是mysql还是postgres两种。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">dbGet</span><span class="p">()</span> <span class="o">*</span><span class="nx">common</span><span class="p">.</span><span class="nx">DB</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">common</span><span class="p">.</span><span class="nf">DbGet</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">DB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// DbGet get db connection for specified conf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">DbGet</span><span class="p">(</span><span class="nx">conf</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">DB</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">dsn</span> <span class="o">:=</span> <span class="nx">dtmimp</span><span class="p">.</span><span class="nf">GetDsn</span><span class="p">(</span><span class="nx">conf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//.....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// GetDsn get dsn from map config
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">GetDsn</span><span class="p">(</span><span class="nx">conf</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">host</span> <span class="o">:=</span> <span class="nf">MayReplaceLocalhost</span><span class="p">(</span><span class="nx">conf</span><span class="p">[</span><span class="s">&#34;host&#34;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">   <span class="nx">driver</span> <span class="o">:=</span> <span class="nx">conf</span><span class="p">[</span><span class="s">&#34;driver&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="nx">dsn</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;mysql&#34;</span><span class="p">:</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=true&amp;loc=Local&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="nx">conf</span><span class="p">[</span><span class="s">&#34;user&#34;</span><span class="p">],</span> <span class="nx">conf</span><span class="p">[</span><span class="s">&#34;password&#34;</span><span class="p">],</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">conf</span><span class="p">[</span><span class="s">&#34;port&#34;</span><span class="p">],</span> <span class="nx">conf</span><span class="p">[</span><span class="s">&#34;database&#34;</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;postgres&#34;</span><span class="p">:</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;host=%s user=%s password=%s dbname=&#39;%s&#39; port=%s sslmode=disable&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="nx">host</span><span class="p">,</span> <span class="nx">conf</span><span class="p">[</span><span class="s">&#34;user&#34;</span><span class="p">],</span> <span class="nx">conf</span><span class="p">[</span><span class="s">&#34;password&#34;</span><span class="p">],</span> <span class="nx">conf</span><span class="p">[</span><span class="s">&#34;database&#34;</span><span class="p">],</span> <span class="nx">conf</span><span class="p">[</span><span class="s">&#34;port&#34;</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl">   <span class="p">}[</span><span class="nx">driver</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="nf">PanicIf</span><span class="p">(</span><span class="nx">dsn</span> <span class="o">==</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;unknow driver: %s&#34;</span><span class="p">,</span> <span class="nx">driver</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">dsn</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>再看这个DB结构，所以本质上无论底层是哪种数据库，都是直接依赖gorm来对数据进行操作的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// DB provide more func over gorm.DB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">DB</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">DB</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>接着，看下TM是如何通知各个RM进行commit或者rollback的？</p>
<p>举一个TCC模式的例子。</p>
<p>TCC的两个阶段。</p>
<ul>
<li>阶段一: try。尝试执行，调用各RM自定义的try行为，预留必要的业务资源。</li>
<li>阶段二:Confirm(阶段一所有参与本次事务的try行为都成功)。调用各分支事务的Confirm方法，真正执行业务，并且只使用try阶段预留的资源。</li>
<li>阶段二:Cancel(阶段一任一参与本次事务的try行为失败)。调用各分支事务的Cancel方法，释放一阶段try所预留的资源。</li>
</ul>
<p>从上面我们可以得知，TCC模式下，TM在第二阶段要么通知各分支事务Confirm要么Cancel。</p>
<p>在注册各RM事务分支到TM的时候，最终TM会为每一个分布式事务的参与者(RM)生成两条分支信息。</p>
<p>就像这样，</p>
<pre tabindex="0"><code>gid(分布式事务id)  url(rm请求地址)    data(数据)   op(操作类型比如:confirm｜cancel)
520xxx           xxx.com/confirm    xxx.          confirm
520xxx           xxx.com/cancel     xxx           cancel
</code></pre><p>对，就是把对应的RM资源操作地址直接存入。</p>
<p>当TM接收到commit或者rollback命令，在处理完自身逻辑(一般就是修改Gloable状态)，就需要开始处理每一个注册进来的分支事务了，说白了就是需要调用各个分支事务对应操作的接口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TransGlobal</span><span class="p">)</span> <span class="nf">processInner</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">common</span><span class="p">.</span><span class="nx">DB</span><span class="p">)</span> <span class="p">(</span><span class="nx">rerr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">branches</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">TransBranch</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span><span class="p">.</span><span class="nf">Must</span><span class="p">().</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;gid=?&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Gid</span><span class="p">).</span><span class="nf">Order</span><span class="p">(</span><span class="s">&#34;id asc&#34;</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">branches</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nx">lastTouched</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rerr</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">getProcessor</span><span class="p">().</span><span class="nf">ProcessOnce</span><span class="p">(</span><span class="nx">db</span><span class="p">,</span> <span class="nx">branches</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里的t.getProcessor() 是需要根据当前事务的类型(TCC、SAGA、XA)获取到对应的处理器来进行逻辑的处理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TransGlobal</span><span class="p">)</span> <span class="nf">getProcessor</span><span class="p">()</span> <span class="nx">transProcessor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">processorFac</span><span class="p">[</span><span class="nx">t</span><span class="p">.</span><span class="nx">TransType</span><span class="p">](</span><span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当然，每个事务处理器只需要实现接口，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">transProcessor</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">GenBranches</span><span class="p">()</span> <span class="p">[]</span><span class="nx">TransBranch</span>
</span></span><span class="line"><span class="cl">	<span class="nf">ProcessOnce</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">common</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="nx">branches</span> <span class="p">[]</span><span class="nx">TransBranch</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>真正调用RM资源服务地址的时候，分为http和grpc，这是由开发者决定的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TransGlobal</span><span class="p">)</span> <span class="nf">getURLResult</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">branchID</span><span class="p">,</span> <span class="nx">op</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">branchPayload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Protocol</span> <span class="o">==</span> <span class="s">&#34;grpc&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dtmimp</span><span class="p">.</span><span class="nf">PanicIf</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="s">&#34;http&#34;</span><span class="p">),</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;bad url for grpc: %s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">server</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dtmdriver</span><span class="p">.</span><span class="nf">GetDriver</span><span class="p">().</span><span class="nf">ParseServerMethod</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">dtmgimp</span><span class="p">.</span><span class="nf">MustGetGrpcConn</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">dtmgimp</span><span class="p">.</span><span class="nf">TransInfo2Ctx</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">Gid</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">TransType</span><span class="p">,</span> <span class="nx">branchID</span><span class="p">,</span> <span class="nx">op</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">branchPayload</span><span class="p">,</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dtmimp</span><span class="p">.</span><span class="nf">PanicIf</span><span class="p">(!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="s">&#34;http&#34;</span><span class="p">),</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;bad url for http: %s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dtmimp</span><span class="p">.</span><span class="nx">RestyClient</span><span class="p">.</span><span class="nf">R</span><span class="p">().</span><span class="nf">SetBody</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">branchPayload</span><span class="p">)).</span>
</span></span><span class="line"><span class="cl">		<span class="nf">SetQueryParams</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;gid&#34;</span><span class="p">:</span>        <span class="nx">t</span><span class="p">.</span><span class="nx">Gid</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;trans_type&#34;</span><span class="p">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">TransType</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;branch_id&#34;</span><span class="p">:</span>  <span class="nx">branchID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;op&#34;</span><span class="p">:</span>         <span class="nx">op</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}).</span>
</span></span><span class="line"><span class="cl">		<span class="nf">SetHeader</span><span class="p">(</span><span class="s">&#34;Content-type&#34;</span><span class="p">,</span> <span class="s">&#34;application/json&#34;</span><span class="p">).</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Execute</span><span class="p">(</span><span class="nx">dtmimp</span><span class="p">.</span><span class="nf">If</span><span class="p">(</span><span class="nx">branchPayload</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">TransType</span> <span class="o">==</span> <span class="s">&#34;xa&#34;</span><span class="p">,</span> <span class="s">&#34;POST&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).(</span><span class="kt">string</span><span class="p">),</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">resp</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在v1.6之前的版本，grpc的请求是很简单粗暴解析地址方法然后连接的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//v1.6之前
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TransGlobal</span><span class="p">)</span> <span class="nf">getURLResult</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">branchID</span><span class="p">,</span> <span class="nx">op</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">branchPayload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Protocol</span> <span class="o">==</span> <span class="s">&#34;grpc&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dtmimp</span><span class="p">.</span><span class="nf">PanicIf</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="s">&#34;http&#34;</span><span class="p">),</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;bad url for grpc: %s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">server</span><span class="p">,</span> <span class="nx">method</span> <span class="o">:=</span> <span class="nx">dtmgimp</span><span class="p">.</span><span class="nf">GetServerAndMethod</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">dtmgimp</span><span class="p">.</span><span class="nf">MustGetGrpcConn</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">dtmgimp</span><span class="p">.</span><span class="nf">TransInfo2Ctx</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">Gid</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">TransType</span><span class="p">,</span> <span class="nx">branchID</span><span class="p">,</span> <span class="nx">op</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">branchPayload</span><span class="p">,</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">dtmcli</span><span class="p">.</span><span class="nx">ResultSuccess</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">GetServerAndMethod</span><span class="p">(</span><span class="nx">grpcURL</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fs</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">grpcURL</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">server</span> <span class="o">:=</span> <span class="nx">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">method</span> <span class="o">:=</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">fs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">server</span><span class="p">,</span> <span class="nx">method</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>现在为了支持那些采用gRPC Resolver 机制之上的一些微服务框架接入，做了一块抽象。感兴趣可以看下，这里就不介绍了。</p>
<h3 id="sdk">SDK</h3>
<p>至于SDK，每一个事务模式都是独立的，本质上是没有关联的。比如下面我们启动一个TCC分布式事务。这个分布式事务是由两个服务组成，简称+30和-30的服务。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">gid</span> <span class="o">:=</span> <span class="nx">dtmcli</span><span class="p">.</span><span class="nf">MustGenGid</span><span class="p">(</span><span class="nx">DtmHttpServer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">dtmcli</span><span class="p">.</span><span class="nf">TccGlobalTransaction</span><span class="p">(</span><span class="nx">DtmHttpServer</span><span class="p">,</span> <span class="nx">gid</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">tcc</span> <span class="o">*</span><span class="nx">dtmcli</span><span class="p">.</span><span class="nx">Tcc</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">resty</span><span class="p">.</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tcc</span><span class="p">.</span><span class="nf">CallBranch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">TransReq</span><span class="p">{</span><span class="nx">Amount</span><span class="p">:</span> <span class="mi">30</span><span class="p">},</span> <span class="nx">Busi</span><span class="o">+</span><span class="s">&#34;/TransOut&#34;</span><span class="p">,</span> <span class="nx">Busi</span><span class="o">+</span><span class="s">&#34;/TransOutConfirm&#34;</span><span class="p">,</span> <span class="nx">Busi</span><span class="o">+</span><span class="s">&#34;/TransOutRevert&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">tcc</span><span class="p">.</span><span class="nf">CallBranch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">TransReq</span><span class="p">{</span><span class="nx">Amount</span><span class="p">:</span> <span class="mi">30</span><span class="p">},</span> <span class="nx">Busi</span><span class="o">+</span><span class="s">&#34;/TransIn&#34;</span><span class="p">,</span> <span class="nx">Busi</span><span class="o">+</span><span class="s">&#34;/TransInConfirm&#34;</span><span class="p">,</span> <span class="nx">Busi</span><span class="o">+</span><span class="s">&#34;/TransInRevert&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// dtm dtm服务器地址
</span></span></span><span class="line"><span class="cl"><span class="c1">// gid 全局事务id
</span></span></span><span class="line"><span class="cl"><span class="c1">// tccFunc tcc事务函数，里面会定义全局事务的分支
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">TccGlobalTransaction</span><span class="p">(</span><span class="nx">dtm</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">gid</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">tccFunc</span> <span class="nx">TccGlobalFunc</span><span class="p">)</span> <span class="p">(</span><span class="nx">rerr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tcc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Tcc</span><span class="p">{</span><span class="nx">TransBase</span><span class="p">:</span> <span class="o">*</span><span class="nx">dtmimp</span><span class="p">.</span><span class="nf">NewTransBase</span><span class="p">(</span><span class="nx">gid</span><span class="p">,</span> <span class="s">&#34;tcc&#34;</span><span class="p">,</span> <span class="nx">dtm</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rerr</span> <span class="p">=</span> <span class="nx">dtmimp</span><span class="p">.</span><span class="nf">TransCallDtm</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tcc</span><span class="p">.</span><span class="nx">TransBase</span><span class="p">,</span> <span class="nx">tcc</span><span class="p">,</span> <span class="s">&#34;prepare&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">rerr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">rerr</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 小概率情况下，prepare成功了，但是由于网络状况导致上面Failure，那么不执行下面defer的内容，等待超时后再回滚标记事务失败，也没有问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">x</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">operation</span> <span class="o">:=</span> <span class="nx">dtmimp</span><span class="p">.</span><span class="nf">If</span><span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">rerr</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;submit&#34;</span><span class="p">,</span> <span class="s">&#34;abort&#34;</span><span class="p">).(</span><span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">dtmimp</span><span class="p">.</span><span class="nf">TransCallDtm</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tcc</span><span class="p">.</span><span class="nx">TransBase</span><span class="p">,</span> <span class="nx">tcc</span><span class="p">,</span> <span class="nx">operation</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">rerr</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rerr</span> <span class="p">=</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">rerr</span> <span class="p">=</span> <span class="nf">tccFunc</span><span class="p">(</span><span class="nx">tcc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CallBranch call a tcc branch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Tcc</span><span class="p">)</span> <span class="nf">CallBranch</span><span class="p">(</span><span class="nx">body</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">tryURL</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">confirmURL</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cancelURL</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">resty</span><span class="p">.</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">branchID</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">NewSubBranchID</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">dtmimp</span><span class="p">.</span><span class="nf">TransRegisterBranch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">TransBase</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;data&#34;</span><span class="p">:</span>        <span class="nx">dtmimp</span><span class="p">.</span><span class="nf">MustMarshalString</span><span class="p">(</span><span class="nx">body</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;branch_id&#34;</span><span class="p">:</span>   <span class="nx">branchID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">BranchConfirm</span><span class="p">:</span> <span class="nx">confirmURL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">BranchCancel</span><span class="p">:</span>  <span class="nx">cancelURL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="s">&#34;registerTccBranch&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">dtmimp</span><span class="p">.</span><span class="nf">TransRequestBranch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">TransBase</span><span class="p">,</span> <span class="nx">body</span><span class="p">,</span> <span class="nx">branchID</span><span class="p">,</span> <span class="nx">BranchTry</span><span class="p">,</span> <span class="nx">tryURL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>从上面的调用中我们还是能还原出整体流程。</p>
<ul>
<li>调用TM，得到一个分布式id</li>
<li>调用TccGlobalTransaction函数开启分布式事务。</li>
<li>调用TM prepare(这步只是为了查看第一步产生的那个分布式事务状态是否处于prepare。这里没看明白，此时还未注册执行分支，全局状态不是应该只会存在初始化状态吗)</li>
<li>上一步没问题，执行传入的闭包函数，即CallBranch 函数里向TM注册参与事务的TM分支。注册完成后，开始第一阶段调用各分支的try服务。</li>
<li>各分支try服务调用结束，根据第一阶段结果决定通知TM是submit还是abort。</li>
</ul>
<p>代码还是很好懂的。</p>
<p>另外提一点，分布式事务常见的一些问题:比如空补偿、重挂等问题。</p>
<p>一般情况下，业务需要自行去处理这种场景，以免造成不可描述的错误。</p>
<p>dtm里面提供了对应子事务屏障方案。核心就在，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">  <span class="nx">originAffected</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">insertBarrier</span><span class="p">(</span><span class="nx">tx</span><span class="p">,</span> <span class="nx">ti</span><span class="p">.</span><span class="nx">TransType</span><span class="p">,</span> <span class="nx">ti</span><span class="p">.</span><span class="nx">Gid</span><span class="p">,</span> <span class="nx">ti</span><span class="p">.</span><span class="nx">BranchID</span><span class="p">,</span> <span class="nx">originType</span><span class="p">,</span> <span class="nx">bid</span><span class="p">,</span> <span class="nx">ti</span><span class="p">.</span><span class="nx">Op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">currentAffected</span><span class="p">,</span> <span class="nx">rerr</span> <span class="o">:=</span> <span class="nf">insertBarrier</span><span class="p">(</span><span class="nx">tx</span><span class="p">,</span> <span class="nx">ti</span><span class="p">.</span><span class="nx">TransType</span><span class="p">,</span> <span class="nx">ti</span><span class="p">.</span><span class="nx">Gid</span><span class="p">,</span> <span class="nx">ti</span><span class="p">.</span><span class="nx">BranchID</span><span class="p">,</span> <span class="nx">ti</span><span class="p">.</span><span class="nx">Op</span><span class="p">,</span> <span class="nx">bid</span><span class="p">,</span> <span class="nx">ti</span><span class="p">.</span><span class="nx">Op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dtmimp</span><span class="p">.</span><span class="nf">Logf</span><span class="p">(</span><span class="s">&#34;originAffected: %d currentAffected: %d&#34;</span><span class="p">,</span> <span class="nx">originAffected</span><span class="p">,</span> <span class="nx">currentAffected</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nx">ti</span><span class="p">.</span><span class="nx">Op</span> <span class="o">==</span> <span class="nx">BranchCancel</span> <span class="o">||</span> <span class="nx">ti</span><span class="p">.</span><span class="nx">Op</span> <span class="o">==</span> <span class="nx">BranchCompensate</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">originAffected</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="c1">// 这个是空补偿
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">currentAffected</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 这个是重复请求或者悬挂
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rerr</span> <span class="p">=</span> <span class="nf">busiCall</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
</span></span></code></pre></div><p>其实就是利用数据库的唯一索引机制，当然每个RM资源你都得新增一张表。</p>
<p>上面提到，dtm的TM角色本质上就是对应 seata 中的 TC，但是他们的处理模式是不同的。</p>
<p>dtm中的TM会根据注册时的各分支保存的地址，决定通过http还是rpc调用各RM操作，是由TM直接发起对RM的请求。</p>
<p>seata-go的实现中，TC是不参与直接调用RM的。</p>
<p>还记得上篇提到一个双向流RPC接口(BranchCommunicate)。TC通过这个接口把对应分支处理信息传递给RM管理器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// ........
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">switch</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">BranchMessageType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分支commit消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">case</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TypeBranchCommit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">request</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitRequest</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">data</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GetMessage</span><span class="p">().</span><span class="nf">GetValue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="nx">err</span> <span class="o">:=</span> <span class="nx">request</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">log</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="k">continue</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">response</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">manager</span><span class="p">.</span><span class="nf">BranchCommit</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">content</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">MarshalAny</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="nx">manager</span><span class="p">.</span><span class="nx">branchMessages</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchMessage</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">							<span class="nx">ID</span><span class="p">:</span>                <span class="nx">msg</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							<span class="nx">BranchMessageType</span><span class="p">:</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TypeBranchCommitResult</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							<span class="nx">Message</span><span class="p">:</span>           <span class="nx">content</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分支rollback消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">case</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">TypeBranchRollback</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//........
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//....
</span></span></span></code></pre></div><p>然后由RM管理器根据事务类型选择对应的事务管理器进行处理，最终调用的是对应事务类型管理器的BranchCommit方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 分支commit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">manager</span> <span class="nx">ResourceManager</span><span class="p">)</span> <span class="nf">BranchCommit</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">request</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rm</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">manager</span><span class="p">.</span><span class="nx">managers</span><span class="p">[</span><span class="nx">request</span><span class="p">.</span><span class="nx">BranchType</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">rm</span><span class="p">.</span><span class="nf">BranchCommit</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitResponse</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ResultCode</span><span class="p">:</span> <span class="nx">apis</span><span class="p">.</span><span class="nx">ResultCodeFailed</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Message</span><span class="p">:</span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;there is no resource manager for %s&#34;</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">BranchType</span><span class="p">.</span><span class="nf">String</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>下面是一个TCC事务类型管理器的处理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 只留核心代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">resourceManager</span> <span class="nx">TCCResourceManager</span><span class="p">)</span> <span class="nf">BranchCommit</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">request</span> <span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">apis</span><span class="p">.</span><span class="nx">BranchCommitResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">resource</span> <span class="o">:=</span> <span class="nx">resourceManager</span><span class="p">.</span><span class="nx">ResourceCache</span><span class="p">[</span><span class="nx">request</span><span class="p">.</span><span class="nx">ResourceID</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">resource</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tccResource</span> <span class="o">:=</span> <span class="nx">resource</span><span class="p">.(</span><span class="o">*</span><span class="nx">TCCResource</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">tccResource</span><span class="p">.</span><span class="nx">CommitMethod</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// .....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">result</span> <span class="o">:=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">businessActionContext</span> <span class="o">:=</span> <span class="nf">getBusinessActionContext</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">XID</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">BranchID</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">ResourceID</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">ApplicationData</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kd">interface</span><span class="p">{},</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">businessActionContext</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 最终执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">returnValues</span> <span class="o">:=</span> <span class="nx">proxy</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">tccResource</span><span class="p">.</span><span class="nx">CommitMethod</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>对应的事务RM管理器是如何通知、处理各个RM资源的。原理就是我上篇提到的作者实现的一个全局事务代理模式，本质上是利用go的反射实现的，感兴趣的可以自己去扒下源码，也可以看看作者对实现全局事务代理的介绍。</p>
<h3 id="总结">总结</h3>
<p>这篇文章主要介绍了dtm实现的一些细节，从这两篇文章大体能看出实现上的部分区别，更多的细节还得靠自己去挖掘。</p>
<p>最后再问几个问题，</p>
<ul>
<li>日常开发中你们哪些场景是用到了分布式事务？用的是哪个框架还是自研的？</li>
<li>或者说在分布式环境下，一致性的问题你们是如何解决的？</li>
</ul>
<h3 id="相关文章">相关文章</h3>
<ul>
<li><a href="https://dtm.pub/protocol/support.html">https://dtm.pub/protocol/support.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/351391359">https://zhuanlan.zhihu.com/p/351391359</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>channel原理解析(三)</title>
			<link>https://www.syst.top/posts/go/channel3/</link>
			<pubDate>Sun, 10 Oct 2021 21:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/channel3/</guid>
			<description>上一篇文章主要通过一个现实例子间接反映channel的一些原理。最后一篇开始介绍一些细节，会涉及到源码。
还是从一个简单的代码程序看起。
我们创建了一个无缓冲channel，然后往这个channel发送数据。因为程序中没有读操作ready，所以发送的时候会阻塞。我们通过汇编代码看它底层的调用。
从图中我们看到，上述发送操作，程序运行时实际调用的runtime.chansend1。
最终chansend1最终调用的还是chansend，chansend的第三个参数block是个bool值，表示操作channel不能立即成功时是否需要阻塞。
具体哪些操作？
 向无缓冲channel发送数据且当前无接收者ready。 接收无缓冲channel数据且当前无发送者ready。 缓冲channel已满，往channel发送数据。 缓冲channel为空，接收channel数据 向一个nil的channel发送数据。(注意，向一个nil的channel发送数据并不会引发panic)。 向一个nil的channel接收数据。  碰到上面的操作，如果不是特殊处理，我们的应用程序会被阻塞，直到被唤醒。
当然对于向nil的channel发送|接收数据，后续再也没机会被唤醒了。
那么如果是快速试错的场景，是不是只要把block改成false，在失败的场景下就不会被阻塞了。
编译这段代码。
可以看出，上面这段代码编译后调用selectnbsend最终发送动作调用的还是chansned，只是传入的block是false。这样一旦操作失败，程序不会被阻塞。
同理我们可以得出接收的调用动作。
到这里我们已经知道，
发送数据，最终调用的runtime.chansend。
接收数据，最终调用的runtime.chanrecv。
接下来我们来说明这两个函数底层是如何操作的。
我们还是以一个无缓冲的channel和缓冲channel来说明。
来看一段简单的程序。
值得一提的是，在Go中使用 go func的时候，本质上调用的是runtime.newproc创建一个g，然后把这个g交给调度器调度。至于什么时候g被调度，然后执行你的代码逻辑，那就要看调度器的&amp;quot;心情&amp;quot;了。
所以上面创建的两个g(暂且称为g1和g2)，可以看成是我们向调度器提交了两个任务g，我们无法保证哪个g会被先调度器调度执行，因此我们也不确定发送和接收这两个操作，谁会先被执行。
假设g1先被调度器运行，然后执行代码ch&amp;lt;-struct{}{}。
如果g2先被调度器运行，然后执行代码&amp;lt;-ch。
当然我们也可以把上面的代码换成画成详细的无缓冲队列核心流程图。
缓冲channel发送的时候分为三种情况，想想我们上篇文章快递员送快递场景。
 如果快递柜未满，直接把快递放入到快递柜。(对应缓冲区未满，把发送数据拷贝到缓冲区) 如果快递柜满了，那快递员只能在那等待快递柜空了。(对应把当前g封装成sudog，然后把sudog放到等待发送消息队列sendq中，最后挂起当前g) 如果送快递的时候正好客户在那里等，那就直接把快递给他就是了(对应如果发送的时候发现有等待者，直接数据拷贝给他呗)  我们来创建一个例子。
我们创建了一个缓冲区为7的channel。buffer就是用来存储缓冲元素的，它实际上是一个环形数组。为什么是环形的？因为这样就可以达到复用空间的效果。
此时没有发送接收动作，所以qcount为0，发送(sendx)和接收(recvx)的位置都为0。
我们来看上面的第一种情况。缓冲区未满，
这块代码就比较简单了。如果缓冲区未满，那就把当前要发送的数据拷贝到缓冲区的发送位置，然后发送位置sendx+1，然后当然channel个数qcount+1，整个流程就结束了。
如果缓冲满的情况下，封装当前g成sudog，把这个sudog入队等待发送队列，最后调用gopark挂起当前g，上面无缓冲的时候有提到。
最后一种情况，发送的时候正好有等待接收消息者，那么就从recvq中拿出最早开始等待的接受者，然后把发送的数据直接拷贝给他。
send整体有两个动作：拷贝数据&amp;mdash;&amp;ndash;&amp;gt;唤醒等待的recvq。
那么对于接收操作呢？
 快递柜里有我的快递，那我直接拿就行了。(对应缓冲区有数据，根据读recvx的位置拿数据) 快递柜还没我的快递，但是快递哥打电话说快到了，那我现在楼下转转。(对应缓冲区无数据，把当前g封装成sudog,然后放入到等待接收消息队列recvq中)。 去拿一个快递的时候，正好一个快递员放我另一个快递的时候因为快递柜满了，在那等着。(对应缓冲区满了，且还有等待发送者。此时先到缓冲区获取当前读recvx位置的数据，然后再从等待发送者队列中取出最早等待的发送者，把他要发送的数据拷贝拷贝到当前我读取数据的位置(保证先入先出的顺序)，最后更新发送位置和更新位置即可)。  第一种情况就简单了。直接通过当前读位置recvx读取buffer对应的值，这里还需要通过判断是否忽略返回值，而决定需不需要往当前接收操作拷贝数据。然后移动recvx位置，元素个数qcount-- ，最后解锁即可。
第二种情况，封装当前g成sudog，把这个sudog入队等待接收队列，最后调用gopark挂起当前g。上面无缓冲的时候画过这个逻辑。
第三种情况有点复杂。
这种情况下，当获取到一个等待发送者，对于接收者来说，如果我们直接拿它的发送数据返回会发生什么？举个例子
上图，channel满了，且sendq有一个等待发送者(假设是G8，发送数据为800)，此时执行接收操作，也就出现上述第三种情况。
如果此时我们直接拿G8的数据，那么数据就不能保证先入先出了。
所以正确的操作是，读取当前recvx位置(0)buffer值100，然后把G8的数据800拷贝到0的位置，最后把recvq的位置向前移动，同步发送位置sendx等于recvq。这里，可以思考下为啥？
到这里缓冲channel的核心流程就说完了。如图，
另外后台回复channel有我准备的一个小ppt，可以跟着一起看。</description>
			<content type="html"><![CDATA[<p>上一篇文章主要通过一个现实例子间接反映<code>channel</code>的一些原理。最后一篇开始介绍一些细节，会涉及到源码。</p>
<p>还是从一个简单的代码程序看起。</p>
<p><img src="https://cdn.syst.top/12-1.png" alt="image-20211012211523725"></p>
<p>我们创建了一个无缓冲<code>channel</code>，然后往这个<code>channel</code>发送数据。因为程序中没有读操作<code>ready</code>，所以发送的时候会阻塞。我们通过汇编代码看它底层的调用。</p>
<p><img src="https://cdn.syst.top/12-2.png" alt="image-20211012211523725"></p>
<p>从图中我们看到，上述发送操作，程序运行时实际调用的<code>runtime.chansend1</code>。</p>
<p><img src="https://cdn.syst.top/12-3.png" alt="image-20211012211523725"></p>
<p>最终<code>chansend1</code>最终调用的还是<code>chansend</code>，<code>chansend</code>的第三个参数<code>block</code>是个<code>bool</code>值，表示操作<code>channel</code>不能立即成功时是否需要阻塞。</p>
<p>具体哪些操作？</p>
<ul>
<li>向无缓冲<code>channel</code>发送数据且当前无接收者<code>ready</code>。</li>
<li>接收无缓冲<code>channel</code>数据且当前无发送者<code>ready</code>。</li>
<li>缓冲<code>channel</code>已满，往<code>channel</code>发送数据。</li>
<li>缓冲<code>channel</code>为空，接收<code>channel</code>数据</li>
<li>向一个<code>nil</code>的<code>channel</code>发送数据。(注意，向一个<code>nil</code>的<code>channel</code>发送数据并不会引发<code>panic</code>)。</li>
<li>向一个<code>nil</code>的<code>channel</code>接收数据。</li>
</ul>
<p>碰到上面的操作，如果不是特殊处理，我们的应用程序会被阻塞，直到被唤醒。</p>
<p>当然对于向<code>nil</code>的<code>channel</code>发送|接收数据，后续再也没机会被唤醒了。</p>
<p>那么如果是快速试错的场景，是不是只要把<code>block</code>改成<code>false</code>，在失败的场景下就不会被阻塞了。</p>
<p>编译这段代码。</p>
<p><img src="https://cdn.syst.top/12-4.png" alt="image-20211012215229617"></p>
<p><img src="https://cdn.syst.top/12-5.png" alt="image-20211012215229617"></p>
<p><img src="https://cdn.syst.top/12-6.png" alt="12-6"></p>
<p>可以看出，上面这段代码编译后调用<code>selectnbsend</code>最终发送动作调用的还是<code>chansned</code>，只是传入的<code>block</code>是<code>false</code>。这样一旦操作失败，程序不会被阻塞。</p>
<p>同理我们可以得出接收的调用动作。</p>
<p><img src="https://cdn.syst.top/12-7.png" alt="12-6"></p>
<p><img src="https://cdn.syst.top/12-8.png" alt="12-6"></p>
<p><img src="https://cdn.syst.top/12-9.png" alt="12-6"></p>
<p><img src="https://cdn.syst.top/12-10.png" alt="12-6"></p>
<p>到这里我们已经知道，</p>
<p>发送数据，最终调用的<code>runtime.chansend</code>。</p>
<p>接收数据，最终调用的<code>runtime.chanrecv</code>。</p>
<p>接下来我们来说明这两个函数底层是如何操作的。</p>
<p>我们还是以一个无缓冲的<code>channel</code>和缓冲<code>channel</code>来说明。</p>
<p>来看一段简单的程序。</p>
<p><img src="https://cdn.syst.top/12-11.png" alt="image-20211012221535539"></p>
<p>值得一提的是，在Go中使用 <code>go func</code>的时候，本质上调用的是<code>runtime.newproc</code>创建一个<code>g</code>，然后把这个<code>g</code>交给调度器调度。至于什么时候<code>g</code>被调度，然后执行你的代码逻辑，那就要看调度器的&quot;心情&quot;了。</p>
<p>所以上面创建的两个<code>g</code>(暂且称为g1和g2)，可以看成是我们向调度器提交了两个任务<code>g</code>，我们无法保证哪个<code>g</code>会被先调度器调度执行，因此我们也不确定发送和接收这两个操作，谁会先被执行。</p>
<p>假设<code>g1</code>先被调度器运行，然后执行代码<code>ch&lt;-struct{}{}</code>。</p>
<p><img src="https://cdn.syst.top/12-11-2.png" alt="image-20211012223319977"></p>
<p>如果<code>g2</code>先被调度器运行，然后执行代码<code>&lt;-ch</code>。</p>
<p><img src="https://cdn.syst.top/12-13.png" alt="image-20211012230756372"></p>
<p>当然我们也可以把上面的代码换成画成详细的无缓冲队列核心流程图。</p>
<p><img src="https://cdn.syst.top/12-12.jpg" alt="12-12"></p>
<p>缓冲<code>channel</code>发送的时候分为三种情况，想想我们上篇文章快递员送快递场景。</p>
<ul>
<li>如果快递柜未满，直接把快递放入到快递柜。(对应缓冲区未满，把发送数据拷贝到缓冲区)</li>
<li>如果快递柜满了，那快递员只能在那等待快递柜空了。(对应把当前<code>g</code>封装成<code>sudog</code>，然后把sudog放到等待发送消息队列<code>sendq</code>中，最后挂起当前<code>g</code>)</li>
<li>如果送快递的时候正好客户在那里等，那就直接把快递给他就是了(对应如果发送的时候发现有等待者，直接数据拷贝给他呗)</li>
</ul>
<p>我们来创建一个例子。</p>
<p><img src="https://cdn.syst.top/12-14.png" alt="12-14"></p>
<p>我们创建了一个缓冲区为7的<code>channel</code>。<code>buffer</code>就是用来存储缓冲元素的，它实际上是一个环形数组。为什么是环形的？因为这样就可以达到复用空间的效果。</p>
<p>此时没有发送接收动作，所以<code>qcount</code>为0，发送(<code>sendx</code>)和接收(<code>recvx</code>)的位置都为0。</p>
<p>我们来看上面的第一种情况。缓冲区未满，</p>
<p><img src="https://cdn.syst.top/12-27.png" alt="12-15"></p>
<p>这块代码就比较简单了。如果缓冲区未满，那就把当前要发送的数据拷贝到缓冲区的发送位置，然后发送位置<code>sendx+1</code>，然后当然<code>channel</code>个数<code>qcount+1</code>，整个流程就结束了。</p>
<p>如果缓冲满的情况下，封装当前<code>g</code>成<code>sudog</code>，把这个<code>sudog</code>入队等待发送队列，最后调用<code>gopark</code>挂起当前<code>g</code>，上面无缓冲的时候有提到。</p>
<p>最后一种情况，发送的时候正好有等待接收消息者，那么就从<code>recvq</code>中拿出最早开始等待的接受者，然后把发送的数据直接拷贝给他。</p>
<p><img src="https://cdn.syst.top/12-28.png" alt="image-20211015002454895"></p>
<p><img src="https://cdn.syst.top/12-29.png" alt="image-20211014224054936"></p>
<p><code>send</code>整体有两个动作：拷贝数据&mdash;&ndash;&gt;唤醒等待的<code>recvq</code>。</p>
<p>那么对于接收操作呢？</p>
<ul>
<li>快递柜里有我的快递，那我直接拿就行了。(对应缓冲区有数据，根据读<code>recvx</code>的位置拿数据)</li>
<li>快递柜还没我的快递，但是快递哥打电话说快到了，那我现在楼下转转。(对应缓冲区无数据，把当前<code>g</code>封装成<code>sudog</code>,然后放入到等待接收消息队列<code>recvq</code>中)。</li>
<li>去拿一个快递的时候，正好一个快递员放我另一个快递的时候因为快递柜满了，在那等着。(对应缓冲区满了，且还有等待发送者。此时先到缓冲区获取当前读<code>recvx</code>位置的数据，然后再从等待发送者队列中取出最早等待的发送者，把他要发送的数据拷贝拷贝到当前我读取数据的位置(保证先入先出的顺序)，最后更新发送位置和更新位置即可)。</li>
</ul>
<p>第一种情况就简单了。直接通过当前读位置<code>recvx</code>读取<code>buffer</code>对应的值，这里还需要通过判断是否忽略返回值，而决定需不需要往当前接收操作拷贝数据。然后移动<code>recvx</code>位置，元素个数<code>qcount--</code> ，最后解锁即可。</p>
<p><img src="https://cdn.syst.top/12-30.png" alt="image-20211014224602030"></p>
<p>第二种情况，封装当前<code>g</code>成<code>sudog</code>，把这个<code>sudog</code>入队等待接收队列，最后调用<code>gopark</code>挂起当前<code>g</code>。上面无缓冲的时候画过这个逻辑。</p>
<p>第三种情况有点复杂。</p>
<p><img src="https://cdn.syst.top/12-31.png" alt="image-20211014230147629"></p>
<p>这种情况下，当获取到一个等待发送者，对于接收者来说，如果我们直接拿它的发送数据返回会发生什么？举个例子</p>
<p><img src="https://cdn.syst.top/12-32.png" alt="image-20211014230147629"></p>
<p>上图，<code>channel</code>满了，且<code>sendq</code>有一个等待发送者(假设是<code>G8</code>，发送数据为<code>800</code>)，此时执行接收操作，也就出现上述第三种情况。</p>
<p>如果此时我们直接拿<code>G8</code>的数据，那么数据就不能保证先入先出了。</p>
<p>所以正确的操作是，读取当前<code>recvx</code>位置(0)<code>buffer</code>值<code>100</code>，然后把<code>G8</code>的数据800拷贝到0的位置，最后把<code>recvq</code>的位置向前移动，同步发送位置<code>sendx</code>等于<code>recvq</code>。这里，可以思考下为啥？</p>
<p>到这里缓冲<code>channel</code>的核心流程就说完了。如图，</p>
<p><img src="https://cdn.syst.top/12-33.jpg" alt="image-20211014230147629"></p>
<p>另外后台回复<code>channel</code>有我准备的一个小<code>ppt</code>，可以跟着一起看。</p>
]]></content>
		</item>
		
		<item>
			<title>channel原理解析(二)</title>
			<link>https://www.syst.top/posts/go/channel2/</link>
			<pubDate>Sun, 10 Oct 2021 21:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/channel2/</guid>
			<description>上一篇文章主要介绍channel运行时是通过hchan表示的，也简单说明了hchan各个字段的含义。
我们提到，对channel的操作，本质上就是对hchan里字段的操作。因为在操作的过程中使用了互斥锁，所以保证了channel的并发安全。
这篇文章主要通过现实生活的一些例子来说明channel的一些原理，当然还是不会涉及过多源码。
无缓冲 我们都知道，channel分为无缓冲和缓冲。这两者最大的区别是什么？
我们用一个现实生活的快递例子来说明。
上面场景是快递员在等小库，当然反过来小库也可能在等快递员。
如果没有快递柜，快递员在送快递的过程中，如果家里没人，他就得在那等着，等着有人来签收快递，他才送货结束。
客户在快递员到来之前，他也不能离开家，不然快递来了没人收，所以他也得等到快递员上门，签字收了快递，他才算收货结束。
当然，客户不止有这家快递，如果快递员A在等的时候又来一个快递员B给他送货。这个快递员B不仅得等着，还得排队。等到客户到家后，肯定是先签收A的快递，然后再签收B的快递。
对应到无缓冲channel，
发送数据的时候，如果没有对应的接收者ready，那么发送者就进入到等待发送队列中，等待有对应的接收者唤醒它。
接收数据的时候，如果没有对应的发送者ready，那么接收者就进入到等待接收队列中，等待有对应的发送者唤醒它。
还记得上一篇文章我们介绍过hchan的结构吗。
其中recvq 表示等待接收消息的队列，sendq表示等待发送消息的队列。
我们来看waitq。
本质上waitq就是一个链表，更确切的说是一个双向循环的链表。其中waitq记录了链表的头尾，sudog记录了当前等待者的上一个等待者(prev)和下一个等待者(next)。
这就好像小库在签收完A的快递后喊，下一个是谁啊？
A会说:我的下一个是B。
B会说:是我。我记得我上一个是A，目前我没有下一个，所以我是最后一个。
缓冲 看完了无缓冲队列，我们再来看缓冲队列。还是用上面的故事，
只要快递柜有空闲柜子，快递员就可以直接把快递放到柜子里，让客户自己去柜子拿。如果发送没有空闲的柜子，那就只能等，等到别人告诉我有空闲柜子，我再把快递放到空出来的柜子里。
对应到缓冲channel，上面的快递柜，就是缓冲channel中存储数据的buffer。
对于发送者来说：只要缓冲区未满，发送者就可以继续发送数据存放在缓冲区。一旦缓冲区满了，发送者就只能进入到等待发送队列中，等待有对应的接收者唤醒它，然后它再把数据放入到刚刚被取走数据的位置。
对于接收者来说：只要缓冲区不为空，接收者就可以继续接收数据。一旦缓冲区空了，那么接收者就只能进入到等待接收队列中，等待有对应的发送者唤醒它。
上面还有什么问题吗？还真有。
我们取快递的时候，你一定会按照快递放入到快递柜的先后顺序取快递吗？咋么可能。
但是在channel中，是会保证消息的先进先出(FIFO)关系的。至于咋么保证的，我们终结篇解析代码细节的时候再说。
总结 这篇文章主要通过一个快递的例子来介绍channel操作的原理。下一篇我们介绍channel针对上述处理的细节逻辑。</description>
			<content type="html"><![CDATA[<p>上一篇文章主要介绍<code>channel</code>运行时是通过<code>hchan</code>表示的，也简单说明了<code>hchan</code>各个字段的含义。</p>
<p>我们提到，对<code>channel</code>的操作，本质上就是对<code>hchan</code>里字段的操作。因为在操作的过程中使用了互斥锁，所以保证了<code>channel</code>的并发安全。</p>
<p>这篇文章主要通过现实生活的一些例子来说明<code>channel</code>的一些原理，当然还是不会涉及过多源码。</p>
<h3 id="无缓冲">无缓冲</h3>
<p>我们都知道，<code>channel</code>分为无缓冲和缓冲。这两者最大的区别是什么？</p>
<p>我们用一个现实生活的快递例子来说明。</p>
<p><img src="https://cdn.syst.top/%E6%88%AA%E5%B1%8F2021-10-10%20%E4%B8%8B%E5%8D%8810.38.35.png" alt="image"></p>
<p>上面场景是快递员在等小库，当然反过来小库也可能在等快递员。</p>
<p><img src="https://cdn.syst.top/%E6%88%AA%E5%B1%8F2021-10-10%20%E4%B8%8B%E5%8D%8810.47.13.png" alt="image"></p>
<p>如果没有快递柜，快递员在送快递的过程中，如果家里没人，他就得在那等着，等着有人来签收快递，他才送货结束。</p>
<p>客户在快递员到来之前，他也不能离开家，不然快递来了没人收，所以他也得等到快递员上门，签字收了快递，他才算收货结束。</p>
<p>当然，客户不止有这家快递，如果快递员A在等的时候又来一个快递员B给他送货。这个快递员B不仅得等着，还得排队。等到客户到家后，肯定是先签收A的快递，然后再签收B的快递。</p>
<p>对应到无缓冲<code>channel</code>，</p>
<p>发送数据的时候，如果没有对应的接收者<code>ready</code>，那么发送者就进入到等待发送队列中，等待有对应的接收者唤醒它。</p>
<p>接收数据的时候，如果没有对应的发送者<code>ready</code>，那么接收者就进入到等待接收队列中，等待有对应的发送者唤醒它。</p>
<p>还记得上一篇文章我们介绍过<code>hchan</code>的结构吗。</p>
<p><img src="https://cdn.syst.top/hchan.png" alt="image"></p>
<p>其中<code>recvq</code> 表示等待接收消息的队列，<code>sendq</code>表示等待发送消息的队列。</p>
<p>我们来看<code>waitq</code>。</p>
<p><img src="/Users/wuqinqiang/Desktop/waitq.png" alt="image-20211010230421470"></p>
<p><img src="/Users/wuqinqiang/Desktop/sudog.png" alt="image-20211010230607222"></p>
<p>本质上<code>waitq</code>就是一个链表，更确切的说是一个双向循环的链表。其中<code>waitq</code>记录了链表的头尾，<code>sudog</code>记录了当前等待者的上一个等待者(<code>prev</code>)和下一个等待者(<code>next</code>)。</p>
<p>这就好像小库在签收完A的快递后喊，下一个是谁啊？</p>
<p>A会说:我的下一个是B。</p>
<p>B会说:是我。我记得我上一个是A，目前我没有下一个，所以我是最后一个。</p>
<h3 id="缓冲">缓冲</h3>
<p>看完了无缓冲队列，我们再来看缓冲队列。还是用上面的故事，</p>
<p><img src="/Users/wuqinqiang/Desktop/Xnip2021-10-10_23-40-05.jpg" alt="Xnip2021-10-10_23-40-05"></p>
<p>只要快递柜有空闲柜子，快递员就可以直接把快递放到柜子里，让客户自己去柜子拿。如果发送没有空闲的柜子，那就只能等，等到别人告诉我有空闲柜子，我再把快递放到空出来的柜子里。</p>
<p>对应到缓冲<code>channel</code>，上面的快递柜，就是缓冲<code>channel</code>中存储数据的<code>buffer</code>。</p>
<p>对于发送者来说：只要缓冲区未满，发送者就可以继续发送数据存放在缓冲区。一旦缓冲区满了，发送者就只能进入到等待发送队列中，等待有对应的接收者唤醒它，然后它再把数据放入到刚刚被取走数据的位置。</p>
<p>对于接收者来说：只要缓冲区不为空，接收者就可以继续接收数据。一旦缓冲区空了，那么接收者就只能进入到等待接收队列中，等待有对应的发送者唤醒它。</p>
<p>上面还有什么问题吗？还真有。</p>
<p>我们取快递的时候，你一定会按照快递放入到快递柜的先后顺序取快递吗？咋么可能。</p>
<p>但是在<code>channel</code>中，是会保证消息的先进先出(FIFO)关系的。至于咋么保证的，我们终结篇解析代码细节的时候再说。</p>
<h3 id="总结">总结</h3>
<p>这篇文章主要通过一个快递的例子来介绍<code>channel</code>操作的原理。下一篇我们介绍<code>channel</code>针对上述处理的细节逻辑。</p>
]]></content>
		</item>
		
		<item>
			<title>对CAP理论的理解</title>
			<link>https://www.syst.top/posts/go/dtm/</link>
			<pubDate>Sun, 10 Oct 2021 21:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/dtm/</guid>
			<description>介绍 最近经常看到有人发一个Go实现的分布式事务管理器，看到star增的挺猛的，索性看看代码实现，毕竟工作中部分场景也用的上。
在写源码分析之前，我们来简单了解一些概念型的东西。
CAP 分布式系统中很大的一个难点在于各个节点之间的状态如何同步，CAP就是分布式系统领域一条已经被证明的定律。
其中各个字母的含义如下，
 Consistency(一致性) Availability(可用性) Partition tolerance(分区容忍性)  下面我们用一些简单的例子来说明。
假设我们的系统是由两个服务组成的:G1和G2。
G1和G2维护了同一条记录V0。G1和G2可以相互通信，外部客户端(Client)可以调用任意一个服务。
当一个客户端对任意一个服务发起读|写请求，那么被请求的那个服务器根据客户端的请求，处理、响应结果。
比如客户端向G1发起一个读操作，客户端G1响应请求。
又比如客户端向G1发起一个写操作，把V0修改成V1。
Consistency(一致性) 这个一致性和事务中ACID中的C还是有区别的。事务中的C更多是指在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这里的完整性包括一些外键约束、键的唯一性等。
而分布式事务中的C指的是，写操作之后的读操作，必须返回该值，这就等同于所有节点访问的是同一份最新数据的副本。
下面是一个非一致性的例子。
客户端成功请求G1服务器写V1。由于网络分区，导致G1数据不能同步到G2，此时客户端从G2读取数据，依旧返回V0。
来看一个满足一致性的例子。
在这个系统中，G1收到客户端写V1的操作，G1在修改自身数据的同时，会把V1数据同步到G2。G1在收到G2的响应后，才向客户端响应结果。这样，之后无论客户端从哪个节点读取数据，都能获取到V1值。
Availability(可用性) 可用性指的是系统中非故障节点接收到的每一个请求都必须响应。
在一个可用的系统中，如果客户端向服务器发送一个请求，那么服务器必须响应客户端每一个请求，不允许忽略客户端请求。
Partition Tolerance(分区容忍性) 什么分区？
 网络分区。
 网络分区咋么理解？
 假设有两台服务器A和B，本来他们两是正常通信的，不知道啥原因，他们之间的网络链接断开，导致无法正常通信。此时本来在同一个网络的AB，发生了网络分区。变成了A所在的A网络和B所在的B网络。这就是网络分区。
 容忍性是指什么？
 当一个服务的多台服务器发生上述网络分区的时候，系统依旧能正常提供服务。
 对CAP的误解 网上很多文章都是这么说的：
 一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项，这被称为CAP定律。
 似乎CAP被解释成一种三选二的定律。
看到一篇文章CAP Twelve Years Later: How the &amp;quot;Rules&amp;quot; Have Changed有一段CAP的完整表述：
 The CAP theorem asserts that any net­worked shared-data system can have only two of three desirable properties。</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>最近经常看到有人发一个Go实现的分布式事务管理器，看到star增的挺猛的，索性看看代码实现，毕竟工作中部分场景也用的上。</p>
<p>在写源码分析之前，我们来简单了解一些概念型的东西。</p>
<h3 id="cap">CAP</h3>
<p>分布式系统中很大的一个难点在于各个节点之间的状态如何同步，CAP就是分布式系统领域一条已经被证明的定律。</p>
<p>其中各个字母的含义如下，</p>
<ul>
<li><strong>C</strong>onsistency(一致性)</li>
<li><strong>A</strong>vailability(可用性)</li>
<li><strong>P</strong>artition tolerance(分区容忍性)</li>
</ul>
<p>下面我们用一些简单的例子来说明。</p>
<p><img src="https://cdn.syst.top/dtm01.svg" alt="dtm01"></p>
<p>假设我们的系统是由两个服务组成的:G1和G2。</p>
<p>G1和G2维护了同一条记录V0。G1和G2可以相互通信，外部客户端(Client)可以调用任意一个服务。</p>
<p>当一个客户端对任意一个服务发起读|写请求，那么被请求的那个服务器根据客户端的请求，处理、响应结果。</p>
<p>比如客户端向G1发起一个读操作，客户端G1响应请求。</p>
<p><img src="https://cdn.syst.top/dtm02.png" alt="dtm01"></p>
<p>又比如客户端向G1发起一个写操作，把V0修改成V1。</p>
<p><img src="https://cdn.syst.top/dtm03.png" alt="dtm01"></p>
<h4 id="consistency一致性">Consistency(一致性)</h4>
<p>这个一致性和事务中ACID中的C还是有区别的。事务中的C更多是指在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这里的完整性包括一些外键约束、键的唯一性等。</p>
<p>而分布式事务中的C指的是，写操作之后的读操作，必须返回该值，这就等同于所有节点访问的是同一份最新数据的副本。</p>
<p>下面是一个非一致性的例子。</p>
<p><img src="https://cdn.syst.top/dtm04.png" alt="dtm01"></p>
<p>客户端成功请求G1服务器写V1。由于网络分区，导致G1数据不能同步到G2，此时客户端从G2读取数据，依旧返回V0。</p>
<p>来看一个满足一致性的例子。</p>
<p><img src="https://cdn.syst.top/dtm05.png" alt="dtm01"></p>
<p>在这个系统中，G1收到客户端写V1的操作，G1在修改自身数据的同时，会把V1数据同步到G2。G1在收到G2的响应后，才向客户端响应结果。这样，之后无论客户端从哪个节点读取数据，都能获取到V1值。</p>
<h4 id="availability可用性">Availability(可用性)</h4>
<p>可用性指的是系统中非故障节点接收到的每一个请求都必须响应。</p>
<p>在一个可用的系统中，如果客户端向服务器发送一个请求，那么服务器必须响应客户端每一个请求，不允许忽略客户端请求。</p>
<h4 id="partition-tolerance分区容忍性">Partition Tolerance(分区容忍性)</h4>
<p>什么分区？</p>
<blockquote>
<p>网络分区。</p>
</blockquote>
<p>网络分区咋么理解？</p>
<blockquote>
<p>假设有两台服务器A和B，本来他们两是正常通信的，不知道啥原因，他们之间的网络链接断开，导致无法正常通信。此时本来在同一个网络的AB，发生了网络分区。变成了A所在的A网络和B所在的B网络。这就是网络分区。</p>
</blockquote>
<p>容忍性是指什么？</p>
<blockquote>
<p>当一个服务的多台服务器发生上述网络分区的时候，系统依旧能正常提供服务。</p>
</blockquote>
<h3 id="对cap的误解">对CAP的误解</h3>
<p>网上很多文章都是这么说的：</p>
<blockquote>
<p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项，这被称为CAP定律。</p>
</blockquote>
<p>似乎CAP被解释成一种三选二的定律。</p>
<p>看到一篇文章<code>CAP Twelve Years Later: How the &quot;Rules&quot; Have Changed</code>有一段CAP的完整表述：</p>
<blockquote>
<p>The CAP theorem asserts that any net­worked shared-data system can have only two of three desirable properties。</p>
</blockquote>
<p>按照表述，发现网上这句话存在一定的误导性。</p>
<p>CAP定律的前提是P(网络分区)，出现P之后才会有CA的选择。</p>
<p>当P发生的时候，而我们的系统直接不服务了，那就不存在选择什么CA了。</p>
<p>因此CAP的正常理解应该是：当P(网络分区)发生的时候，如果我们要继续提供服务，那么C(强一致性)和A(可用性)只能2选1了。</p>
<h3 id="consistency和availability的矛盾">Consistency和Availability的矛盾</h3>
<p>为什么当P发生时，CA只能二选一？</p>
<p>还是之前那个简单的例子。</p>
<p>假设此时G1和G2发生了网络分区。</p>
<p><img src="https://cdn.syst.top/dtm01.svg" alt="dtm01"></p>
<p>接下来我们的客户端请求G1写V1数据。由于分区，G1不能同步数据到G2。</p>
<p><img src="https://cdn.syst.top/dtm06.png" alt="dtm01"></p>
<p><img src="https://cdn.syst.top/dtm07.png" alt=""></p>
<p>如果我们保证G2的可用性，那么当客户端请求G2数据的时候，G2能正常响应V0数据，数据不一致。</p>
<p>如果我们保证G2的一致性，那么在G1写操作的时候，需要锁定G2的读写操作，此时G2不可用。</p>
<p>因此，Consistency和Availability存在矛盾。</p>
<h3 id="参考">参考</h3>
<ul>
<li>
<p><a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/">https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/</a></p>
</li>
<li>
<p><a href="https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/">https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/</a></p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/64778723">https://www.zhihu.com/question/64778723</a></p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>超实用的 gRPC 客户端调试工具</title>
			<link>https://www.syst.top/posts/go/grpc/</link>
			<pubDate>Tue, 27 Jul 2021 10:01:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/grpc/</guid>
			<description>介绍 正好看到董泽润老哥写了一篇关于使用 WireShark 分析 gRPC 流量的文章，学到了。
那我就介绍两个日常开发使用过的两款 gRPC 客户端调试工具吧。
Evans Evans 有两种模式：REPL 和 CLI。比起其他 gRPC 客户端,更具有表现力。并且它还支持自动补全功能。
它的安装非常方便，在 Mac 上我们只需要执行以下两行命令即可。
$ brew tap ktr0731/evans $ brew install evans 我们来操作一下 REPL 模式。
首先我们需要有一个 pb 文件，假设你的文件在 api/api.proto，我们只需要这样： 默认地址为 127.0.0.1:50051，当然你可以通过 --host 和 --port 来指定服务器。 上图的命令:
 show package 读取 pb 包名， show service 显示对应服务列表。 call xxx 调用 grpc 服务&amp;hellip;&amp;hellip; &amp;hellip;..  更多命令可自行查阅官网。
除了上述这种直接引入 pb 文件外，我们还可以通过 gRPC 反射包(reflection)， 将 grpc.Server 注册到反射服务中, 这样的话，就可以通过 reflection 提供的反射服务查询到对应的 gRPC 服务或者调用 gRPC 服务。</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>正好看到董泽润老哥写了一篇关于使用 <code>WireShark</code> 分析 <code>gRPC</code> 流量的文章，学到了。</p>
<p>那我就介绍两个日常开发使用过的两款 <code>gRPC</code> 客户端调试工具吧。</p>
<h2 id="evans">Evans</h2>
<p><code>Evans</code> 有两种模式：<code>REPL</code> 和 <code>CLI</code>。比起其他 <code>gRPC</code> 客户端,更具有表现力。并且它还支持自动补全功能。</p>
<p>它的安装非常方便，在 <code>Mac</code> 上我们只需要执行以下两行命令即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="err">$</span> <span class="nx">brew</span> <span class="nx">tap</span> <span class="nx">ktr0731</span><span class="o">/</span><span class="nx">evans</span>
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="nx">brew</span> <span class="nx">install</span> <span class="nx">evans</span>
</span></span></code></pre></div><p>我们来操作一下 <code>REPL</code> 模式。</p>
<p>首先我们需要有一个 <code>pb</code> 文件，假设你的文件在 <code>api/api.proto</code>，我们只需要这样：
<img src="https://image.syst.top/image/grpc/1.gif" alt="image"></p>
<p>默认地址为 <code>127.0.0.1:50051</code>，当然你可以通过 <code>--host</code> 和 <code>--port</code> 来指定服务器。
<img src="https://image.syst.top/image/grpc/2.png" alt="image"></p>
<p>上图的命令:</p>
<ul>
<li><code>show package</code> 读取 <code>pb</code> 包名，</li>
<li><code>show service</code> 显示对应服务列表。</li>
<li><code>call xxx</code> 调用 <code>grpc</code> 服务&hellip;&hellip;</li>
<li>&hellip;..</li>
</ul>
<p>更多命令可自行查阅官网。</p>
<p>除了上述这种直接引入 <code>pb</code> 文件外，我们还可以通过 <code>gRPC</code> 反射包(<code>reflection</code>)， 将 <code>grpc.Server</code> 注册到反射服务中,
这样的话，就可以通过 <code>reflection</code> 提供的反射服务查询到对应的 <code>gRPC</code> 服务或者调用 <code>gRPC</code> 服务。</p>
<p>操作起来很简单，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;google.golang.org/grpc/reflection&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">grpcServer</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reflection</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">grpcServer</span><span class="p">)</span>
</span></span></code></pre></div><p>回到 <code>Evans</code> 工具， 如果一个 <code>gRPC</code> 服务启动了反射，我们就可以使用 <code>-r (--reflection)</code> 选项来启动 <code>Evans</code>。</p>
<p>比如像下面这样：
<img src="https://image.syst.top/image/grpc/3.gif" alt="image"></p>
<h3 id="bloomrpc">BloomRPC</h3>
<p><code>BloomRPC</code> 是一个简单的<code>GUI</code> 客户端工具，使用这个那就更简单了。</p>
<p>只需要导入 <code>pb</code> 文件，然后点两下即可。
<img src="https://image.syst.top/image/grpc/4.gif" alt="image"></p>
<p>当然有个不好点在于，每次修改了 <code>pb</code>，都不得不重新导入。</p>
<h3 id="总结">总结</h3>
<p>以上介绍了两款 <code>gRPC</code> 客户端工具。不知道你们平常都使用 <code>gRPC</code> 哪些周边工具，欢迎一起讨论。当然调试工具再好，改写的 <code>test</code> 还是逃不了。</p>
]]></content>
		</item>
		
		<item>
			<title>go并发-工作池模式</title>
			<link>https://www.syst.top/posts/go/worker-pool/</link>
			<pubDate>Thu, 01 Jul 2021 23:37:45 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/worker-pool/</guid>
			<description>开篇 之前写过一篇文章，它有个响亮的名字: Handling 1 Million Requests per Minute with Go。 这是国外的一个作者写的，我做了一篇说明。起的也是这个标题， 阅读量是我最好的一篇，果然文章都是靠标题出彩的&amp;hellip;..
今天偶然看到另一篇文章(原文在文末)。两篇文章原理相似:有一批工作任务(job)，通过工作池(worker-pool)的方式，达到多 worker 并发处理 job 的效果。
他们还是有很多不同的点，实现上差别也是蛮大的。
首先上一篇文章我放了一张图片，大概就是上篇整体的工作流。  每个 worker 处理完任务就好，不关心结果,不对结果做进一步处理。 只要请求不停止，程序就不会停止，没有控制机制，除非宕机。  这篇文章不同点在于:
首先数据会从 generate (生产数据)-&amp;gt;并发处理数据-&amp;gt;处理结果聚合。 图大概是这样的, 然后它可以通过 context.context 达到控制工作池停止工作的效果。
最后通过代码，你会发现它不是传统意义上的 worker-pool，后面会说明。
下图能清晰表达整体流程了。 顺便说一句，这篇文章实现的代码比 Handling 1 Million Requests per Minute with Go 的代码简单多了。
首先看 job。
package wpool import ( &amp;#34;context&amp;#34; ) type JobID string type jobType string type jobMetadata map[string]interface{} type ExecutionFn func(ctx context.Context, args interface{}) (interface{}, error) type JobDescriptor struct { ID JobID JType jobType Metadata map[string]interface{} } type Result struct { Value interface{} Err error Descriptor JobDescriptor } type Job struct { Descriptor JobDescriptor ExecFn ExecutionFn Args interface{} } // 处理 job 逻辑,处理结果包装成 Result 结果 func (j Job) execute(ctx context.</description>
			<content type="html"><![CDATA[<h3 id="开篇">开篇</h3>
<p>之前写过一篇文章，它有个响亮的名字: <code>Handling 1 Million Requests per Minute with Go</code>。
这是国外的一个作者写的，我做了一篇说明。起的也是这个标题，
阅读量是我最好的一篇，果然文章都是靠标题出彩的&hellip;..</p>
<p>今天偶然看到另一篇文章(原文在文末)。两篇文章原理相似:有一批工作任务(job)，通过工作池(worker-pool)的方式，达到多 <code>worker</code> 并发处理 <code>job</code> 的效果。</p>
<p>他们还是有很多不同的点，实现上差别也是蛮大的。</p>
<p>首先上一篇文章我放了一张图片，大概就是上篇整体的工作流。
<img src="https://image.syst.top/image/work-pool.png" alt="image"></p>
<ul>
<li>每个 <code>worker</code> 处理完任务就好，不关心结果,不对结果做进一步处理。</li>
<li>只要请求不停止，程序就不会停止，没有控制机制，除非宕机。</li>
</ul>
<p>这篇文章不同点在于:</p>
<p>首先数据会从 <code>generate</code> (生产数据)-&gt;并发处理数据-&gt;处理结果聚合。
图大概是这样的,
<img src="https://image.syst.top/image/out.png" alt="image"></p>
<p>然后它可以通过 <code>context.context</code> 达到控制工作池停止工作的效果。</p>
<p>最后通过代码，你会发现它不是传统意义上的 <code>worker-pool</code>，后面会说明。</p>
<p>下图能清晰表达整体流程了。
<img src="https://image.syst.top/image/work-pool-2.png" alt="image"></p>
<p>顺便说一句，这篇文章实现的代码比 <code>Handling 1 Million Requests per Minute with Go</code> 的代码简单多了。</p>
<p>首先看 <code>job</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">wpool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">JobID</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">jobType</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">jobMetadata</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ExecutionFn</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">args</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">JobDescriptor</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ID</span>       <span class="nx">JobID</span> 
</span></span><span class="line"><span class="cl">	<span class="nx">JType</span>    <span class="nx">jobType</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Metadata</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Result</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span>      <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Err</span>        <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Descriptor</span> <span class="nx">JobDescriptor</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Job</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Descriptor</span> <span class="nx">JobDescriptor</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ExecFn</span>     <span class="nx">ExecutionFn</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Args</span>       <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 处理 job 逻辑,处理结果包装成 Result 结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="nx">Job</span><span class="p">)</span> <span class="nf">execute</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="nx">Result</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">value</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">j</span><span class="p">.</span><span class="nf">ExecFn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">j</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">Result</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Err</span><span class="p">:</span>        <span class="nx">err</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Descriptor</span><span class="p">:</span> <span class="nx">j</span><span class="p">.</span><span class="nx">Descriptor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">Result</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Value</span><span class="p">:</span>      <span class="nx">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Descriptor</span><span class="p">:</span> <span class="nx">j</span><span class="p">.</span><span class="nx">Descriptor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个可以简单过一下。最终每个 <code>job</code> 处理完都会包装成 <code>Result</code> 返回。</p>
<p>下面这段就是核心代码了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">wpool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 运行中的每个worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">jobs</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">results</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">job</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">jobs</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">results</span> <span class="o">&lt;-</span> <span class="nx">job</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;cancelled worker. Error detail: %v\n&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="nx">results</span> <span class="o">&lt;-</span> <span class="nx">Result</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">Err</span><span class="p">:</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">WorkerPool</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">workersCount</span> <span class="kt">int</span> <span class="c1">//worker 数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">jobs</span>         <span class="kd">chan</span> <span class="nx">Job</span> <span class="c1">// 存储 job 的 channel 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">results</span>      <span class="kd">chan</span> <span class="nx">Result</span> <span class="c1">// 处理完每个 job 对应的 结果集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Done</span>         <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">//是否结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">wcount</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">WorkerPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">WorkerPool</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">workersCount</span><span class="p">:</span> <span class="nx">wcount</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">jobs</span><span class="p">:</span>         <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">wcount</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">results</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Result</span><span class="p">,</span> <span class="nx">wcount</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Done</span><span class="p">:</span>         <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">workersCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">,</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span><span class="p">,</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">results</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">Done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">results</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">Results</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Result</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">results</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">GenerateFrom</span><span class="p">(</span><span class="nx">jobsBulk</span> <span class="p">[]</span><span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">jobsBulk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span> <span class="o">&lt;-</span> <span class="nx">jobsBulk</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>整个 <code>WorkerPool</code> 结构很简单。 <code>jobs</code> 是一个缓冲 <code>channel</code>。每一个任务都会放入 <code>jobs</code> 中等待处理 <code>woker</code> 处理。</p>
<p><code>results</code> 也是一个通道类型，它的作用是保存每个 <code>job</code> 处理后产生的结果 <code>Result</code>。</p>
<p>首先通过 <code>New</code> 初始化一个 <code>worker-pool</code> 工作池,然后执行 <code>Run</code> 开始运行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">wcount</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">WorkerPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">WorkerPool</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">workersCount</span><span class="p">:</span> <span class="nx">wcount</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">jobs</span><span class="p">:</span>         <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">wcount</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">results</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Result</span><span class="p">,</span> <span class="nx">wcount</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Done</span><span class="p">:</span>         <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">workersCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">,</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span><span class="p">,</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">results</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">Done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">results</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>初始化的时候传入 <code>worker</code> 数，对应每个 <code>g</code> 运行 <code>work(ctx,&amp;wg,wp.jobs,wp.results)</code>,组成了 <code>worker-pool</code>。
同时通过 <code>sync.WaitGroup</code>,我们可以等待所有 <code>worker</code> 工作结束，也就意味着 <code>work-pool</code> 结束工作，当然可能是因为任务处理结束，也可能是被停止了。</p>
<p>每个 <code>job</code> 数据源是如何来的？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// job数据源，把每个 job 放入到 jobs channel 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">GenerateFrom</span><span class="p">(</span><span class="nx">jobsBulk</span> <span class="p">[]</span><span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">jobsBulk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span> <span class="o">&lt;-</span> <span class="nx">jobsBulk</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nb">close</span><span class="p">(</span><span class="nx">wp</span><span class="p">.</span><span class="nx">jobs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对应每个 <code>worker</code> 的工作，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">jobs</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">results</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">job</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">jobs</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">results</span> <span class="o">&lt;-</span> <span class="nx">job</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;cancelled worker. Error detail: %v\n&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="nx">results</span> <span class="o">&lt;-</span> <span class="nx">Result</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">Err</span><span class="p">:</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>每个 worker 都尝试从同一个 <code>jobs</code> 获取数据，这是一个典型的 <code>fan-out</code> 模式。
当对应的 <code>g</code> 获取到 <code>job</code> 进行处理后，会把处理结果发送到同一个 <code>results channel</code> 中,这又是一个 <code>fan-in</code> 模式。
当然我们通过 <code>context.Context</code> 可以对每个 <code>worker</code> 做停止运行控制。</p>
<p>最后是处理结果集合，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 处理结果集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wp</span> <span class="nx">WorkerPool</span><span class="p">)</span> <span class="nf">Results</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Result</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">wp</span><span class="p">.</span><span class="nx">results</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>那么整体的测试代码就是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TestWorkerPool</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wp</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="nx">workerCount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">TODO</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">wp</span><span class="p">.</span><span class="nf">GenerateFrom</span><span class="p">(</span><span class="nf">testJobs</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">wp</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">wp</span><span class="p">.</span><span class="nf">Results</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">i</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Descriptor</span><span class="p">.</span><span class="nx">ID</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;unexpected error: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">val</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">val</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;wrong value %v; expected %v&#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">wp</span><span class="p">.</span><span class="nx">Done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>看了代码之后，我们知道，这并不是一个传统意义的 <code>worker-pool</code>。它并不像 <code>Handling 1 Million Requests per Minute with Go</code> 这篇文章一样，
初始化一个真正的 <code>worker-pool</code>，一旦接收到 <code>job</code>,就尝试从池中获取一个 <code>worker</code>，
把对应的 <code>job</code> 交给这个 <code>work</code> 进行处理，等 <code>work</code> 处理完毕，重新进行到工作池中，等待下一次被利用。</p>
]]></content>
		</item>
		
		<item>
			<title>channel原理解析</title>
			<link>https://www.syst.top/posts/go/channel/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/channel/</guid>
			<description>躺的太久了，该起床了。宁可我卷死别人，不能让别人卷我。
之前断断续续看过Go几个模块的源码，可从未下笔，导致有些细节记不起来了。打算写一些文章重新记录。
channel源码解析的文章太多了。只用一篇文章的长篇大论大部分人没耐心看完，所以我打算分开写，最后附上完整的ppt。
当然这其中不会涉及过多细节源码，因为有时候，细节是魔鬼。
介绍 channel一些基础介绍这里就不过多涉及了，都1202年了，我不相信用过Go的人没用过channel。
当然下图也涵盖了大部分使用方法。注意是使用姿势，而不是模式。
顺便再提一句，有一道使用channel进行任务编排的经典的题。题目如下，
有四个goroutine，编号为 1、2、3、4。每秒钟会有一个 goroutine打印自己的编号。请你实现这个程序，让输出的编号总是按照 1、2、3、4、1、2、3、4、……的顺序打印出来。就像这样，
可以自己先思考下，代码也可以通过后台回复击鼓传花获取。
原理解析 从一个简单的例子说起。
创建一个main.go文件，代码如下，
我们来看看这段代码编译以后长啥样。
想得到go程序的汇编代码并不难。
可以使用go tool compile -N -l -S main.go生成汇编代码：
或者使用go tool compile -N -l main.go 先编译出代码，然后再使用go tool objdump main.o反汇编出代码。
当然，通过go build -gcflags -S main.go同样可以得到汇编的代码。
上面两种我就不演示了，可以自行实验。他们之中flag的具体含义也可以自行了解。
如果你觉得上面要自己敲代码比较麻烦，我推荐一个更加直接可视化的工具。
综上，从编译的代码我们可以看出，上述初始化一个channel,
ch := make(chan struct{}) 实际上调用的是runtime.makechan。我们来了解一下runtime.makechan。
从函数中，我们能知道最终返回一个runtime.hchan的指针。
runtime.hchan结构。
我们先来解释hchan结构体各个字段的含义，之后在案例介绍中会更加详细的说明他们的作用。
我们先来看qcount和dataqsiz有什么区别？
你去银行办事，银行有5个办事窗口，那么dataqsiz就等于5。在这里体现的是channel的容量为5。去银行的时候，当前有3个窗口有人正在办事，那么qcount就等于3，体现channel当前有3个数据元素。那么此时银行还可以再接待2个客户，对应还可以往channel发送2个数据元素。
其他字段现在看看说明就行了，后面会细讲。
到这里我们就知道创建一个channel本质上就是得到一个runtime.hchan的指针，后续对此chan的操作，无非就是对结构体字段进行相对应的操作。
同时我们也能猜出，为啥channel能在不同的g中传递消息，而对于使用者来说不用担心并发的问题，其实就是hchan内部使用互斥锁来保证了并发安全。
最后我们来看一下runtime.makechan函数核心实现，当然注释已经很明白了。
可以看到创建的时候有一段switch分支代码，那么什么情况下会走对应的case呢?
根据上面的信息，我们可以得出，
 如果创建一个无缓冲channel ，那么只需要为runtime.hchan本身分配一段内存空间即可。 如果创建的缓冲channel 存储的类型不是指针类型，会为当前 channel 和存储类型元素的缓冲区，分配一块连续的内存空间。 在默认情况下(缓冲channel存储类型包含指针)，会单独为runtime.hchan和缓冲区分配内存。  总结 这篇我们主要介绍了如何获取go程序的汇编代码，通过汇编代码知道创建channel的具体函数runtime.makechan，同时我们还知道不同的创建姿势会导致走向不同的内存空间分配。最后通过创建函数我们知道channel在程序运行时使用runtime.hchan来表示。</description>
			<content type="html"><![CDATA[<p>躺的太久了，该起床了。宁可我卷死别人，不能让别人卷我。</p>
<p>之前断断续续看过<code>Go</code>几个模块的源码，可从未下笔，导致有些细节记不起来了。打算写一些文章重新记录。</p>
<p><code>channel</code>源码解析的文章太多了。只用一篇文章的长篇大论大部分人没耐心看完，所以我打算分开写，最后附上完整的<code>ppt</code>。</p>
<p>当然这其中不会涉及过多细节源码，因为有时候，细节是魔鬼。</p>
<h3 id="介绍">介绍</h3>
<p><code>channel</code>一些基础介绍这里就不过多涉及了，都1202年了，我不相信用过<code>Go</code>的人没用过<code>channel</code>。</p>
<p>当然下图也涵盖了大部分使用方法。注意是使用姿势，而不是模式。</p>
<p><img src="https://cdn.syst.top/use-channel.png" alt="image"></p>
<p>顺便再提一句，有一道使用<code>channel</code>进行任务编排的经典的题。题目如下，</p>
<p>有四个<code>goroutine</code>，编号为 1、2、3、4。每秒钟会有一个 <code>goroutine</code>打印自己的编号。请你实现这个程序，让输出的编号总是按照 1、2、3、4、1、2、3、4、……的顺序打印出来。就像这样，</p>
<p><img src="https://cdn.syst.top/channel-gif.gif" alt="image"></p>
<p>可以自己先思考下，代码也可以通过后台回复<code>击鼓传花</code>获取。</p>
<h3 id="原理解析">原理解析</h3>
<p>从一个简单的例子说起。</p>
<p>创建一个<code>main.go</code>文件，代码如下，</p>
<p><img src="https://cdn.syst.top/ch-send.png" alt="image"></p>
<p>我们来看看这段代码编译以后长啥样。</p>
<p>想得到<code>go</code>程序的汇编代码并不难。</p>
<p>可以使用<code>go tool compile -N -l -S main.go</code>生成汇编代码：</p>
<p><img src="https://cdn.syst.top/compile-channel.png" alt="image"></p>
<p>或者使用<code>go tool compile -N -l main.go</code> 先编译出代码，然后再使用<code>go tool objdump main.o</code>反汇编出代码。</p>
<p>当然，通过<code>go build -gcflags -S main.go</code>同样可以得到汇编的代码。</p>
<p>上面两种我就不演示了，可以自行实验。他们之中<code>flag</code>的具体含义也可以自行了解。</p>
<p>如果你觉得上面要自己敲代码比较麻烦，我推荐一个更加直接可视化的工具。</p>
<p><img src="https://cdn.syst.top/compile-show.png" alt="image"></p>
<p>综上，从编译的代码我们可以看出，上述初始化一个<code>channel</code>,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></span></code></pre></div><p>实际上调用的是<code>runtime.makechan</code>。我们来了解一下<code>runtime.makechan</code>。</p>
<p><img src="https://cdn.syst.top/makechannel.png" alt="image"></p>
<p>从函数中，我们能知道最终返回一个<code>runtime.hchan</code>的指针。</p>
<p><code>runtime.hchan</code>结构。</p>
<p><img src="https://cdn.syst.top/hchan.png" alt="image"></p>
<p>我们先来解释<code>hchan</code>结构体各个字段的含义，之后在案例介绍中会更加详细的说明他们的作用。</p>
<p><img src="https://cdn.syst.top/hchan-detail2.png" alt="image"></p>
<p>我们先来看<code>qcount</code>和<code>dataqsiz</code>有什么区别？</p>
<p>你去银行办事，银行有5个办事窗口，那么<code>dataqsiz</code>就等于5。在这里体现的是<code>channel</code>的容量为5。去银行的时候，当前有3个窗口有人正在办事，那么<code>qcount</code>就等于3，体现<code>channel</code>当前有3个数据元素。那么此时银行还可以再接待2个客户，对应还可以往<code>channel</code>发送2个数据元素。</p>
<p>其他字段现在看看说明就行了，后面会细讲。</p>
<p>到这里我们就知道创建一个<code>channel</code>本质上就是得到一个<code>runtime.hchan</code>的指针，后续对此<code>chan</code>的操作，无非就是对结构体字段进行相对应的操作。</p>
<p>同时我们也能猜出，为啥<code>channel</code>能在不同的<code>g</code>中传递消息，而对于使用者来说不用担心并发的问题，其实就是<code>hchan</code>内部使用互斥锁来保证了并发安全。</p>
<p>最后我们来看一下<code>runtime.makechan</code>函数核心实现，当然注释已经很明白了。</p>
<p><img src="https://cdn.syst.top/makechan2.png" alt="image-20211009084700993"></p>
<p>可以看到创建的时候有一段<code>switch</code>分支代码，那么什么情况下会走对应的<code>case</code>呢?</p>
<p><img src="https://cdn.syst.top/make-zi.png" alt="image-20211009084700993"></p>
<p>根据上面的信息，我们可以得出，</p>
<ul>
<li>如果创建一个无缓冲<code>channel</code> ，那么只需要为<code>runtime.hchan</code>本身分配一段内存空间即可。</li>
<li>如果创建的缓冲<code>channel</code> 存储的类型不是指针类型，会为当前 <code>channel</code> 和存储类型元素的缓冲区，分配一块连续的内存空间。</li>
<li>在默认情况下(缓冲<code>channel</code>存储类型包含指针)，会单独为<code>runtime.hchan</code>和缓冲区分配内存。</li>
</ul>
<h3 id="总结">总结</h3>
<p>这篇我们主要介绍了如何获取<code>go</code>程序的汇编代码，通过汇编代码知道创建<code>channel</code>的具体函数<code>runtime.makechan</code>，同时我们还知道不同的创建姿势会导致走向不同的内存空间分配。最后通过创建函数我们知道<code>channel</code>在程序运行时使用<code>runtime.hchan</code>来表示。</p>
<p>下一篇我们继续。</p>
<p><img src="/Users/wuqinqiang/Desktop/image-20211009180357516.png" alt="image-20211009180357516"></p>
]]></content>
		</item>
		
		<item>
			<title>iota 在 Go 中的使用 </title>
			<link>https://www.syst.top/posts/go/enum/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/enum/</guid>
			<description>介绍 Go 语言实际上没有直接支持枚举的关键字。一般我们都是通过 const + iota 实现枚举的能力。
有人要问了，为什么一定要使用枚举呢？stackoverflow 上有一个高赞的回答，如下:
You should always use enums when a variable (especially a method parameter) can only take one out of a small set of possible values. Examples would be things like type constants (contract status: &amp;#34;permanent&amp;#34;, &amp;#34;temp&amp;#34;, &amp;#34;apprentice&amp;#34;), or flags (&amp;#34;execute now&amp;#34;, &amp;#34;defer execution&amp;#34;). If you use enums instead of integers (or String codes), you increase compile-time checking and avoid errors from passing in invalid constants, and you document which values are legal to use.</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>Go 语言实际上没有直接支持枚举的关键字。一般我们都是通过 <code>const</code> + <code>iota</code> 实现枚举的能力。</p>
<p>有人要问了，为什么一定要使用枚举呢？<code>stackoverflow</code> 上有一个高赞的回答，如下:</p>
<pre tabindex="0"><code>You should always use enums when a variable (especially a method parameter) can only take one out of a small set of possible values. Examples would be things like type constants (contract status: &#34;permanent&#34;, &#34;temp&#34;, &#34;apprentice&#34;), or flags (&#34;execute now&#34;, &#34;defer execution&#34;).

If you use enums instead of integers (or String codes), you increase compile-time checking and avoid errors from passing in invalid constants, and you document which values are legal to use.

BTW, overuse of enums might mean that your methods do too much (it&#39;s often better to have several separate methods, rather than one method that takes several flags which modify what it does), but if you have to use flags or type codes, enums are the way to go.
</code></pre><p>简单翻译一下， 两点很重要。</p>
<ul>
<li>当一个变量(尤其是方法参数) 只能从一小部分可能的值中取出一个时，理应使用枚举。
例如类型常量(合同状态：永久、临时工、学徒)， 或者在做任务程序时，是立即执行还是延迟执行的标记。</li>
<li>如果使用枚举而不是整形，则会增加编译时的检查，避免错误无效值的传入，记录哪些值是合法使用的。</li>
</ul>
<h3 id="如何实现枚举">如何实现枚举</h3>
<p><code>iota</code> 是 Go 中预声明的一个特殊常量。它会被预声明为0，但是它的值在编译阶段并非是固定的，当预声明的 <code>iota</code> 出现在一个常量声明中的时候，它的值在第n个常量描述中的值为n(从0开始)。所以它只在同类型多个常量声明的情况下才显得有意义。</p>
<p>比如，大家都了解的电商，订单系统一定会涉及到订单状态的流转。那么这时候，我们一般可以这样做:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cancelled</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">//订单已取消 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NoPay</span>     <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">//未支付  1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PendIng</span>   <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// 未发货 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Delivered</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// 已发货 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Received</span>  <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// 已收货 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Cancelled</span><span class="p">,</span> <span class="nx">NoPay</span><span class="p">)</span> <span class="c1">// 打印:0,1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>当然，这样看着好麻烦。其实，其他常量可以重复上一行 <code>iota</code> 表达式，我们可以改成这样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cancelled</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">//订单已取消 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NoPay</span>                        <span class="c1">//未支付 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PendIng</span>                      <span class="c1">// 未发货 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Delivered</span>                    <span class="c1">// 已发货 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Received</span>                     <span class="c1">// 已收货 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Cancelled</span><span class="p">,</span> <span class="nx">NoPay</span><span class="p">)</span> <span class="c1">// 打印:0,1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>有人会用 0 的值来表示状态吗？一般都不会，我们想以1开头，那么可以这样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cancelled</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span><span class="o">+</span><span class="mi">1</span> <span class="c1">//订单已取消 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NoPay</span>                        <span class="c1">//未支付 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PendIng</span>                      <span class="c1">// 未发货 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Delivered</span>                    <span class="c1">// 已发货 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Received</span>                     <span class="c1">// 已收货 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Cancelled</span><span class="p">,</span> <span class="nx">NoPay</span><span class="p">)</span> <span class="c1">// 打印:1,2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>我们还想在 <code>Delivered</code> 后跳过一个数字，才是 <code>Received</code> 的值,也就是 <code>Received=6</code>，那么可以借助 <code>_</code> 符号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cancelled</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span><span class="o">+</span><span class="mi">1</span> <span class="c1">//订单已取消 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NoPay</span>                        <span class="c1">//未支付 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PendIng</span>                      <span class="c1">// 未发货 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Delivered</span>                    <span class="c1">// 已发货 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">_</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Received</span>                     <span class="c1">// 已收货 6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Received</span><span class="p">)</span> <span class="c1">// 打印:6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>顺着来可以，倒着当然也行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Max</span> <span class="p">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Received</span>  <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="nx">Max</span> <span class="o">-</span> <span class="kc">iota</span> <span class="c1">// 已收货  5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Delivered</span>                          <span class="c1">// 已发货 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PendIng</span>                            <span class="c1">// 未发货 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NoPay</span>                              <span class="c1">//未支付 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Cancelled</span>                          <span class="c1">//订单已取消 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Received</span><span class="p">,</span><span class="nx">Delivered</span><span class="p">)</span> <span class="c1">// 打印:5,4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>你还可以使用位运算，比如在 go 源码中的包 <code>sync</code> 中的锁上面有这么一段代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutexLocked</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>  <span class="c1">//1&lt;&lt;0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mutexWoken</span>               <span class="c1">//1&lt;&lt;1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mutexStarving</span>            <span class="c1">//1&lt;&lt;2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mutexWaiterShift</span> <span class="p">=</span> <span class="kc">iota</span>  <span class="c1">//3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;mutexLocked的值&#34;</span><span class="p">,</span><span class="nx">mutexLocked</span><span class="p">)</span> <span class="c1">//打印：1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;mutexWoken的值&#34;</span><span class="p">,</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="c1">//打印：2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;mutexStarving的值&#34;</span><span class="p">,</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="c1">//打印：4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;mutexWaiterShift的值&#34;</span><span class="p">,</span><span class="nx">mutexWaiterShift</span><span class="p">)</span> <span class="c1">// 打印：3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>可能有人平常是直接定义常量值或者用字符串来表示的。</p>
<p>比如，上面这些我完全可以用 <code>string</code> 来表示，我还真见过用字符串来表示订单状态的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cancelled</span> <span class="p">=</span> <span class="s">&#34;cancelled&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">NoPay</span>     <span class="p">=</span> <span class="s">&#34;noPay&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">PendIng</span>   <span class="p">=</span> <span class="s">&#34;pendIng&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Delivered</span> <span class="p">=</span> <span class="s">&#34;delivered&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Received</span>  <span class="p">=</span> <span class="s">&#34;received&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">OrderStatusMsg</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cancelled</span><span class="p">:</span> <span class="s">&#34;订单已取消&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">NoPay</span><span class="p">:</span>     <span class="s">&#34;未付款&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">PendIng</span><span class="p">:</span>   <span class="s">&#34;未发货&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Delivered</span><span class="p">:</span> <span class="s">&#34;已发货&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Received</span><span class="p">:</span>  <span class="s">&#34;已收货&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">OrderStatusMsg</span><span class="p">[</span><span class="nx">Cancelled</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>或者直接定义整形常量值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cancelled</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nx">NoPay</span>     <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="nx">PendIng</span>   <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Delivered</span> <span class="p">=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Received</span>  <span class="p">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">OrderStatusMsg</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cancelled</span><span class="p">:</span> <span class="s">&#34;订单已取消&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">NoPay</span><span class="p">:</span>     <span class="s">&#34;未付款&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">PendIng</span><span class="p">:</span>   <span class="s">&#34;未发货&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Delivered</span><span class="p">:</span> <span class="s">&#34;已发货&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Received</span><span class="p">:</span>  <span class="s">&#34;已收货&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">OrderStatusMsg</span><span class="p">[</span><span class="nx">Cancelled</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其实上述两种都可以，但是相比之下使用 <code>iota</code> 更有优势。</p>
<ul>
<li>能保证一组常量的唯一性，人工定义的不能保证。</li>
<li>可以为一组动作分享同一种行为。</li>
<li>避免无效值。</li>
<li>提高代码阅读性以及维护。</li>
</ul>
<h3 id="延伸">延伸</h3>
<p>按照上面我们所演示的，最后我们可以这样操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OrderStatus</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cancelled</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">//订单已取消 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NoPay</span>                            <span class="c1">//未支付 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PendIng</span>                          <span class="c1">// 未发货 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Delivered</span>                        <span class="c1">// 已发货 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Received</span>                         <span class="c1">// 已收货 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//公共行为 赋予类型 String() 函数，方便打印值含义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">order</span> <span class="nx">OrderStatus</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;cancelled&#34;</span><span class="p">,</span> <span class="s">&#34;noPay&#34;</span><span class="p">,</span> <span class="s">&#34;pendIng&#34;</span><span class="p">,</span> <span class="s">&#34;delivered&#34;</span><span class="p">,</span> <span class="s">&#34;received&#34;</span><span class="p">}[</span><span class="nx">order</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//创建公共行为 赋予类型 int 函数 EnumIndex()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">order</span> <span class="nx">OrderStatus</span><span class="p">)</span> <span class="nf">EnumIndex</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">order</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">order</span> <span class="nx">OrderStatus</span> <span class="p">=</span> <span class="nx">Received</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">order</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>    <span class="c1">// 打印:received
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">order</span><span class="p">.</span><span class="nf">EnumIndex</span><span class="p">())</span> <span class="c1">// 打印:5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="总结">总结</h3>
<p>这篇文章主要介绍了 <code>Golang</code> 中对 <code>iota</code> 的使用介绍，以及我们为什么要使用它。</p>
<p>不知道大家平常对于此类场景是用的什么招数，欢迎下方留言交流。</p>
]]></content>
		</item>
		
		<item>
			<title>原来sync.Once还能这么用</title>
			<link>https://www.syst.top/posts/go/synconce/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/synconce/</guid>
			<description>介绍 sync.Once估计大家都不陌生，官方介绍中，
 Once is an object that will perform exactly one action
 正是因为这个特性，Once常常被用于单例对象的初始化场景。
也正是因为这个特性，其实它还能做一些其他的事情。
缓存击穿 日常背诵八股文，我相信你们对缓存击穿这个词特别熟悉。
缓存击穿一般待指热点key缓存失效(到期|删了)，同一时刻大量对热点key的并发请求。缓存找不到数据，所有请求都打入到DB层。此时，身为开发的你，明天和意外就不知道哪个先到了。
为了防止这种情况发生，针对相同key的请求，只需要一个请求(A)到达DB层取数据，其他请求等待A通知就行了。
就像这样，
​ 图片来源:caching
singleflight Go里有很多防缓存击穿的工具，比如singleflight库。
type call struct { wg sync.WaitGroup val interface{} err error forgotten bool //.....省略部分字段 } type Group struct { mu sync.Mutex m map[string]*call } 通过上面简单的代码大概能看出，其实就是对key做了缓存。
把一个key对应call结构存储在map中。保证只有一个key真正执行fn()服务 ，其他请求则通过sync.waitGroup的wait等待结果。
至于g.docall(c,key,fn)，
当带着全村人希望的那个请求，获取到数据，给对应key的call赋值，最终执行done，通知等待这个key全村的村民获取数据。
代码并不复杂。
自定义singleflight 我们也可以实现一个简易版本的。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) type CacheEntry struct { data []byte err error wait chan struct{} } type OrderSever struct { cache map[string]*CacheEntry mutex sync.</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p><code>sync.Once</code>估计大家都不陌生，官方介绍中，</p>
<blockquote>
<p>Once is an object that will perform exactly one action</p>
</blockquote>
<p>正是因为这个特性，<code>Once</code>常常被用于单例对象的初始化场景。</p>
<p>也正是因为这个特性，其实它还能做一些其他的事情。</p>
<h3 id="缓存击穿">缓存击穿</h3>
<p>日常背诵八股文，我相信你们对<strong>缓存击穿</strong>这个词特别熟悉。</p>
<p><strong>缓存击穿</strong>一般待指热点<code>key</code>缓存失效(到期|删了)，同一时刻大量对热点<code>key</code>的并发请求。缓存找不到数据，所有请求都打入到<code>DB</code>层。此时，身为开发的你，明天和意外就不知道哪个先到了。</p>
<p>为了防止这种情况发生，针对相同<code>key</code>的请求，只需要一个请求(A)到达<code>DB</code>层取数据，其他请求等待<code>A</code>通知就行了。</p>
<p>就像这样，</p>
<p><img src="https://cdn.syst.top/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png" alt="缓存击穿"></p>
<p>​                                 图片来源:<a href="https://medium.com/codex/caching-system-stability-766bf5fff69f">caching</a></p>
<h3 id="singleflight">singleflight</h3>
<p><code>Go</code>里有很多防缓存击穿的工具，比如<code>singleflight</code>库。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">call</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">val</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nx">forgotten</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//.....省略部分字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>       
</span></span><span class="line"><span class="cl">	<span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">call</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://cdn.syst.top/once-1.png" alt=""></p>
<p>通过上面简单的代码大概能看出，其实就是对<code>key</code>做了缓存。</p>
<p>把一个<code>key</code>对应<code>call</code>结构存储在<code>map</code>中。保证只有一个<code>key</code>真正执行<code>fn()</code>服务 ，其他请求则通过<code>sync.waitGroup</code>的<code>wait</code>等待结果。</p>
<p>至于<code>g.docall(c,key,fn)</code>，</p>
<p><img src="https://cdn.syst.top/once-2.png" alt=""></p>
<p>当带着全村人希望的那个请求，获取到数据，给对应<code>key</code>的<code>call</code>赋值，最终执行<code>done</code>，通知等待这个<code>key</code>全村的村民获取数据。</p>
<p>代码并不复杂。</p>
<h3 id="自定义singleflight"><strong>自定义</strong>singleflight</h3>
<p>我们也可以实现一个简易版本的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CacheEntry</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span>  <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wait</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OrderSever</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cache</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CacheEntry</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mutex</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">order</span> <span class="o">*</span><span class="nx">OrderSever</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">order</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">order</span><span class="p">.</span><span class="nx">cache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">order</span><span class="p">.</span><span class="nx">cache</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CacheEntry</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">//已经有其他兄弟请求了，你等等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">entry</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">order</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">order</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="o">&lt;-</span><span class="nx">entry</span><span class="p">.</span><span class="nx">wait</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">entry</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">CacheEntry</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">data</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wait</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">order</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">entry</span>
</span></span><span class="line"><span class="cl">	<span class="nx">order</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 请求数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nf">getOrder</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 请求数据完毕，通知其他兄弟可以拿数据了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nb">close</span><span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">wait</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//外部服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">getOrder</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">50</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>代码整体不难，主要的点在于我们是通过通道来实现通知自家兄弟取数据。</p>
<p>最后，让我们使用<code>Once</code>来达到同样的效果，不然标题不白起了嘛。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CacheEntry</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span>  <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nx">once</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OrderSever</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cache</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CacheEntry</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mutex</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">order</span> <span class="o">*</span><span class="nx">OrderSever</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">order</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">order</span><span class="p">.</span><span class="nx">cache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">order</span><span class="p">.</span><span class="nx">cache</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CacheEntry</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">entry</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">order</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// 找不到就初始化一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">entry</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">CacheEntry</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">data</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">			<span class="nx">err</span><span class="p">:</span>  <span class="kc">nil</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">once</span><span class="p">:</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">order</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">entry</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">order</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// 我只执行一次。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">entry</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nf">getOrder</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//数据被赋值了，返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getOrder</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">50</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面核心代码都写出来了，实际开发中需要对请求资源做一些超时控制等操作。</p>
<h3 id="总结">总结</h3>
<p>平常对<code>Once</code>的使用只停留在初始化工作上，而弱化了它的使用场景。对于其他工具也是一个道理，这就需要去积累和挖掘了。</p>
<h3 id="附录"><strong>附录</strong></h3>
<p>[1]https://medium.com/codex/caching-system-stability-766bf5fff69f</p>
<p><a href="https://blog.chuie.io/posts/synconce/">https://blog.chuie.io/posts/synconce/</a></p>
]]></content>
		</item>
		
		<item>
			<title>推荐两款go开发中提高效率工具</title>
			<link>https://www.syst.top/posts/go/go-tool/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/go-tool/</guid>
			<description>介绍 推荐两款 go 开发中用的还行的工具。
为什么推荐工具？是为了让评论区的大佬介绍其他更好用的工具，解放我的双手。
顺便问问，有没有只说话就能自动打完代码的工具？
JSON-To-Stuct 这个工具可以把 json 格式的数据转换成 go 的 struct。比如你在对接第三方的时候，就不需要根据对方的接口一个个定义 struct 字段。下面示例复制的微信小商店商品 json 数据到网站的左框即可，当然自己还是需要做一些局部的调整。
其实这个功能 21 版的 goland 也支持了。在 goland 中你只需要这样,
Table-To-Stuct 被业务缠身的同学每天免不了 CURD。CURD 之前总得建表吧。建表之后总得在代码中定义模型吧。总不能又一个个字段定义，那么下面这个工具可能管用。
假设你有一个库 dream，库里有一个表 category，结构如下，
CREATETABLE`category`(`id`int(11)unsignedNOTNULLAUTO_INCREMENT,`name`varchar(20)NOTNULLDEFAULT&amp;#39;&amp;#39;,`parent_id`int(11)unsignedNOTNULLDEFAULT&amp;#39;0&amp;#39;,`created_at`timestampNOTNULLDEFAULTCURRENT_TIMESTAMP,`updated_at`timestampNOTNULLDEFAULTCURRENT_TIMESTAMP,PRIMARYKEY(`id`),UNIQUEKEY`name`(`name`))ENGINE=InnoDBAUTO_INCREMENT=23DEFAULTCHARSET=utf8mb4;你只需引入包 github.com/gohouse/converter ,然后写这样的代码，就可以实现 table-to-go 功能。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/gohouse/converter&amp;#34; ) func main() { // 初始化 	t2t := converter.NewTable2Struct() // 个性化配置 	t2t.Config(&amp;amp;converter.T2tConfig{ // 如果字段首字母本来就是大写, 就不添加tag, 默认false添加, true不添加 	RmTagIfUcFirsted: false, // tag的字段名字是否转换为小写, 如果本身有大写字母的话, 默认false不转 	TagToLower: false, // 字段首字母大写的同时, 是否要把其他字母转换为小写,默认false不转换 	UcFirstOnly: false, //// 每个struct放入单独的文件,默认false,放入同一个文件(暂未提供) 	//SeperatFile: false, 	}) // 开始迁移转换 	err := t2t.</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>推荐两款 <code>go</code> 开发中用的还行的工具。</p>
<p>为什么推荐工具？是为了让评论区的大佬介绍其他更好用的工具，解放我的双手。</p>
<p>顺便问问，有没有只说话就能自动打完代码的工具？</p>
<h3 id="json-to-stuct">JSON-To-Stuct</h3>
<p>这个工具可以把 <code>json</code> 格式的数据转换成 <code>go</code> 的 <code>struct</code>。比如你在对接第三方的时候，就不需要根据对方的接口一个个定义 <code>struct</code> 字段。下面示例复制的微信小商店商品 <code>json</code> 数据到网站的左框即可，当然自己还是需要做一些局部的调整。</p>
<p><img src="https://image.syst.top/image/go-tool/1.png" alt="image"></p>
<p>其实这个功能 21 版的 <code>goland</code> 也支持了。在 <code>goland</code> 中你只需要这样,</p>
<p><img src="https://image.syst.top/image/go-tool/2.gif" alt="image"></p>
<h3 id="table-to-stuct">Table-To-Stuct</h3>
<p>被业务缠身的同学每天免不了 <code>CURD</code>。<code>CURD</code> 之前总得建表吧。建表之后总得在代码中定义模型吧。总不能又一个个字段定义，那么下面这个工具可能管用。</p>
<p>假设你有一个库 <code>dream</code>，库里有一个表 <code>category</code>，结构如下，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">category</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">name</span><span class="o">`</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">parent_id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">created_at</span><span class="o">`</span><span class="w"> </span><span class="k">timestamp</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">updated_at</span><span class="o">`</span><span class="w"> </span><span class="k">timestamp</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">UNIQUE</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="n">name</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">name</span><span class="o">`</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">23</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>你只需引入包 <code>github.com/gohouse/converter</code> ,然后写这样的代码，就可以实现 <code>table-to-go</code> 功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/gohouse/converter&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t2t</span> <span class="o">:=</span> <span class="nx">converter</span><span class="p">.</span><span class="nf">NewTable2Struct</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 个性化配置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t2t</span><span class="p">.</span><span class="nf">Config</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">converter</span><span class="p">.</span><span class="nx">T2tConfig</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果字段首字母本来就是大写, 就不添加tag, 默认false添加, true不添加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">RmTagIfUcFirsted</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// tag的字段名字是否转换为小写, 如果本身有大写字母的话, 默认false不转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">TagToLower</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 字段首字母大写的同时, 是否要把其他字母转换为小写,默认false不转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">UcFirstOnly</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//// 每个struct放入单独的文件,默认false,放入同一个文件(暂未提供)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//SeperatFile: false,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 开始迁移转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">t2t</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 指定某个表,如果不指定,则默认全部表都迁移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">Table</span><span class="p">(</span><span class="s">&#34;category&#34;</span><span class="p">).</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//// 表前缀
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//Prefix(&#34;prefix_&#34;).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 是否添加json tag
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">EnableJsonTag</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 生成struct的包名(默认为空的话, 则取名为: package model)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">PackageName</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">).</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// tag字段的key值,默认是orm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">TagKey</span><span class="p">(</span><span class="s">&#34;orm&#34;</span><span class="p">).</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 是否添加结构体方法获取表名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">RealNameMethod</span><span class="p">(</span><span class="s">&#34;TableName&#34;</span><span class="p">).</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 生成的结构体保存路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">SavePath</span><span class="p">(</span><span class="s">&#34;model/category.go&#34;</span><span class="p">).</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 数据库dsn,这里可以使用 t2t.DB() 代替,参数为 *sql.DB 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">Dsn</span><span class="p">(</span><span class="s">&#34;root:Passw0rd@tcp(localhost:3306)/dream?charset=utf8&#34;</span><span class="p">).</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">Run</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>运行这段代码，最后会根据设置的 <code>SavePath</code> 里的地址(尚未存在的目录需要先自行创建)，生成 <code>category.go</code> 文件，内容如下，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">model</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Category</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Id</span>        <span class="kt">int</span>    <span class="s">`orm:&#34;id&#34; json:&#34;id&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span>      <span class="kt">string</span> <span class="s">`orm:&#34;name&#34; json:&#34;name&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ParentId</span>  <span class="kt">int</span>    <span class="s">`orm:&#34;parent_id&#34; json:&#34;parent_id&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">CreatedAt</span> <span class="kt">string</span> <span class="s">`orm:&#34;created_at&#34; json:&#34;created_at&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">UpdatedAt</span> <span class="kt">string</span> <span class="s">`orm:&#34;updated_at&#34; json:&#34;updated_at&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Category</span><span class="p">)</span> <span class="nf">TableName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="s">&#34;category&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>相应的再进行调整即可。</p>
<h3 id="总结">总结</h3>
<p>今天主要分享的是 <code>json-to-stuct</code>、<code>table-to-stuct</code> 这两款日常会用上的工具。</p>
<p>好了，现在开始你们给我介绍趁手的工具了。</p>
]]></content>
		</item>
		
		<item>
			<title>无限缓冲的channel(1)</title>
			<link>https://www.syst.top/posts/go/unlimited/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/unlimited/</guid>
			<description>介绍 事情的起因是前几周看到鸟窝写了一篇关于实现无限缓冲 channel 的文章，当时忙着和小姐姐聊天没看，今天想起来了。
不过这篇文章不会涉及到鸟窝自己实现的 chanx，我们会在下一篇提到。
我们都知道，channel 有两种类型:无缓冲和有缓冲的。
当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。
有时候，我们并不知道也无法预估写入通道的数量规模。如果此时通道的写入速度远远超过读取速度，那么必然会在某个时间点塞满通道，导致写入阻塞。 比如之前我翻译的一篇文章 使用 Go 每分钟处理百万请求 中，作者就出现处理速度太慢，导致通道塞满，其他请求被阻塞，响应时间慢慢增加。
此时有人就会提到，能不能提供一个无限缓冲(Unbounded or Unlimited)的通道。
这个问题早在 2017 年就有人提过 issues，最终 go 官方没有实现这个提案。
不过，这个 issues 下面总共产生了 67 个 comments，评论很精彩。 比如有人提到:
cznic:Unlimited capacity channels ask for a machine with unlimited memory. rsc:The limited capacity of channels is an important source of backpressure in a set of communicating goroutines. It is typically a mistake to use an unbounded channel, because you lose that backpressure.</description>
			<content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p>事情的起因是前几周看到鸟窝写了一篇关于实现无限缓冲 <code>channel</code> 的文章，当时忙着和小姐姐聊天没看，今天想起来了。</p>
<p>不过这篇文章不会涉及到鸟窝自己实现的 <code>chanx</code>，我们会在下一篇提到。</p>
<p>我们都知道，<code>channel</code> 有两种类型:无缓冲和有缓冲的。</p>
<p>当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。</p>
<p>有时候，我们并不知道也无法预估写入通道的数量规模。如果此时通道的写入速度远远超过读取速度，那么必然会在某个时间点塞满通道，导致写入阻塞。
比如之前我翻译的一篇文章 <a href="https://www.syst.top/posts/go/handle-million-requests/">使用 Go 每分钟处理百万请求</a> 中，作者就出现处理速度太慢，导致通道塞满，其他请求被阻塞，响应时间慢慢增加。</p>
<p>此时有人就会提到，能不能提供一个无限缓冲(Unbounded or Unlimited)的通道。</p>
<p>这个问题早在 2017 年就有人提过 issues，最终 go 官方没有实现这个提案。</p>
<p>不过，这个 issues 下面总共产生了 67 个 comments，评论很精彩。
<img src="https://image.syst.top/image/unlimited/unlimit-1.png" alt="image"></p>
<p>比如有人提到:</p>
<pre tabindex="0"><code>cznic:Unlimited capacity channels ask for a machine with unlimited memory.

rsc:The limited capacity of channels is an important source of backpressure in a set of communicating goroutines. It is typically a mistake to use an unbounded channel, because you lose that backpressure. If one goroutine falls sufficiently behind, you usually want to take some action in response, not just queue its messages forever. The appropriate response varies by situation: maybe you want to drop messages, maybe you want to keep summary messages, maybe you want to take different responses as the goroutine falls further and further behind. Making it trivial to reach for unbounded channels keeps developers from thinking about this, which I believe is a strong disadvantage.
</code></pre><p>那么如何实现一个无限缓冲的通道呢？</p>
<p>针对这类需求，有很多版本的实现，我们来看其中的一个实现。鸟窝的 chanx 就是在这个基础上做修改的。</p>
<p>我们一步步还原它的实现，这其中还能知道作者的思考过程。</p>
<h2 id="代码">代码</h2>
<p>第一版,</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-2.png" alt="image"></p>
<p><code>MakeInfinite</code> 函数返回两个通道，第一个用于数据的写入，第二个用于数据的读取。</p>
<p>注意看这里的细节，在返回的时候就约束了通道的操作类型:一个只写，一个只读，这样避免了用户破坏通道的操作流程。
这里面的代码也简单，只要写入通道 <code>in</code> 未被关闭，那么就把从 <code>in</code> 通道中读取的值 <code>append</code> 到 <code>inQueue</code> 切片中。
<code>inQueue</code> 在这里就是实现无限缓冲的中间层。</p>
<p>然后有个 test。</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-3.png" alt="image"></p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-4.png" alt="image"></p>
<p>当走到第二个 <code>case</code> 的时候，由于 <code>inQueue</code> 一开始是空的，那么必然会出现  <code>index out</code>。
不仅是一开始，在运行中，如果读取比写入快，那么必然也会导致相同的情况。</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-5.jpg" alt="image">
<img src="https://image.syst.top/image/unlimited/unlimit-6.png" alt="image"></p>
<p>在 <code>inQueue</code> 没有值的时候，我们把 <code>nil</code> 也写入到通道，
然后测试代码中我们从 <code>out channel</code> 读取数值试图把值断言 <code>int</code> 失败了。 那么，当队列中没有数据时，我们不应该写入 <code>out</code> 通道。</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-7.jpg" alt="image">
作者使用了一个技巧，如果 <code>inQueue</code> 没有数据，那么尝试写入一个 <code>nil</code> 通道将永远阻塞。
通常，永久阻塞是一个不好的行为，但是这个是包含在 <code>select</code> 语句中的，所以问题不大。</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-8.png" alt="image"></p>
<p>还有问题。原因很简单，我们再发送完数据就马上关闭了 <code>in</code> 通道。随后 <code>break loop</code>。接下来关闭 <code>out</code> 通道，程序运行结束。
此时 <code>inQueue</code> 还有值未被取出。</p>
<p>只要写比读快，那么就永远存在这个问题。我们需要保证在通道关闭的时候，<code>inQueue</code> 已为空。
<img src="https://image.syst.top/image/unlimited/unlimit-9.jpg" alt="image"></p>
<h2 id="总结">总结</h2>
<p>上面是如何实现一个无限缓冲的 <code>channel</code>？</p>
<p>借助了一个临时存储数据的中间层。</p>
<p>上面的实现有没有哪些地方可以改进？</p>
<p><code>inQueue</code> 作为中间层，本质上是一个切片。明明 <code>inQueue</code> 已经扩容到很大的值了，但是并没有对应的 <code>reset</code>。会导致 <code>inQueue</code> 指向还在底层数组靠后的位置，并不能复用数组前面的空间，造成浪费。</p>
<p><code>chanx</code> 是咋么改进的？</p>
<p>下一篇</p>
]]></content>
		</item>
		
		<item>
			<title>无限缓冲的channel(2)</title>
			<link>https://www.syst.top/posts/go/unlimited-2/</link>
			<pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/unlimited-2/</guid>
			<description>chanx 上篇文章我们提到，当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。 由此引发了关于无限缓存的 channel 话题讨论。 我们分析了一个实现无限缓冲的代码。 最后，我们也提到了它还可以继续优化的点。
鸟窝的 chanx 正是基于此方案改造而成的，我们来看看他俩的不同之处。
上篇文章说过，所谓的无限缓冲，无非是借助一个中间层的数据结构，暂存临时数据。
在 chanx 中，结构是这样的:
type UnboundedChan struct { In chan&amp;lt;- T // channel for write 	Out &amp;lt;-chan T // channel for read 	buffer *RingBuffer // buffer } in 和 out 的职责在上篇文章已经说明，这里的 buffer 就是我们所谓的中间临时存储层。其中的 RingBuffer 结构我们后面再说。
func NewUnboundedChan(initCapacity int) UnboundedChan { return NewUnboundedChanSize(initCapacity, initCapacity, initCapacity) } func NewUnboundedChanSize(initInCapacity, initOutCapacity, initBufCapacity int) UnboundedChan { in := make(chan T, initInCapacity) out := make(chan T, initOutCapacity) ch := UnboundedChan{In: in, Out: out, buffer: NewRingBuffer(initBufCapacity)} go process(in, out, ch) return ch } 它提供了两个初始化 UnboundedChan 的方法，从代码中我们可以明显的看出,NewUnboundedChanSize 可以给每个属性自定义自己的容量大小。仅此而已。</description>
			<content type="html"><![CDATA[<h2 id="chanx">chanx</h2>
<p>上篇文章我们提到，当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。 由此引发了关于无限缓存的 <code>channel</code> 话题讨论。
我们分析了一个实现无限缓冲的代码。 最后，我们也提到了它还可以继续优化的点。</p>
<p>鸟窝的 <code>chanx</code> 正是基于此方案改造而成的，我们来看看他俩的不同之处。</p>
<p>上篇文章说过，所谓的无限缓冲，无非是借助一个中间层的数据结构，暂存临时数据。</p>
<p>在 <code>chanx</code> 中，结构是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">UnboundedChan</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">In</span>     <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">T</span>    <span class="c1">// channel for write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Out</span>    <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">T</span>    <span class="c1">// channel for read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">buffer</span> <span class="o">*</span><span class="nx">RingBuffer</span> <span class="c1">// buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><code>in</code> 和 <code>out</code> 的职责在上篇文章已经说明，这里的 <code>buffer</code> 就是我们所谓的中间临时存储层。其中的 <code>RingBuffer</code> 结构我们后面再说。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewUnboundedChan</span><span class="p">(</span><span class="nx">initCapacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UnboundedChan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">NewUnboundedChanSize</span><span class="p">(</span><span class="nx">initCapacity</span><span class="p">,</span> <span class="nx">initCapacity</span><span class="p">,</span> <span class="nx">initCapacity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewUnboundedChanSize</span><span class="p">(</span><span class="nx">initInCapacity</span><span class="p">,</span> <span class="nx">initOutCapacity</span><span class="p">,</span> <span class="nx">initBufCapacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UnboundedChan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">in</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">initInCapacity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">initOutCapacity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">UnboundedChan</span><span class="p">{</span><span class="nx">In</span><span class="p">:</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">Out</span><span class="p">:</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">:</span> <span class="nf">NewRingBuffer</span><span class="p">(</span><span class="nx">initBufCapacity</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">process</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">ch</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>它提供了两个初始化 <code>UnboundedChan</code> 的方法，从代码中我们可以明显的看出,<code>NewUnboundedChanSize</code> 可以给每个属性自定义自己的容量大小。仅此而已。</p>
<p><code>chanx</code> 中 关于 <code>in</code> 和 <code>out</code> 都是带缓冲的通道，而上篇文章中的 <code>in</code> 和 <code>out</code> 都是无缓冲的通道。
这和他们对数据的流转处理有很大关系。</p>
<p>我们接下去看 <code>process(in,out,ch)</code> 最核心的方法。
<img src="https://image.syst.top/image/unlimited-2/unlimit-1.jpg" alt="image"></p>
<p>这时候，我们再放上一篇核心代码。</p>
<p><img src="https://image.syst.top/image/unlimited/unlimit-7.jpg" alt="image"></p>
<p>可以很明显他们看出它俩的区别。</p>
<p>上篇从 <code>in</code> 通道读数据会先 <code>append</code> 到 <code>buffer</code>，然后从 <code>buffer</code> 中取数据写入 <code>out</code> 通道。
而 <code>chanx</code> 从 <code>in</code> 通道取出数据先尝试写入 <code>out</code>(没有中间商赚差价?)，只有在 <code>out</code> 已经满的情况下，才塞入到 <code>buffer</code>。</p>
<p><code>chanx</code> 还有一段小细节代码。
<img src="https://image.syst.top/image/unlimited-2/unlimit-2.jpg" alt="image"></p>
<p>能走到这里，一定是因为 <code>out</code> 通道满了。我们把值追加到 <code>buffer</code> 的同时，需要尝试把 <code>buffer</code> 中的数据写入 <code>out</code> 。
此时 <code>in</code> 通道也许还在持续的写入数据， 为了避免 <code>in</code> 通道塞满，阻塞业务写入，我们同时需要尝试从 <code>in</code> 通道中读数据追加到 <code>buffer</code>。</p>
<h2 id="buffer">buffer</h2>
<p>上篇文章我提到了关于 <code>buffer</code> 优化的点。</p>
<p><code>chanx</code> 是如何优化的?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// type T interface{}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">RingBuffer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span>         <span class="p">[]</span><span class="nx">T</span> 
</span></span><span class="line"><span class="cl">	<span class="nx">initialSize</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">size</span>        <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span>           <span class="kt">int</span> <span class="c1">// read pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">w</span>           <span class="kt">int</span> <span class="c1">// write pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>这是 <code>buffer</code> 的结构，其中</p>
<ul>
<li><code>buf</code> 具体存储数据的结构。</li>
<li><code>initialSize</code> 初始化化 <code>buf</code> 的长度</li>
<li><code>size</code> 当前 <code>buf</code> 的长度</li>
<li><code>r</code> 当前读数据位置</li>
<li><code>w</code> 当前写入数据位置</li>
</ul>
<p><code>buffer</code> 本质上就是一个环形的队列，目的是达到资源的复用。
并且当 <code>buffer</code> 满时，提供自动扩容的功能。</p>
<p>我们来看具体把数据写入 <code>buffer</code> 的源码。
<img src="https://image.syst.top/image/unlimited-2/unlimit-3.png" alt="image"></p>
<p>接着看扩容。
<img src="https://image.syst.top/image/unlimited-2/unlimit-4.png" alt="image"></p>
<p>这段代码唯一难理解的就是数据迁移了。这里的数据迁移目的是为了保证先入先出的原则。</p>
<p>可能加了注释有些人也无法理解，那么就再加一个草率图。</p>
<p>假设我们 <code>buffer</code> 的长度是 8。 当前读和写的 <code>index</code> 都是5。说明 <code>buffer</code> 满了，触发自动扩容规则，进行数据迁移。</p>
<p>那么迁移的过程就是下图这样的。</p>
<p><img src="https://image.syst.top/image/unlimited-2/unlimit-5.png" alt="image"></p>
<p>还有，当 <code>buffer</code> 为空并且当前的 <code>size</code> 比初始化 <code>size</code> 还大，那么可以考虑重置 <code>buffer</code> 了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//if ch.buffer.IsEmpty() &amp;&amp; ch.buffer.size &gt; ch.buffer.initialSize { 
</span></span></span><span class="line"><span class="cl"><span class="c1">//						ch.buffer.Reset()
</span></span></span><span class="line"><span class="cl"><span class="c1">//					}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">initialSize</span>
</span></span><span class="line"><span class="cl"><span class="nx">r</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">initialSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>剩下的代码,就没什么好说的了。</p>
<h3 id="总结">总结</h3>
<p>继上篇文章后，这篇文章我们主要讲解了 <code>chanx</code> 是如何实现无限缓冲的 <code>channel</code>。
其中最重要的一个点在于 <code>chanx</code> 中 <code>buffer</code> 实现采用的是 <code>ringbuffer</code>，达到资源复用的同时还能自动扩容。</p>
]]></content>
		</item>
		
		<item>
			<title>hystrix-go使用与原理(二)</title>
			<link>https://www.syst.top/posts/go/hystrix-go%E4%BA%8C/</link>
			<pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/hystrix-go%E4%BA%8C/</guid>
			<description>开篇 上篇文章主要介绍了 hystrix-go 的使用以及原理，这篇文章让我们全面的解析源码。本文很长，请耐心看完。另外，由于直接放源码很是影响手机阅读体验，我把源码都截成图片了。
还是上篇的例子
大部分文章只是说明每个模块的职责和功能，考虑到如果只是单纯说明，读者还是很难把整体的流程连接起来。因此我打算从这个例子一步步解析。 就直接从开头 hystrix.ConfigureCommand 开始吧。 上篇文章提过，这个操作主要是为每个 commandName 自定义自己的规则配置。如果未自定义，那么会使用默认值。 最终会把配置值存储在 circuitSettings 这个 map类型中，它的初始化操作是在 init()执行的。 接下来执行 hystrix.Do，	Do 是一个同步的操作，它会阻塞等待，直到执行函数结束或者熔断器返回错误，如:断路器开启、超出最大并发数。 此函数需要三个参数，第一个参数表示 commandName 的名称，第二个参数就是正常的业务的匿名函数，比如在函数中进行外部服务调用。如果调用失败，那么就会执行第三个参数的操作，我们可以称之为保底操作，当熔断器开启的时候，系统也是会直接调用此函数。这两个参数的类型分别是匿名函数和闭包函数。 从图中可以看出，Do 函数只是把传入的后两个参数进一步封装成函数。然后调用 DoC。
Doc 函数第一个参数是上下文 context.Context。context.Context 一般出现在不同 Goroutine 之间同步指定数据。如果你使用过 gin 框架，经常和它打交道。
第三和第四的参数即 Do 中进一步包装的两个闭包函数。所谓闭包，我的理解是:存在自由的变量。这个自由的变量取决于运行闭包函数时的环境，在 DoC中, runFunc 和 fallbackFuncC 类型 也就是说这两个闭包的自由变量是 context.Context。
Doc函数中 变量 r 和 f 不再解释。由于我们在调用 Do函数时传递了第三个参数,因此执行 errChan = GoC(ctx, name, r, f)。最下面使用select 可以监控多 channel。当某个 channel 有数据时，从其中读取。我们接着往下看 GoC。
Goc是核心代码块。它是真正执行你的核心业务函数的地方。我先大体介绍一些这个函数核心功能。 它会先去验证一些规则，比如判断熔断器是否开启，决定当前是否可以执行你的业务。判断是否可以获取访问令牌。如果可以，执行你的业务逻辑，成功了上报成功的状态，失败了，除了上报状态，如果传入了异常处理的函数，那么执行异常处理的函数。另外还有一些归还令牌等操作。我们来看代码。 这段代码就不解释了吧。但是我们可以来看看 command 结构体中还有啥参数。 command 里面，关键的两个字段是 events 和 circuit。其实 events 主要是存储事件类型信息，比如执行成功的 success，或者失败的 timeout、context_canceled 等。 circuit 是指针类型 CircuitBreaker, CircuitBreaker就是真正的熔断器 。command 主要是记录单个执行的状态以及和熔断器进行一些运行交互。交互什么?</description>
			<content type="html"><![CDATA[<h3 id="开篇">开篇</h3>
<p>上篇文章主要介绍了 <code>hystrix-go</code> 的使用以及原理，这篇文章让我们全面的解析源码。本文很长，请耐心看完。另外，由于直接放源码很是影响手机阅读体验，我把源码都截成图片了。</p>
<p>还是上篇的例子</p>
<p><img src="https://cdn.learnku.com/uploads/images/202012/29/26855/kfaOfFI9ez.png!large" alt="">
大部分文章只是说明每个模块的职责和功能，考虑到如果只是单纯说明，读者还是很难把整体的流程连接起来。因此我打算从这个例子一步步解析。
就直接从开头 <code>hystrix.ConfigureCommand</code> 开始吧。
<img src="https://cdn.learnku.com/uploads/images/202012/29/26855/Twv8QvPbyR.png!large" alt=""></p>
<p>上篇文章提过，这个操作主要是为每个 <code>commandName</code> 自定义自己的规则配置。如果未自定义，那么会使用默认值。 最终会把配置值存储在 <code>circuitSettings</code> 这个 <code>map</code>类型中，它的初始化操作是在 <code>init()</code>执行的。
<img src="https://cdn.learnku.com/uploads/images/202012/29/26855/4j1xoqVqzB.png!large" alt="">
接下来执行 <code>hystrix.Do</code>，	<code>Do</code> 是一个同步的操作，它会阻塞等待，直到执行函数结束或者熔断器返回错误，如:断路器开启、超出最大并发数。
<img src="https://cdn.learnku.com/uploads/images/202012/29/26855/ENUcELdfsT.png!large" alt="">
此函数需要三个参数，第一个参数表示 <code>commandName</code> 的名称，第二个参数就是正常的业务的匿名函数，比如在函数中进行外部服务调用。如果调用失败，那么就会执行第三个参数的操作，我们可以称之为保底操作，当熔断器开启的时候，系统也是会直接调用此函数。这两个参数的类型分别是匿名函数和闭包函数。
<img src="https://cdn.learnku.com/uploads/images/202012/29/26855/Vn1Yot5vsx.png!large" alt="">
从图中可以看出，<code>Do</code> 函数只是把传入的后两个参数进一步封装成函数。然后调用 <code>DoC</code>。</p>
<p><img src="https://cdn.learnku.com/uploads/images/202012/29/26855/eJ89Y8YEHw.png!large" alt=""></p>
<p><code>Doc</code> 函数第一个参数是上下文 <code>context.Context</code>。<code>context.Context</code> 一般出现在不同 <code>Goroutine</code> 之间同步指定数据。如果你使用过 <code>gin</code> 框架，经常和它打交道。</p>
<p>第三和第四的参数即 <code>Do</code> 中进一步包装的两个闭包函数。所谓闭包，我的理解是:存在自由的变量。这个自由的变量取决于运行闭包函数时的环境，在 <code>DoC</code>中,<code> runFunc</code> 和 <code>fallbackFuncC</code> 类型
<img src="https://cdn.learnku.com/uploads/images/202012/29/26855/12x0zgb6ll.png!large" alt="hystrix-go 源码解析">
也就是说这两个闭包的自由变量是 <code>context.Context</code>。</p>
<p><code>Doc</code>函数中 变量 <code>r</code> 和 <code>f</code> 不再解释。由于我们在调用 <code>Do</code>函数时传递了第三个参数,因此执行 <code>errChan = GoC(ctx, name, r, f)</code>。最下面使用<code>select</code> 可以监控多 <code>channel</code>。当某个  <code>channel</code> 有数据时，从其中读取。我们接着往下看 <code>GoC</code>。</p>
<p><code>Goc</code>是核心代码块。它是真正执行你的核心业务函数的地方。我先大体介绍一些这个函数核心功能。
它会先去验证一些规则，比如判断熔断器是否开启，决定当前是否可以执行你的业务。判断是否可以获取访问令牌。如果可以，执行你的业务逻辑，成功了上报成功的状态，失败了，除了上报状态，如果传入了异常处理的函数，那么执行异常处理的函数。另外还有一些归还令牌等操作。我们来看代码。
<img src="https://cdn.learnku.com/uploads/images/202012/29/26855/2zG2xABgMO.png!large" alt="">
这段代码就不解释了吧。但是我们可以来看看 <code>command</code> 结构体中还有啥参数。
<img src="https://cdn.learnku.com/uploads/images/202012/29/26855/fpbWU6cyKp.png!large" alt="">
<code>command</code> 里面，关键的两个字段是 <code>events</code> 和 <code>circuit</code>。其实 <code>events</code> 主要是存储事件类型信息，比如执行成功的 <code>success</code>，或者失败的 <code>timeout</code>、<code>context_canceled</code> 等。 circuit 是指针类型 <code>CircuitBreaker</code>, <code>CircuitBreaker</code>就是真正的熔断器 。<code>command</code> 主要是记录单个执行的状态以及和熔断器进行一些运行交互。交互什么? 主要向 <code>CircuitBreaker</code> 上报执行状态事件。</p>
<p>接下来看下面的代码
<img src="https://cdn.learnku.com/uploads/images/202012/29/26855/vwYVVDHUsQ.png!large" alt="">
<code>GetCircuit(name)</code>，从函数名就知道是通过名称获取一个熔断器。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/fgMesgzwlm.png!large" alt="">
这个函数代码很清晰，如果没有从 <code>circuitBreakers</code>中查询到对应的 <code>CircuitBreaker</code>，那么就创建一个。</p>
<p>这里的代码有点小细节。首先 <code>circuitBreakers</code>是 <code>map</code> 类型，我们都知道 <code>map</code> 并不是并发安全的。所以在查找的的时候加了读锁。如果没找到值，那么解除读锁。尝试获取写锁，我们在写锁里面，又进一步确认是否存在<code>circuitBreakers</code>，为什么需要这样操作? 这是因为在我们释放读锁到获取写锁过程中有可能存在其他的 <code>Goroutine</code> 抢先一步创建。所以这里需要进一步确认，此时不存在，那就真的不存在，通过 <code>name</code> 生成一个 <code>circuitBreakers</code>。具体看下 <code>newCircuitBreaker(name)</code> 函数。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/aWyPBGteD6.png!large" alt="">
主要是初始化创建一个熔断器 <code>CircuitBreaker</code>操作，我们可以看看 <code>CircuitBreaker</code> 都有哪些字段。</p>
<p><img src="https://cdn.learnku.com/uploads/images/202012/30/26855/frqN8a2tWj.png!large" alt="一文读懂 hystrix-go 源码">
主要说明几个字段，<code>open</code> 表示当前熔断器是否开启，<code>executorPool</code> 是流量控制中心，所有的请求都需要先获取到令牌。<code>metrics</code> 的类型是 <code>*metricExchange</code>,可以看成是上报执行状态事件的载体。通过它把执行状态信息存储到实际熔断器执行各个维度状态(成功次数，失败次数，超时&hellip;&hellip;)的数据集合中。</p>
<p><code>newCircuitBreaker(name)</code> 初始化的同时也初始化了 <code>executorPool</code> 和 <code>metrics</code>。</p>
<p>先看 <code>newMetricExchange(name)</code>。看看它 <code>metricExchange</code> 结构
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/VkJb7VQ41k.png!large" alt="">
<code>Updates</code> 是一个 <code>channel</code> 类型，通过 <code>Updates</code> 上报执行事件集合。<code>metricCollectors</code> 存储的是 <code>metricCollector.MetricCollector</code> 切片，而 <code>metricCollector.MetricCollector</code> 是一个接口类型。</p>
<p><img src="https://cdn.learnku.com/uploads/images/202012/30/26855/36K9RaCfiC.png!large" alt="一文读懂 hystrix-go 源码"></p>
<p><code>newMetricExchange(name)</code> 中，
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/QMt69SGi7l.png!large" alt="">
可以看到，初始化 <code>Updates</code> 通道的的容量是 <code>2000</code>。初始化 <code>metricCollectors</code> 主要逻辑在 <code>InitializeMetricCollectors</code>。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/2J1yday7lA.png!large" alt="">
关键的地方我标明了。再看看 <code>newDefaultMetricCollector</code>
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/JWj5RbQxEf.png!large" alt="">
此函数返回一个 <code>MetricCollector</code> 类型，结构体 <code>DefaultMetricCollector</code> 实现了 <code>MetricCollector</code> 所有方法。再看看 <code>DefaultMetricCollector</code>，不正是存储熔断器执行状态所有信息嘛。看看指针类型 <code>rolling.Number</code>：
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/MEeJ15Zk69.png!large" alt="">
<code>rolling.Number</code> 是真正存储各个执行事件状态信息的底层存储结构。它是如何只保存 <code>10</code> 秒内的信息的。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/vkVXeOEHOe.png!large" alt="">
惊不惊喜？
<code>newMetricExchange(name)</code> 还有一个细节，会单独开启一个 <code>g</code> 运行  <code>go m.Monitor()</code>  去接收 <code>channel</code> 类型的 <code>Updates</code> 信息，即执行事件状态信息。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/oNJhRa2nEr.png!large" alt="">
在接收到事件信息后，调用 <code>IncrementMetrics</code> 先做状态信息的整合，最终把整合后的执行状态事件信息上报 <code>collector.Update(r)</code>。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/L1CUsHg6NP.png!large" alt=""></p>
<p><img src="https://cdn.learnku.com/uploads/images/202012/30/26855/iw35u2p7Vg.png!large" alt=""></p>
<p>接着回头看初始化流量控制中心 <code>newExecutorPool(name)</code>。先看看 <code>executorPool</code>结构。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/oJf8DzKrYA.png!large" alt="">
主要关注两个字段，<code>Tickets</code>表示的就是访问令牌带缓冲通道的 <code>channel</code> ，初始化 <code>channel</code> 容量取决于一开始你设置的<code>MaxConcurrentRequests </code>。当有请求到来时，从 <code>channel</code> 中拿出一个令牌，调用后重新归还。 <code>poolMetrics</code> 就是流量控制的具体指标。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/Tl4WyBnbah.png!large" alt=""></p>
<p><code>Executed</code>表示当前桶已经处理的请求数量。此外在 <code>newExecutorPool(name)</code> 函数中，和刚才套路一样，启动一个 <code>go m.Monitor()</code>   专门去更新当前桶的最大值。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/UQaHVMIHKw.png!large" alt="">
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/I1FTB6RksV.png!large" alt=""></p>
<p>到这里，<code>GetCircuit(name)</code> 获取一个熔断器的代码讲完了。
回到 <code>GoC</code> ，我们得到一个 <code>circuitBreakers</code> 的指针。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/HCMq26mFlm.png!large" alt="">
接下来我们创建一个条件变量 <code>sync.NewCond</code>。条件变量的场景是当共享资源发生变化时，通知那些被互斥锁锁住的线程。
在这里它是用来协调通知你可以归还访问令牌了。</p>
<p>接着有一句 <code>returnOnce := &amp;sync.Once{}</code>,关于 <code>sync.Once</code>,之前解析过一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzU3Mzc5NTU2MQ==&amp;tempkey=MTA5NF95VUwzVkc5bUNoWkNzZWtwQ1A1dXlPNGZTazVBS3RUZ3FOTDVxRmlGR3M3Tnk0YmJmLURhc1JkQTlkVFhEQ3FxQWRvUXFjeExXS0hBZ2ttVWNFdjR5cGRrUW5HbzJZdTZ2TzkyM2lfT0FIQU9wNzJOVmRHVWNMaTF2eF9odGppb0xVTEU3UzhLRTdieVlEY29NXzliODU3YWJsczhjc3BZblV0bVFRfn4%3D&amp;chksm=7d3d7a344a4af322ddae8dc18b7944c97eca68df27d7f7ff926ee59c89d6b5ba8b5f2de5a8e4#rd" title="你真的了解 sync.Once 吗">你真的了解 sync.Once 吗</a>。这里它存在的意义是什么? 我们往下看，就会发现其实到后面开启了两个 <code>Goroutine</code>。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/r87TmWEEGW.png!large" alt="">
它的作用是确保由最快那个 <code>Goroutine</code> 运行 <code>errWithFallback()</code> 和 <code>reportAllEvent()</code>，而且保证只会执行一次。</p>
<p>接着往下看，
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/UMDw3GhSuW.png!large" alt="一文读懂 hystrix-go 源码">
这个函数就是就是用来上报执行事件的。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/DlLsJohHro.png!large" alt=""></p>
<p>前面都好懂，我们从这段开始看：
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/3XV3I8nHPG.png!large" alt="">
这里操作这句话是什么意思？因为存在一种情况：当前熔断器是开启的，并且已经过了 <code>SleepWindow</code> 时间，此时请求就属于半开的状态，允许尝试执行，如果执行成功，那么就说明服务恢复了，可以关闭熔断器了。接下来，
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/xo6FXuJjxA.png!large" alt="">
组装执行状态状态事件，然后塞进 <code>Updates</code> 通道中。正好被初始化 <code>metricExchange</code> 另开的 <code>Goroutine</code> 接收，这样，这个上报流程就对应上了。</p>
<p>接下来就是刚才截图的两个 <code>Goroutine</code>,我们先看第一个。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/kSrIBnzDZp.png!large" alt=""></p>
<p>截图了上前半部分。上来一个 <code>defer func() { cmd.finished &lt;- true }()</code> 作为正常运行结束的通知。然后就是 <code>cmd.circuit.AllowRequest()</code>判断是否能请求。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/nTLNWvkzEE.png!large" alt="">
有两种情况可以往下走，第一种熔断器是关闭的。对应 <code>circuit.IsOpen()</code>。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/Mq6gtXmpGu.png!large" alt="">
首先判断熔断器是否被强制开启或者已经开启，如果是，直接返回 <code>true</code>。否则说明是当前熔断器处于关闭。接着判断过去十秒内各个桶值的和是否小于设置的 <code>RequestVolumeThreshold </code>值，如果小于，说明熔断器还应该是关闭状态，返回 <code>false</code> 。如果大于等于，那么应该进一步去判断错误百分比 是否超出自己的设置的<code>ErrorPercentThreshold </code>。如果超出了，那么说明错误率过高，此时需要开启熔断器。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/tZ1MK9ICVI.png!large" alt="">
这段代码很好懂，有意思的是 <code>int(errPct + 0.5)</code>。<code>+0.5</code> 是为了四舍五入，如果直接浮点数转换成整形，那么必然就是去除小数点。加了 <code>0.5</code>，那么假设 <code>ErrorPercentThreshold</code>设置 <code>50</code>，如果是 <code>&lt;45.5</code>,熔断器就继续关闭,否则开启熔断器。</p>
<p>如果<code>circuit.IsOpen()</code>不符合，那么再看 <code>circuit.allowSingleTest()</code>。虽然熔断器是开启的，但是如果当前的时间已经大于 （上次开启熔断器的时间+<code>SleepWindow </code> 的时间），这时候熔断器属于半开的状态，可以执行下一步。那么就会返回 <code>true</code>。</p>
<p>如果 <code>cmd.circuit.AllowRequest</code> 返回 <code>false</code>，那么就是执行 <code>returnTicket</code> 归还令牌(尽管这时候还没有令牌可言)。这段代码很有趣，通过变量  <code>ticketChecked</code>  加 <code>sync.NewCond</code> 实现的逻辑。<code>cmd.errorWithFallback()</code>，上报熔断器已开启事件(<code>circuit open</code>)以及运行 <code>fallBakck</code> 保底函数(如果存在的话)，执行结束，响应。</p>
<p><img src="https://cdn.learnku.com/uploads/images/202012/30/26855/UaVlqg18CJ.png!large" alt=""></p>
<p>如果返回 <code>true</code>，接着玩下走，</p>
<p><img src="https://cdn.learnku.com/uploads/images/202012/30/26855/beu0NFqgrd.png!large" alt="">
如果拿不到访问令牌，那么和刚才一样，上报当前请求已超过并发数事件(<code>max concurrency</code>)，运行保底操作，响应。</p>
<p>如果拿到访问令牌，那么真正执行自己的业务代码 <code>run(ctx)</code>。套路和上面相似。
再看第二个 <code>Goroutine</code>
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/bMP0fZPdsi.png!large" alt="">
三个 <code>case</code>分别表示:正常执行结束、业务执行被取消以及超时。至于为什么说 <code>Do</code>是同步操作，因为在 <code>Doc</code> 最后,
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/HBZXgbhOxA.png!large" alt="">，而 <code>Go</code> 则是一个异步过程。
到这里，从 <code>Do</code> 开始执行的大体流程就走完了。
最后我们可以直接给出它的大体流程图。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/YGB2gucOJF.png!large" alt="">
他们结构体之间的一些关系图。
<img src="https://cdn.learnku.com/uploads/images/202012/30/26855/56cG9Ir6NW.png!large" alt="">
分享 一些奇奇怪怪的东西</p>
<p><img src="https://cdn.learnku.com/uploads/images/202012/12/26855/d1Y1mxQjr9.webp!large" alt="图片"></p>
<p>👆 长按关注库里的深夜食堂</p>
]]></content>
		</item>
		
		<item>
			<title>为什么把 dig 迁移到 wire</title>
			<link>https://www.syst.top/posts/go/why-dig-to-wire/</link>
			<pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/why-dig-to-wire/</guid>
			<description>开篇 dig 和 wire 都是 Go 依赖注入的工具，那么，本质上功能相似的框架，为什么要从 dig 切换成 wire？
场景 我们从场景出发。
假设我们的项目分层是:router-&amp;gt;controller-&amp;gt;service-&amp;gt;dao。
大概就长这样:
现在我们需要对外暴露一个订单服务的接口。
首页看 main.go 文件。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;github.com/wuqinqiang/digvswire/dig&amp;#34; &amp;#34;github.com/wuqinqiang/digvswire/router&amp;#34; ) func main() { serverStart() } func serverStart() { defer func() { if err := recover(); err != nil { fmt.Printf(&amp;#34;init app err:%v\n&amp;#34;, err) } }() e := gin.Default() di := dig.ContainerByDig() err := router.RegisterRouter(e, di) if err != nil { fmt.Printf(&amp;#34;register router err:%v&amp;#34;, err) } _ = e.</description>
			<content type="html"><![CDATA[<h3 id="开篇">开篇</h3>
<p><code>dig</code> 和 <code>wire</code> 都是 <code>Go</code> 依赖注入的工具，那么，本质上功能相似的框架，为什么要从 <code>dig</code> 切换成 <code>wire</code>？</p>
<h3 id="场景">场景</h3>
<p>我们从场景出发。</p>
<p>假设我们的项目分层是:<code>router-&gt;controller-&gt;service-&gt;dao</code>。</p>
<p>大概就长这样:</p>
<p><img src="https://image.syst.top/image/dig-to-wire/1.png" alt="image"></p>
<p>现在我们需要对外暴露一个订单服务的接口。</p>
<p>首页看 <code>main.go</code> 文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/dig&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/router&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">serverStart</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">serverStart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;init app err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">di</span> <span class="o">:=</span> <span class="nx">dig</span><span class="p">.</span><span class="nf">ContainerByDig</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">router</span><span class="p">.</span><span class="nf">RegisterRouter</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">di</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;register router err:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8090&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里使用了 <code>gin</code> 启动项目。 然后我们查看 <code>dig.ContainerByDig()</code>，</p>
<h3 id="dig">dig</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">dig</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/controller&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/dao&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/server&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;go.uber.org/dig&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ContainerByDig</span><span class="p">()</span> <span class="o">*</span><span class="nx">dig</span><span class="p">.</span><span class="nx">Container</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">dig</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">dao</span><span class="p">.</span><span class="nx">NewOrderDao</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">d</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>首先通过 <code>dig.New()</code> 创建一个 <code>di</code> 容器。
<code>Provide</code> 函数用于添加服务提供者，  <code>Provide</code> 函数第一个参数本质上是一个函数。一个告诉容器 &ldquo;我能提供什么，为了提供它，我需要什么？&rdquo; 的函数。</p>
<p>比如我们看第二个 <code>server.NewOrderServer</code>,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">server</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/dao&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">_</span> <span class="nx">OrderServerInterface</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">OrderServer</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OrderServerInterface</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">GetUserOrderList</span><span class="p">(</span><span class="nx">userId</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="nx">dao</span><span class="p">.</span><span class="nx">Order</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OrderServer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">orderDao</span> <span class="nx">dao</span><span class="p">.</span><span class="nx">OrderDao</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewOrderServer</span><span class="p">(</span><span class="nx">order</span> <span class="nx">dao</span><span class="p">.</span><span class="nx">OrderDao</span><span class="p">)</span> <span class="nx">OrderServerInterface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">OrderServer</span><span class="p">{</span><span class="nx">orderDao</span><span class="p">:</span> <span class="nx">order</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">OrderServer</span><span class="p">)</span> <span class="nf">GetUserOrderList</span><span class="p">(</span><span class="nx">userId</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">orderList</span> <span class="p">[]</span><span class="nx">dao</span><span class="p">.</span><span class="nx">Order</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">o</span><span class="p">.</span><span class="nx">orderDao</span><span class="p">.</span><span class="nf">GetOrderListById</span><span class="p">(</span><span class="nx">userId</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里的 <code>NewOrderServer(xxx)</code> 在 <code>Provide</code> 中的语意就是 &ldquo;我能提供一个 <code>OrderServerInterface</code> 服务，但是我需要依赖一个 <code>dao.OrderDao</code>&quot;。</p>
<p>刚才的代码中，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">dao</span><span class="p">.</span><span class="nx">NewOrderDao</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>
</span></span></code></pre></div><p>因为我们的调用链是 <code>controller-&gt;server-&gt;dao</code>，那么本质上他们的依赖是 <code>controller&lt;-server&lt;-dao</code>，只是依赖的不是具体的实现，而是抽象的接口。</p>
<p>所以你看到 <code>Provide</code> 是按照依赖关系顺序写的。</p>
<p>其实完全没有必要，因为这一步 <code>dig</code> 只会对这些函数进行分析，提取函数的形参以及返回值。然后根据返回的参数来组织容器结构。
并不会在这一步执行传入的函数，所以在 <code>Provide</code> 阶段前后顺序并不重要，只要确保不遗漏依赖项即可。</p>
<p>万事俱备，我们开始注册一个能获取订单的路由，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">router</span><span class="p">.</span><span class="nf">RegisterRouter</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// router.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">RegisterRouter</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span><span class="p">,</span> <span class="nx">dig</span> <span class="o">*</span><span class="nx">dig</span><span class="p">.</span><span class="nx">Container</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">dig</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">handle</span> <span class="o">*</span><span class="nx">controller</span><span class="p">.</span><span class="nx">OrderHandler</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/user/orders&#34;</span><span class="p">,</span> <span class="nx">handle</span><span class="p">.</span><span class="nx">GetUserOrderList</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>此时，调用 <code>invoke</code>， 才是真正需要获取 <code>*controller.OrderHandler</code> 对象。</p>
<p>调用 <code>invoke</code> 方法，会对传入的参数做分析，参数中存在 <code>handle *controller.OrderHandler</code>, 就会去容器中寻找哪个 <code>Provide</code> 进来的函数返回类型是 <code>handle *controller.OrderHandler</code>,</p>
<p>就能对应找到,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 对应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewOrderHandler</span><span class="p">(</span><span class="nx">server</span> <span class="nx">server</span><span class="p">.</span><span class="nx">OrderServerInterface</span><span class="p">)</span> <span class="o">*</span><span class="nx">OrderHandler</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">OrderHandler</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">server</span><span class="p">:</span> <span class="nx">server</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>发现这个函数有形参 <code>server.OrderServerInterface</code>,那就去找对应返回此类型的函数，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//对应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewOrderServer</span><span class="p">(</span><span class="nx">order</span> <span class="nx">dao</span><span class="p">.</span><span class="nx">OrderDao</span><span class="p">)</span> <span class="nx">OrderServerInterface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">OrderServer</span><span class="p">{</span><span class="nx">orderDao</span><span class="p">:</span> <span class="nx">order</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>又发现形参 <code>（order dao.OrderDao)</code>,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">dao</span><span class="p">.</span><span class="nx">NewOrderDao</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//对应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewOrderDao</span><span class="p">()</span> <span class="nx">OrderDao</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">OrderDaoImpl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最后发现 <code>NewOrderDao</code> 没有依赖，不需要再查询依赖。开始执行函数的调用 <code>NewOrderDao()</code>，把返回的 <code>OrderDao</code> 传入到上层的 <code>NewOrderServer(order dao.OrderDao)</code> 进行函数调用，
<code>NewOrderServer(order dao.OrderDao)</code> 返回的 <code>OrderServerInterface</code> 继续返回到上层 <code>NewOrderHandler(server server.OrderServerInterface)</code> 执行调用，最后再把函数调用返回的 <code>*OrderHandler</code> 传递给 <code>dig.Invoke(func(handle *controller.OrderHandler) {}</code>,</p>
<p>整个链路就通了。用一个简陋的图来描述这个过程
<img src="https://image.syst.top/image/dig-to-wire/2.png" alt="image"></p>
<p><code>dig</code> 的整个流程采用的是反射机制，在运行时计算依赖关系，构造依赖对象。</p>
<p>这样会存在什么问题？</p>
<p>假设我现在注释掉 <code>Provide</code> 的一行代码，比如,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ContainerByDig</span><span class="p">()</span> <span class="o">*</span><span class="nx">dig</span><span class="p">.</span><span class="nx">Container</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">dig</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//_ = d.Provide(dao.NewOrderDao)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span><span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">d</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们在编译项目的时候并不会报任何错误，只会在运行时才发现缺少了依赖项。
<img src="https://image.syst.top/image/dig-to-wire/3.png" alt="image"></p>
<h3 id="wire">wire</h3>
<p>还是上面的代码，我们使用 <code>wire</code> 作为我们的 <code>DI</code> 容器。</p>
<p><code>wire</code> 也有两个核心概念: <code>Provider</code> 和 <code>Injector</code>。</p>
<p>其中 <code>Provider</code> 的概念和 <code>dig</code> 的概念是一样的:&ldquo;我能提供什么？我需要什么依赖&rdquo;。</p>
<p>比如下面 <code>wire.go</code> 中的代码,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//+build wireinject
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">wire</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/google/wire&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/controller&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/dao&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/server&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">orderSet</span> <span class="p">=</span> <span class="nx">wire</span><span class="p">.</span><span class="nf">NewSet</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dao</span><span class="p">.</span><span class="nx">NewOrderDao</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ContainerByWire</span><span class="p">()</span> <span class="o">*</span><span class="nx">controller</span><span class="p">.</span><span class="nx">OrderHandler</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wire</span><span class="p">.</span><span class="nf">Build</span><span class="p">(</span><span class="nx">orderSet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">controller</span><span class="p">.</span><span class="nx">OrderHandler</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其中，<code>dao.NewOrderDao</code> 、<code>server.NewOrderServer</code> 以及 <code>controller.NewOrderHandler</code> 就是 <code>Provider</code>。</p>
<p>你会发现这里还调用 <code>wire.NewSet</code> 把他们整合在一起，赋值给了一个变量 <code>orderSet</code>。</p>
<p>其实是用到 <code>ProviderSet</code> 的概念。原理就是把一组相关的 <code>Provider</code> 进行打包。</p>
<p>这样的好处是:</p>
<ul>
<li>结构依赖清晰，便于阅读。</li>
<li>以组的形式，减少 <code>injector</code> 里的 <code>Build</code>。</li>
</ul>
<p>至于 <code>injector</code>，本质上就是按照依赖关系调用 <code>Provider</code> 的函数，然后最终生成我们想要的对象(服务)。</p>
<p>比如上面的 <code>ContainerByWire()</code> 就是一个 <code>injector</code>。</p>
<p>那么 <code>wire.go</code> 文件整体的思路就是:定义好 <code>injector</code>，然后实现所需的 <code>Provider</code>。</p>
<p>最后在当前 <code>wire.go</code> 文件夹下执行 <code>wire</code> 命令后，</p>
<p>此时如果你的依赖项存在问题，那么就会报错提示。比如我现在隐藏上面的 <code>dao.NewOrderDao</code>,那么会出现
<img src="https://image.syst.top/image/dig-to-wire/4.png" alt="image"></p>
<p>如果依赖不存在问题，最终会生成一个 <code>wire_gen.go</code> 文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Code generated by Wire. DO NOT EDIT.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//go:generate go run github.com/google/wire/cmd/wire
</span></span></span><span class="line"><span class="cl"><span class="c1">//+build !wireinject
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">wire</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/google/wire&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/controller&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/dao&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/wuqinqiang/digvswire/server&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Injectors from wire.go:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ContainerByWire</span><span class="p">()</span> <span class="o">*</span><span class="nx">controller</span><span class="p">.</span><span class="nx">OrderHandler</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">orderDao</span> <span class="o">:=</span> <span class="nx">dao</span><span class="p">.</span><span class="nf">NewOrderDao</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">orderServerInterface</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">NewOrderServer</span><span class="p">(</span><span class="nx">orderDao</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">orderHandler</span> <span class="o">:=</span> <span class="nx">controller</span><span class="p">.</span><span class="nf">NewOrderHandler</span><span class="p">(</span><span class="nx">orderServerInterface</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">orderHandler</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// wire.go:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">orderSet</span> <span class="p">=</span> <span class="nx">wire</span><span class="p">.</span><span class="nf">NewSet</span><span class="p">(</span><span class="nx">dao</span><span class="p">.</span><span class="nx">NewOrderDao</span><span class="p">,</span> <span class="nx">server</span><span class="p">.</span><span class="nx">NewOrderServer</span><span class="p">,</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">NewOrderHandler</span><span class="p">)</span>
</span></span></code></pre></div><p>需要注意上面两个文件。我们看到 <code>wire.go</code> 中第一行 <code>//+build wireinject</code> ，这个 <code>build tag</code> 确保在常规编译时忽略 <code>wire.go</code> 文件。
而与之相对的 <code>wire_gen.go</code> 中的 <code>//+build !wireinject</code>。 两个对立的 <code>build tag</code> 是为了确保在任意情况下，两个文件只有一个文件生效，
避免出现 &ldquo;<code>ContainerByWire()</code> 方法被重新定义&rdquo; 的编译错误。</p>
<p>现在我们可以真正使用 <code>injector</code> 了，我们在入口文件中替换成 <code>dig</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">serverStart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;init app err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">router</span><span class="p">.</span><span class="nf">RegisterRouterByWire</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">wire</span><span class="p">.</span><span class="nf">ContainerByWire</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8090&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">RegisterRouterByWire</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span><span class="p">,</span> <span class="nx">handler</span> <span class="o">*</span><span class="nx">controller</span><span class="p">.</span><span class="nx">OrderHandler</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/v2/user/orders&#34;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">.</span><span class="nx">GetUserOrderList</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>一切正常。</p>
<p>当然 <code>wire</code> 有一个点需要注意，在 <code>wire.go</code> 文件中开头几行:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//+build wireinject
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">wire</span>
</span></span></code></pre></div><p><code>build tag</code> 和 <code>package</code> 他们之间是有空行的，如果没有空行，<code>build tag</code> 识别不了，那么编译的时候就会报重复声明的错误：
<img src="https://image.syst.top/image/dig-to-wire/5.png" alt="image"></p>
<p>还有很多高级的操作可以自行了解。</p>
<h3 id="总结">总结</h3>
<p>以上大体介绍了 go 中 <code>dig</code> 和 <code>wire</code> 两个 <code>DI</code> 工具。其中 <code>dig</code> 是通过运行时反射实现的依赖注入。
而 <code>wire</code> 是根据自定义的代码，通过命令，生成相应的依赖注入代码，在编译期就完成依赖注入，无需反射机制。
这样的好处是：</p>
<ul>
<li>方便排查，如果存在依赖错误，编译时就能发现。而 <code>dig</code> 只能在运行时才能发现依赖错误。</li>
<li>避免依赖膨胀，<code>wire</code> 生成的代码只包含被依赖的，而 <code>dig</code> 可能会存在好多无用依赖。</li>
<li>依赖关系静态存在源码，便于工具分析。</li>
</ul>
<h3 id="reference">Reference</h3>
<p>[1]
<a href="https://github.com/google/wire">https://github.com/google/wire</a></p>
<p>[2]
<a href="https://github.com/uber-go/dig">https://github.com/uber-go/dig</a></p>
<p>[3]
<a href="https://medium.com/@dche423/master-wire-cn-d57de86caa1b">https://medium.com/@dche423/master-wire-cn-d57de86caa1b</a></p>
<p>[4]
<a href="https://www.cnblogs.com/li-peng/p/14708132.html">https://www.cnblogs.com/li-peng/p/14708132.html</a></p>
]]></content>
		</item>
		
		<item>
			<title>在Go中你犯过的错</title>
			<link>https://www.syst.top/posts/go/mistake/</link>
			<pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/mistake/</guid>
			<description>在迭代器变量上使用 goroutine 这算高频吧。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) func main() { var wg sync.WaitGroup items := []int{1, 2, 3, 4, 5} for index, _ := range items { wg.Add(1) go func() { defer wg.Done() fmt.Printf(&amp;#34;item:%v\n&amp;#34;, items[index]) }() } wg.Wait() } 一个很简单的利用 sync.waitGroup 做任务编排的场景，看一下好像没啥问题，运行看看结果。
为啥不是1-5(当然不是顺序的)。
原因很简单，循环器中的 i 实际上是一个单变量，go func 里的闭包只绑定在一个变量上， 每个 goroutine 可能要等到循环结束才真正的运行，这时候运行的 i 值大概率就是5了, 没人能保证这个过程，有的只是手段。
正确的做法
func main() { var wg sync.WaitGroup items := []int{1, 2, 3, 4, 5} for index, _ := range items { wg.</description>
			<content type="html"><![CDATA[<h3 id="在迭代器变量上使用-goroutine">在迭代器变量上使用 goroutine</h3>
<p>这算高频吧。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">items</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v\n&#34;</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>一个很简单的利用 <code>sync.waitGroup</code> 做任务编排的场景，看一下好像没啥问题，运行看看结果。</p>
<p><img src="https://image.syst.top/image/mistake/mistake-1.png" alt="image"></p>
<p>为啥不是1-5(当然不是顺序的)。</p>
<p>原因很简单，循环器中的 i 实际上是一个单变量，<code>go func</code>  里的闭包只绑定在一个变量上，
每个 <code>goroutine</code> 可能要等到循环结束才真正的运行，这时候运行的 i 值大概率就是5了,
没人能保证这个过程，有的只是手段。</p>
<p>正确的做法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">items</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v\n&#34;</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>通过将 <code>i</code>  作为一个参数传入闭包中，i 每次迭代都会被求值，
并放置在 <code>goroutine</code> 的堆栈中，因此每个切片元素最终都会被执行打印。</p>
<p>或者这样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">i</span><span class="o">:=</span><span class="nx">index</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v\n&#34;</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><h3 id="waitgroup">WaitGroup</h3>
<p>上面的例子有用到 <code>sync.waitGroup</code>，使用不当，也会犯错。</p>
<p>我把上面的例子稍微改动复杂一点点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;errors&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/prometheus/common/log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">userId</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">userList</span> <span class="p">[]</span><span class="nx">User</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">userList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">userList</span><span class="p">,</span> <span class="nx">User</span><span class="p">{</span><span class="nx">userId</span><span class="p">:</span> <span class="nx">i</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">userList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">userList</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">log</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;err message:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 处理其他事务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">user</span> <span class="nx">User</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 处理杂七杂八的业务....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">user</span><span class="p">.</span><span class="nx">userId</span> <span class="o">==</span> <span class="mi">9</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 此人是非法用户
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="s">&#34;失败&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;非法用户&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="s">&#34;成功&#34;</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>发现问题严重性了吗？</p>
<p>当用户<code>id</code>等于9的时候，<code>err !=nil</code> 直接 <code>return</code> 了，导致 <code>waitGroup</code> 计数器根本没机会减1，
最终 <code>wait</code> 会阻塞，多么可怕的 <code>bug</code>。</p>
<p>在绝大多数的场景下，我们都必须这样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">userList</span> <span class="p">[]</span><span class="nx">User</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">userList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">userList</span><span class="p">,</span> <span class="nx">User</span><span class="p">{</span><span class="nx">userId</span><span class="p">:</span> <span class="nx">i</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">userList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">//....业务代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">//....业务代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">userList</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">log</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;err message:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="野生-goroutine">野生 goroutine</h3>
<p>我不知道你们公司是咋么处理异步操作的，是下面这样吗</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// doSomething
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// doSomething
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们为了防止程序中出现不可预知的 <code>panic</code>，导致程序直接挂掉，都会加入 <code>recover</code>，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;处理失败&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>但是如果这时候我们直接开启一个 <code>goroutine</code>，在这个 <code>goroutine</code> 里面发生了  <code>panic</code>，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;处理失败&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>此时最外层的 <code>recover</code> 并不能捕获，程序会直接挂掉。
<img src="https://image.syst.top/image/mistake/mistake-2.png" alt="image"></p>
<p>但是你总不能每次开启一个新的 <code>goroutine</code> 就在里面 <code>recover</code>,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// func1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;错误失败&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// func2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;请求错误&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>多蠢啊。所以基本上大家都会包一层。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// func1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;错误失败&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// func2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;请求错误&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">RunSafe</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">RunSafe</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;错误:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">fn</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当然我这里只是简单都打印一些日志信息，一般还会带上堆栈都信息。</p>
<h3 id="channel">channel</h3>
<p><code>channel</code> 在 <code>go</code> 中的地位实在太高了，各大开源项目到处都是 <code>channel</code> 的影子，
以至于你在工业级的项目 issues 中搜索 <code>channel</code> ，能看到很多的 <code>bug</code>，
比如 etcd 这个 <code>issue</code>,
<img src="https://image.syst.top/image/mistake/mistake-3.png" alt="image"></p>
<p>一个往已关闭的 <code>channel</code> 中发送数据引发的 <code>panic</code>,等等类似场景很多。</p>
<p>这个故事告诉我们，否管大不大佬，改写的 <code>bug</code> 还是会写，手动狗头。</p>
<p><code>channel</code> 除了上述高频出现的错误，还有以下几点:</p>
<h4 id="直接关闭一个-nil-值-channel-会引发-panic">直接关闭一个 nil 值 channel 会引发 panic</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="关闭一个已关闭的-channel-会引发-panic">关闭一个已关闭的 channel 会引发 panic。</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">  <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>另外，有时候使用 <code>channel</code> 不小心会导致 <code>goroutine</code> 泄露，比如下面这种情况,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cx</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine 结束&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;res&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">cx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;timeout&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>启动一个 <code>goroutine</code> 去处理业务，业务需要执行2秒，而我们设置的超时时间是1秒。
这就会导致 <code>channel</code> 从未被读取，
我们知道没有缓冲的 <code>channel</code> 必须等发送方和接收方都准备好才能操作。
此时 <code>goroutine</code> 会被永久阻塞在  <code>ch &lt;- struct{}{}</code> 这行代码，除非程序结束。
而这就是 <code>goroutine</code> 泄露。</p>
<p>解决这个也很简单，把无缓冲的 <code>channel</code> 改成缓冲为1。</p>
<h3 id="总结">总结</h3>
<p>这篇文章主要介绍了使用 <code>Go</code> 在日常开发中容易犯下的错。
当然还远远不止这些，你可以在下方留言中补充你犯过的错。</p>
]]></content>
		</item>
		
		<item>
			<title>如何优雅地实现并发编排任务</title>
			<link>https://www.syst.top/posts/go/mr/</link>
			<pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/mr/</guid>
			<description>业务场景 在做任务开发的时候，你们一定会碰到以下场景:
场景1：调用第三方接口的时候， 一个需求你需要调用不同的接口，做数据组装。 场景2:一个应用首页可能依托于很多服务。那就涉及到在加载页面时需要同时请求多个服务的接口。这一步往往是由后端统一调用组装数据再返回给前端，也就是所谓的 BFF(Backend For Frontend) 层。
针对以上两种场景，假设在没有强依赖关系下，选择串行调用，那么总耗时即:
time=s1+s2+....sn 按照当代秒入百万的有为青年，这么长时间早就把你祖宗十八代问候了一遍。
为了伟大的KPI，我们往往会选择并发地调用这些依赖接口。那么总耗时就是:
time=max(s1,s2,s3.....,sn) 当然开始堆业务的时候可以先串行化，等到上面的人着急的时候，亮出绝招。
这样，年底 PPT 就可以加上浓重的一笔流水账:为业务某个接口提高百分之XXX性能，间接产生XXX价值。
当然这一切的前提是，做老板不懂技术，做技术”懂”你。
言归正传,如果修改成并发调用，你可能会这么写，
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) func main() { var wg sync.WaitGroup wg.Add(2) var userInfo *User var productList []Product go func() { defer wg.Done() userInfo, _ = getUser() }() go func() { defer wg.Done() productList, _ = getProductList() }() wg.Wait() fmt.Printf(&amp;#34;用户信息:%+v\n&amp;#34;, userInfo) fmt.Printf(&amp;#34;商品信息:%+v\n&amp;#34;, productList) } /********用户服务**********/ type User struct { Name string Age uint8 } func getUser() (*User, error) { time.</description>
			<content type="html"><![CDATA[<h3 id="业务场景">业务场景</h3>
<p>在做任务开发的时候，你们一定会碰到以下场景:</p>
<p>场景1：调用第三方接口的时候， 一个需求你需要调用不同的接口，做数据组装。
场景2:一个应用首页可能依托于很多服务。那就涉及到在加载页面时需要同时请求多个服务的接口。这一步往往是由后端统一调用组装数据再返回给前端，也就是所谓的 BFF(Backend For Frontend) 层。</p>
<p>针对以上两种场景，假设在没有强依赖关系下，选择串行调用，那么总耗时即:</p>
<pre tabindex="0"><code>time=s1+s2+....sn
</code></pre><p>按照当代秒入百万的有为青年，这么长时间早就把你祖宗十八代问候了一遍。</p>
<p>为了伟大的KPI，我们往往会选择并发地调用这些依赖接口。那么总耗时就是:</p>
<pre tabindex="0"><code>time=max(s1,s2,s3.....,sn)
</code></pre><p>当然开始堆业务的时候可以先串行化，等到上面的人着急的时候，亮出绝招。</p>
<p>这样，年底 PPT 就可以加上浓重的一笔流水账:为业务某个接口提高百分之XXX性能，间接产生XXX价值。</p>
<p>当然这一切的前提是，做老板不懂技术，做技术”懂”你。</p>
<p>言归正传,如果修改成并发调用，你可能会这么写，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">userInfo</span> <span class="o">*</span><span class="nx">User</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">productList</span> <span class="p">[]</span><span class="nx">Product</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">userInfo</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">getUser</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">productList</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">getProductList</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;用户信息:%+v\n&#34;</span><span class="p">,</span> <span class="nx">userInfo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;商品信息:%+v\n&#34;</span><span class="p">,</span> <span class="nx">productList</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/********用户服务**********/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Age</span>  <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getUser</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">u</span> <span class="nx">User</span>
</span></span><span class="line"><span class="cl">	<span class="nx">u</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;wuqinqiang&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">u</span><span class="p">.</span><span class="nx">Age</span> <span class="p">=</span> <span class="mi">18</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">u</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/********商品服务**********/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Product</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Title</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Price</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getProductList</span><span class="p">()</span> <span class="p">([]</span><span class="nx">Product</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">400</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">list</span> <span class="p">[]</span><span class="nx">Product</span>
</span></span><span class="line"><span class="cl">	<span class="nx">list</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">Product</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Title</span><span class="p">:</span> <span class="s">&#34;SHib&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Price</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">list</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>先不管其他问题。从实现上来说，需要多少服务，你会开多少个 <code>G</code>，利用 <code>sync.WaitGroup</code> 的特性，
实现并发编排任务的效果。</p>
<p>好像，问题不大。</p>
<p>但是随着代号 <code>996</code> 业务场景的增加，你会发现，好多模块都有相似的功能，只是对应的业务场景不同而已。</p>
<p>那么我们能不能抽像出一套针对此业务场景的工具，而把具体业务实现交给业务方。</p>
<p>安排。</p>
<h3 id="使用">使用</h3>
<p>本着不重复造轮子的原则，去搜了下开源项目，最终看上了 <code>go-zero</code> 里面的一个工具 <code>mapreduce</code>。
从文件名我们能看出来是什么了，可以自行 <code>Google</code> 这个名词。</p>
<p>使用很简单。我们通过它改造一下上面的代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/tal-tech/go-zero/core/mr&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">userInfo</span> <span class="o">*</span><span class="nx">User</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">productList</span> <span class="p">[]</span><span class="nx">Product</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">mr</span><span class="p">.</span><span class="nf">Finish</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">userInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">getUser</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">productList</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">getProductList</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;用户信息:%+v\n&#34;</span><span class="p">,</span> <span class="nx">userInfo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;商品信息:%+v\n&#34;</span><span class="p">,</span> <span class="nx">productList</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><pre tabindex="0"><code>用户信息:&amp;{Name:wuqinqiang Age:18}
商品信息:[{Title:SHib Price:10}]
</code></pre><p>是不是舒服多了。</p>
<p>但是这里还需要注意一点，假设你调用的其中一个服务错误，并且你 <code>return err</code> 对应的错误，那么其他调用的服务会被取消。
比如我们修改 getProductList 直接响应错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getProductList</span><span class="p">()</span> <span class="p">([]</span><span class="nx">Product</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;test error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//打印
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">用户信息</span><span class="p">:&lt;</span><span class="kc">nil</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nx">商品信息</span><span class="p">:[]</span>
</span></span></code></pre></div><p>那么最终打印的时候连用户信息都会为空，因为出现一个服务错误，用户服务请求被取消了。</p>
<p>一般情况下，在请求服务错误的时候我们会有保底操作，一个服务错误不能影响其他请求的结果。
所以在使用的时候具体处理取决于业务场景。</p>
<h3 id="源码">源码</h3>
<p>既然用了，那么就追下源码吧。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Finish</span><span class="p">(</span><span class="nx">fns</span> <span class="o">...</span><span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">fns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">MapReduceVoid</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">source</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fns</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">source</span> <span class="o">&lt;-</span> <span class="nx">fn</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">writer</span> <span class="nx">Writer</span><span class="p">,</span> <span class="nx">cancel</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">item</span><span class="p">.(</span><span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">fn</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">cancel</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">pipe</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cancel</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">drain</span><span class="p">(</span><span class="nx">pipe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="nf">WithWorkers</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">fns</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MapReduceVoid</span><span class="p">(</span><span class="nx">generator</span> <span class="nx">GenerateFunc</span><span class="p">,</span> <span class="nx">mapper</span> <span class="nx">MapperFunc</span><span class="p">,</span> <span class="nx">reducer</span> <span class="nx">VoidReducerFunc</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">MapReduce</span><span class="p">(</span><span class="nx">generator</span><span class="p">,</span> <span class="nx">mapper</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">input</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">writer</span> <span class="nx">Writer</span><span class="p">,</span> <span class="nx">cancel</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">reducer</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">drain</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We need to write a placeholder to let MapReduce to continue on reducer done,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// otherwise, all goroutines are waiting. The placeholder will be discarded by MapReduce.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">writer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">lang</span><span class="p">.</span><span class="nx">Placeholder</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对于 <code>MapReduceVoid</code>函数，主要查看三个闭包参数。</p>
<ul>
<li>第一个 <code>GenerateFunc</code> 用于生产数据。</li>
<li><code>MapperFunc</code> 读取生产出的数据，进行处理。</li>
<li><code>VoidReducerFunc</code> 这里表示不对 <code>mapper</code> 后的数据做聚合返回。所以这个闭包在此操作几乎0作用。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MapReduce</span><span class="p">(</span><span class="nx">generate</span> <span class="nx">GenerateFunc</span><span class="p">,</span> <span class="nx">mapper</span> <span class="nx">MapperFunc</span><span class="p">,</span> <span class="nx">reducer</span> <span class="nx">ReducerFunc</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">source</span> <span class="o">:=</span> <span class="nf">buildSource</span><span class="p">(</span><span class="nx">generate</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">MapReduceWithSource</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">mapper</span><span class="p">,</span> <span class="nx">reducer</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">buildSource</span><span class="p">(</span><span class="nx">generate</span> <span class="nx">GenerateFunc</span><span class="p">)</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">source</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span><span class="c1">// 创建无缓冲通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">threading</span><span class="p">.</span><span class="nf">GoSafe</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">generate</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="c1">//开始生产数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">source</span> <span class="c1">//返回无缓冲通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><code>buildSource</code>函数中，返回一个无缓冲的通道。并开启一个 <code>G</code> 运行 <code>generate(source)</code>，往无缓冲通道塞数据。 这个<code>generate(source)</code> 不就是一开始 <code>Finish</code> 传递的第一个闭包参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">return</span> <span class="nf">MapReduceVoid</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">source</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 就这个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fns</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">source</span> <span class="o">&lt;-</span> <span class="nx">fn</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span></code></pre></div><p>然后查看 <code>MapReduceWithSource</code> 函数,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MapReduceWithSource</span><span class="p">(</span><span class="nx">source</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">mapper</span> <span class="nx">MapperFunc</span><span class="p">,</span> <span class="nx">reducer</span> <span class="nx">ReducerFunc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">options</span> <span class="o">:=</span> <span class="nf">buildOptions</span><span class="p">(</span><span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//任务执行结束通知信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">output</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//将mapper处理完的数据写入collector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">collector</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">options</span><span class="p">.</span><span class="nx">workers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 取消操作信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">done</span> <span class="o">:=</span> <span class="nx">syncx</span><span class="p">.</span><span class="nf">NewDoneChan</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">writer</span> <span class="o">:=</span> <span class="nf">newGuardedWriter</span><span class="p">(</span><span class="nx">output</span><span class="p">,</span> <span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">closeOnce</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">retErr</span> <span class="nx">errorx</span><span class="p">.</span><span class="nx">AtomicError</span>
</span></span><span class="line"><span class="cl">	<span class="nx">finish</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">closeOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">done</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nb">close</span><span class="p">(</span><span class="nx">output</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cancel</span> <span class="o">:=</span> <span class="nf">once</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">retErr</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">retErr</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">ErrCancelWithNil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">drain</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">finish</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">cancel</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">finish</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">		<span class="nf">reducer</span><span class="p">(</span><span class="nx">collector</span><span class="p">,</span> <span class="nx">writer</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">drain</span><span class="p">(</span><span class="nx">collector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 真正从生成器通道取数据执行Mapper
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nf">executeMappers</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">w</span> <span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">mapper</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">collector</span><span class="p">,</span> <span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">(),</span> <span class="nx">options</span><span class="p">.</span><span class="nx">workers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">output</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">retErr</span><span class="p">.</span><span class="nf">Load</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrReduceNoOutput</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这段代码挺长的，我们说下核心的点。我们看到使用一个<code>G</code> 调用 <code>executeMappers</code> 方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">go</span> <span class="nf">executeMappers</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">w</span> <span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">mapper</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">collector</span><span class="p">,</span> <span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">(),</span> <span class="nx">options</span><span class="p">.</span><span class="nx">workers</span><span class="p">)</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">executeMappers</span><span class="p">(</span><span class="nx">mapper</span> <span class="nx">MapFunc</span><span class="p">,</span> <span class="nx">input</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">collector</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{},</span>
</span></span><span class="line"><span class="cl">	<span class="nx">done</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">lang</span><span class="p">.</span><span class="nx">PlaceholderType</span><span class="p">,</span> <span class="nx">workers</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 等待所有任务全部执行完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 关闭通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nb">close</span><span class="p">(</span><span class="nx">collector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//根据指定数量创建 worker池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pool</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">lang</span><span class="p">.</span><span class="nx">PlaceholderType</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">	<span class="nx">writer</span> <span class="o">:=</span> <span class="nf">newGuardedWriter</span><span class="p">(</span><span class="nx">collector</span><span class="p">,</span> <span class="nx">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">pool</span> <span class="o">&lt;-</span> <span class="nx">lang</span><span class="p">.</span><span class="nx">Placeholder</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 从buildSource() 返回的无缓冲通道取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">item</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">input</span> 
</span></span><span class="line"><span class="cl">			<span class="c1">// 当通道关闭，结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="o">&lt;-</span><span class="nx">pool</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// better to safely run caller defined method
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">threading</span><span class="p">.</span><span class="nf">GoSafe</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">					<span class="o">&lt;-</span><span class="nx">pool</span>
</span></span><span class="line"><span class="cl">				<span class="p">}()</span>
</span></span><span class="line"><span class="cl">				<span class="c1">//真正运行闭包函数的地方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="c1">// func(item interface{}, w Writer) {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="c1">//    mapper(item, w, cancel)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="c1">//    }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nf">mapper</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">})</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>具体的逻辑已备注，代码很容易懂。</p>
<p>一旦 <code>executeMappers</code> 函数返回，关闭 <code>collector</code> 通道，那么执行 <code>reducer</code> 不再阻塞。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">cancel</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">finish</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">		<span class="nf">reducer</span><span class="p">(</span><span class="nx">collector</span><span class="p">,</span> <span class="nx">writer</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">drain</span><span class="p">(</span><span class="nx">collector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span></code></pre></div><p>这里的 <code>reducer(collector, writer, cancel)</code> 其实就是从 <code>MapReduceVoid</code> 传递的第三个闭包函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MapReduceVoid</span><span class="p">(</span><span class="nx">generator</span> <span class="nx">GenerateFunc</span><span class="p">,</span> <span class="nx">mapper</span> <span class="nx">MapperFunc</span><span class="p">,</span> <span class="nx">reducer</span> <span class="nx">VoidReducerFunc</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">MapReduce</span><span class="p">(</span><span class="nx">generator</span><span class="p">,</span> <span class="nx">mapper</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">input</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">writer</span> <span class="nx">Writer</span><span class="p">,</span> <span class="nx">cancel</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">reducer</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">drain</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We need to write a placeholder to let MapReduce to continue on reducer done,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// otherwise, all goroutines are waiting. The placeholder will be discarded by MapReduce.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">writer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">lang</span><span class="p">.</span><span class="nx">Placeholder</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然后这个闭包函数又执行了 <code>reducer(input, cancel)</code>，这里的 <code>reducer</code> 就是我们一开始解释过的 <code>VoidReducerFunc</code>，从 <code>Finish() 而来</code>。</p>
<p><img src="https://image.syst.top/image/mr/mr.png" alt="image"></p>
<p>等等,看到上面三个地方的 <code>drain(input)</code>了吗？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// drain drains the channel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">drain</span><span class="p">(</span><span class="nx">channel</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// drain the channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="k">range</span> <span class="nx">channel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其实就是一个排空 <code>channel</code> 的操作，但是三个地方都对同一个 <code>channel</code>,也是让我费解。</p>
<p>还有更重要的一点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">cancel</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">finish</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">		<span class="nf">reducer</span><span class="p">(</span><span class="nx">collector</span><span class="p">,</span> <span class="nx">writer</span><span class="p">,</span> <span class="nx">cancel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">drain</span><span class="p">(</span><span class="nx">collector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span></code></pre></div><p>上面的代码，假如执行 <code>reducer</code>，<code>writer</code> 写入引发 <code>panic</code>,那么<code>drain(collector)</code> 会直接卡住。</p>
<p>不过作者已经修复了这个问题，直接把 <code>drain(collector)</code> 放入到 <code>defer</code>。
<img src="https://image.syst.top/image/mr/mr-2.png" alt="image"></p>
<p>具体 issues[1]。</p>
<p>到这里，关于 <code>Finish</code> 的源码也就结束了。感兴趣的可以看看其他源码。</p>
<p>很喜欢 <code>go-zero</code> 里的一些工具，但是往往用的一些工具并不独立，
依赖于其他文件包，导致明明只想使用其中一个工具却需要安装整个包。
所以最终的结果就是扒源码，创建无依赖库工具集，遵循 <code>MIT</code> 即可。</p>
<p>附录
[1]
<a href="https://github.com/tal-tech/go-zero/issues/676">https://github.com/tal-tech/go-zero/issues/676</a></p>
]]></content>
		</item>
		
		<item>
			<title>hystrix-go使用与原理(一)</title>
			<link>https://www.syst.top/posts/go/hystrix-go/</link>
			<pubDate>Sat, 17 Apr 2021 22:24:32 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/hystrix-go/</guid>
			<description>开篇 这周在看内部一个熔断限流包时，发现它是基于一个开源项目 hystrix-go 实现了，因此有了这篇文章。
Hystrix Hystrix 是由 Netflex  开发的一款开源组件，提供了基础的熔断功能。 Hystrix 将降级的策略封装在 Command 中，提供了 run 和 fallback 两个方法，前者表示正常的逻辑，比如微服务之间的调用&amp;hellip;&amp;hellip;，如果发生了故障，再执行 fallback方法返回结果，我们可以把它理解成保底操作。如果正常逻辑在短时间内频繁发生故障，那么可能会触发短路，也就是之后的请求不再执行 run,而是直接执行 fallback。更多关于 Hystrix 的信息可以查看 https://github.com/Netflix/Hystrix，而 hystrix-go 则是用 go 实现的 hystrix 版，更确切的说，是简化版。只是上一次更新还是 2018年 的一次 pr,也就毕业了？
为什么需要这些工具？ 比如一个微服务化的产品线上，每一个服务都专注于自己的业务，并对外提供相应的服务接口，或者依赖于外部服务的某个逻辑接口，就像下面这样。 假设我们当前是 服务A，有部分逻辑依赖于 服务C，服务C 又依赖于 服务E,当前微服务之间进行 rpc或者 http通信，假设此时 服务C 调用 服务E 失败,比如由于网络波动导致超时或者服务E由于过载，系统E 已经down掉了。 调用失败，一般会有失败重试等机制。但是再想想，假设服务E已然不可用的情况下，此时新的调用不断产生，同时伴随着调用等待和失败重试，会导致 服务C对服务E的调用而产生大量的积压，慢慢会耗尽服务C的资源，进而导致服务C也down掉，这样恶性循环下，会影响到整个微服务体系，产生雪崩效应。 虽然导致雪崩的发生不仅仅这一种，但是我们需要采取一定的措施，来保证不让这个噩梦发生。而 hystrix-go就很好的提供了 熔断和降级的措施。它的主要思想在于，设置一些阀值，比如最大并发数(当并发数大于设置的并发数，拦截)，错误率百分比(请求数量大于等于设置 的阀值，并且错误率达到设置的百分比时，触发熔断)以及熔断尝试恢复时间等 。
使用 hystrix-go 的使用非常简单，你可以调用它的 Go 或者 Do方法，只是 Go 方法是异步的方式。而 Do 方法是同步方式。我们从一个简单的例子开启。
_ = hystrix.Do(&amp;#34;wuqq&amp;#34;, func() error { // talk to other services 	_, err := http.</description>
			<content type="html"><![CDATA[<h2 id="开篇">开篇</h2>
<p>这周在看内部一个熔断限流包时，发现它是基于一个开源项目 <code>hystrix-go</code> 实现了，因此有了这篇文章。</p>
<h3 id="hystrix">Hystrix</h3>
<p><code>Hystrix</code> 是由 <code>Netflex </code> 开发的一款开源组件，提供了基础的熔断功能。 <code>Hystrix</code> 将降级的策略封装在 <code>Command</code> 中，提供了 <code>run</code> 和 <code>fallback</code> 两个方法，前者表示正常的逻辑，比如微服务之间的调用&hellip;&hellip;，如果发生了故障，再执行 <code>fallback</code>方法返回结果，我们可以把它理解成保底操作。如果正常逻辑在短时间内频繁发生故障，那么可能会触发短路，也就是之后的请求不再执行 <code>run</code>,而是直接执行  <code>fallback</code>。更多关于 <code>Hystrix</code> 的信息可以查看 <code>https://github.com/Netflix/Hystrix</code>，而
<code>hystrix-go</code> 则是用 <code>go</code> 实现的 <code>hystrix</code> 版，更确切的说，是简化版。只是上一次更新还是 2018年 的一次 <code>pr</code>,也就毕业了？</p>
<p>为什么需要这些工具？
比如一个微服务化的产品线上，每一个服务都专注于自己的业务，并对外提供相应的服务接口，或者依赖于外部服务的某个逻辑接口，就像下面这样。
<img src="https://cdn.learnku.com/uploads/images/202012/27/26855/vZWmoZYanE.png!large" alt=""></p>
<p>假设我们当前是 <code>服务A</code>，有部分逻辑依赖于 <code>服务C</code>，<code>服务C</code> 又依赖于 <code>服务E</code>,当前微服务之间进行 <code>rpc</code>或者 <code>http</code>通信，假设此时 <code>服务C</code> 调用 服务E 失败,比如由于网络波动导致超时或者服务E由于过载，系统E 已经down掉了。
<img src="https://cdn.learnku.com/uploads/images/202012/27/26855/0IuLV2g9Pk.png!large" alt=""></p>
<p>调用失败，一般会有失败重试等机制。但是再想想，假设服务E已然不可用的情况下，此时新的调用不断产生，同时伴随着调用等待和失败重试，会导致 服务C对服务E的调用而产生大量的积压，慢慢会耗尽服务C的资源，进而导致服务C也down掉，这样恶性循环下，会影响到整个微服务体系，产生雪崩效应。
<img src="https://cdn.learnku.com/uploads/images/202012/27/26855/OChf6d4cTz.png!large" alt=""></p>
<p>虽然导致雪崩的发生不仅仅这一种，但是我们需要采取一定的措施，来保证不让这个噩梦发生。而 <code>hystrix-go</code>就很好的提供了 熔断和降级的措施。它的主要思想在于，设置一些阀值，比如最大并发数(当并发数大于设置的并发数，拦截)，错误率百分比(请求数量大于等于设置 的阀值，并且错误率达到设置的百分比时，触发熔断)以及熔断尝试恢复时间等 。</p>
<h3 id="使用">使用</h3>
<p><code>hystrix-go</code> 的使用非常简单，你可以调用它的 <code>Go</code> 或者 <code>Do</code>方法，只是 <code>Go</code> 方法是异步的方式。而 <code>Do</code>  方法是同步方式。我们从一个简单的例子开启。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">hystrix</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;wuqq&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// talk to other services
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;https://www.baidu.com/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;get error:%v&#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;handle  error:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span></code></pre></div><p><code>Do</code> 函数需要三个参数，第一个参数 <code>commmand</code> 名称，你可以把每个名称当成一个独立当服务，第二个参数是处理正常的逻辑，比如 <code>http</code> 调用服务，返回参数是 <code>err</code>。如果处理|调用失败，那么就执行第三个参数逻辑， 我们称为保底操作。由于服务错误率过高导致熔断器开启，那么之后的请求也直接回调此函数。</p>
<p>既然熔断器是按照配置的规则而进行是否开启的操作，那么我们当然可以设置我们想要的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">hystrix</span><span class="p">.</span><span class="nf">ConfigureCommand</span><span class="p">(</span><span class="s">&#34;wuqq&#34;</span><span class="p">,</span> <span class="nx">hystrix</span><span class="p">.</span><span class="nx">CommandConfig</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Timeout</span><span class="p">:</span>                <span class="nb">int</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MaxConcurrentRequests</span><span class="p">:</span>  <span class="mi">10</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">SleepWindow</span><span class="p">:</span>            <span class="mi">5000</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">RequestVolumeThreshold</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ErrorPercentThreshold</span><span class="p">:</span>  <span class="mi">30</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">hystrix</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;wuqq&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// talk to other services
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;https://www.baidu.com/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;get error:%v&#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;handle  error:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span></code></pre></div><p>稍微解释一下上面配置的值含义:</p>
<ul>
<li>Timeout: 执行 <code>command</code> 的超时时间。</li>
<li>MaxConcurrentRequests：<code>command</code> 的最大并发量 。</li>
<li>SleepWindow：当熔断器被打开后，<code>SleepWindow</code> 的时间就是控制过多久后去尝试服务是否可用了。</li>
<li>RequestVolumeThreshold： 一个统计窗口10秒内请求数量。达到这个请求数量后才去判断是否要开启熔断</li>
<li>ErrorPercentThreshold：错误百分比，请求数量大于等于<code>RequestVolumeThreshold</code>并且错误率到达这个百分比后就会启动<code>熔断</code></li>
</ul>
<p>当然你不设置的话，那么自动走的默认值。
<img src="https://cdn.learnku.com/uploads/images/202012/27/26855/VX87CNHDs1.png!large" alt=""></p>
<p>我们再来看一个简单的例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">   <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;github.com/afex/hystrix-go/hystrix&#34;</span> <span class="s">&#34;net/http&#34;</span> <span class="s">&#34;time&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Handle</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">Handle</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">r</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">request</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">h</span><span class="p">.</span><span class="nf">Common</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">Handle</span><span class="p">)</span> <span class="nf">Common</span><span class="p">(</span><span class="nx">r</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">request</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">hystrix</span><span class="p">.</span><span class="nf">ConfigureCommand</span><span class="p">(</span><span class="s">&#34;mycommand&#34;</span><span class="p">,</span> <span class="nx">hystrix</span><span class="p">.</span><span class="nx">CommandConfig</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">Timeout</span><span class="p">:</span>                <span class="nb">int</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nx">MaxConcurrentRequests</span><span class="p">:</span>  <span class="mi">10</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">SleepWindow</span><span class="p">:</span>            <span class="mi">5000</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">RequestVolumeThreshold</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ErrorPercentThreshold</span><span class="p">:</span>  <span class="mi">30</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="p">})</span>
</span></span><span class="line"><span class="cl">   <span class="nx">msg</span> <span class="o">:=</span> <span class="s">&#34;success&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">_</span> <span class="p">=</span> <span class="nx">hystrix</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;mycommand&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;https://www.baidu.com&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;请求失败:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;handle  error:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">msg</span> <span class="p">=</span> <span class="s">&#34;error&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl">   <span class="nx">r</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">msg</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8090&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">Handle</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们开启了一个 <code>http</code> 服务，监听端口号 <code>8090</code>，所有请求的处理逻辑都在  <code>Common </code> 方法中，在这个方法中，我们主要是发起一次 <code>http</code>请求，请求成功响应<code> success</code>,如果失败，响应失败原因。</p>
<p>我们再写另一个简单程序，并发 <code>11</code> 次的请求 <code>8090</code> 端口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;io/ioutil&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Transport</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MaxIdleConns</span><span class="p">:</span>    <span class="mi">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">IdleConnTimeout</span><span class="p">:</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span><span class="nx">Transport</span><span class="p">:</span> <span class="nx">tr</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">info</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span> <span class="kd">interface</span><span class="p">{}</span> <span class="s">`json:&#34;data&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">11</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">int2</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;http://localhost:8090&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化http客户端处错误:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化http客户端处错误:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">nByte</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;读取http数据失败:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;接收到到值:%v\n&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">nByte</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;请求完毕\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>由于我们配置 <code>MaxConcurrentRequests</code> 为10，那么意味着还有个 g 请求会失败:
<img src="https://cdn.learnku.com/uploads/images/202012/27/26855/lUriDTdjlP.png!large" alt="">
和我们想的一样。</p>
<p>接着我们把网络断开，并发请求改成10次。再次运行程序并发请求 <code>8090</code> 端口，此时由于网络已关闭，导致请求百度失败：
<img src="https://cdn.learnku.com/uploads/images/202012/27/26855/I2axDFfuxj.png!large" alt="">
接着继续请求：
<img src="https://cdn.learnku.com/uploads/images/202012/27/26855/LzJiOB1FZb.png!large" alt="">
熔断器已开启，上面我们配置的<code>RequestVolumeThreshold</code> 和 <code>ErrorPercentThreshold</code> 生效。</p>
<p>然后我们把网连上，五秒后 (<code>SleepWindow</code>的值)继续并发调用，当前熔断器处于半开的状态，此时请求允许调用依赖，如果成功则关闭，失败则继续开启熔断器。
<img src="https://cdn.learnku.com/uploads/images/202012/27/26855/BqrjYC5RJW.png!large" alt="">
可以看到，有一个成功了，那么此时熔断器已关闭，接下来继续运行函数并发调用：
<img src="https://cdn.learnku.com/uploads/images/202012/27/26855/yMb2jZVBOl.png!large" alt="">
可以看到，10个都已经是正常成功的状态了。</p>
<p>那么问题来了，为什么最上面的图只有一个是成功的？5秒已经过了，并且当前网络正常，应该是10个请求都成功，但是我们看到的只有一个是成功状态。通过源码我们可以找到答案:
具体逻辑在判断当前请求是否可以调用依赖</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">!</span><span class="nx">cmd</span><span class="p">.</span><span class="nx">circuit</span><span class="p">.</span><span class="nf">AllowRequest</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">......</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">circuit</span> <span class="o">*</span><span class="nx">CircuitBreaker</span><span class="p">)</span> <span class="nf">AllowRequest</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">!</span><span class="nx">circuit</span><span class="p">.</span><span class="nf">IsOpen</span><span class="p">()</span> <span class="o">||</span> <span class="nx">circuit</span><span class="p">.</span><span class="nf">allowSingleTest</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">circuit</span> <span class="o">*</span><span class="nx">CircuitBreaker</span><span class="p">)</span> <span class="nf">allowSingleTest</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">circuit</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">openedOrLastTestedTime</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">openedOrLastTestedTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">open</span> <span class="o">&amp;&amp;</span> <span class="nx">now</span> <span class="p">&gt;</span> <span class="nx">openedOrLastTestedTime</span><span class="o">+</span><span class="nf">getSettings</span><span class="p">(</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">Name</span><span class="p">).</span><span class="nx">SleepWindow</span><span class="p">.</span><span class="nf">Nanoseconds</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">/</span>
</span></span><span class="line"><span class="cl">		<span class="nx">swapped</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">openedOrLastTestedTime</span><span class="p">,</span> <span class="nx">openedOrLastTestedTime</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span> <span class="c1">//这一句才是关键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">swapped</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;hystrix-go: allowing single test to possibly close circuit %v&#34;</span><span class="p">,</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">swapped</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这段代码首先判断了熔断器是否开启，并且当前时间大于 上一次开启熔断器的时间+ <code>SleepWindow</code> 的时间，如果条件都符合的话，更新此熔断器最新的 <code>openedOrLastTestedTime </code> ,是通过  <code>CompareAndSwapInt64 </code> 原子操作完成的，意外着必然只会有一个成功。
此时熔断器还是半开的状态，接着如果能拿到令牌，执行<code>run</code> 函数（也就是Do传入的第二个简单封装后的函数），发起 <code>http</code> 请求，如果成功，上报成功状态，关闭熔断器。如果失败，那么熔断器依旧开启。
<img src="https://cdn.learnku.com/uploads/images/202012/27/26855/sLDxoIvR4J.png!large" alt=""></p>
<p><img src="https://cdn.learnku.com/uploads/images/202012/27/26855/ChLKeOHULy.png!large" alt="hystrix-go源码解析"></p>
<p>以上就是大体的流程讲解，下一篇文章将解读核心源码以及进一步当思考。</p>
]]></content>
		</item>
		
		<item>
			<title>etcd 实战基础篇(一) </title>
			<link>https://www.syst.top/posts/go/etcd-2021-04-10/</link>
			<pubDate>Sat, 10 Apr 2021 09:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/etcd-2021-04-10/</guid>
			<description>最近一直在看 etcd 相关的东西，为了不&amp;quot;白看&amp;quot;，加深理解，随即开启此系列的输出。
Etcd是什么 Etcd 是由 Go 编写的。它是一个强一致性的分布式键值存储，提供一种可靠的方式来存储需要由分布式系统或者机器集群访问的数据。 同时 Etcd 各节点中的通信是通过 Raft 一致性算法来处理的。 有很多大型开源项目的底层都基于 Etcd，举几个比较有名的工业级项目:kubernetes、 CoreDNS、ROOK&amp;hellip;&amp;hellip;
Etcd 的场景  服务发现。(可以把服务存储到某个 prefix 开头的 key中，然后消费端或者服务信息以调用， 同时消费者也可以通过 watch 获得 key 的变化) 消息分布和订阅 分布式锁 Leader 选举 分布式队列 负载均衡 &amp;hellip;&amp;hellip;  和 redis 的区别 面试的时候可能有面试官喜欢问，
 redis 的数据类型更丰富(string, hash, set ,zset, list)，etcd 仅仅就是 key-val。 etcd 的底层是 Raft 算法，可以保证数据的强一致性。而 redis 数据复制上是主备异步复制，只能最终一致性。 读写性能上，因为 etcd 保证强一致性，所以会比 redis 差。 存储方面，etcd 使用的是持久化存储boltdb，而 redis 的方案是可持久化的 aof/rdb -&amp;hellip;&amp;hellip;  环境与说明 直接下载编译好的二进制文件也好，还是自己下载源码编译运行，先开启一个单节点服务就行。我本地使用 goreman 搭建了三个实例。 这里稍微说明一下:PEER ADDRS 指的是向其他 etcd server 暴露的通信地址,比如上图 name=infra1 要调用 infra2， 调用的就是 http://127.</description>
			<content type="html"><![CDATA[<p>最近一直在看 etcd 相关的东西，为了不&quot;白看&quot;，加深理解，随即开启此系列的输出。</p>
<h3 id="etcd是什么">Etcd是什么</h3>
<p>Etcd 是由 Go 编写的。它是一个强一致性的分布式键值存储，提供一种可靠的方式来存储需要由分布式系统或者机器集群访问的数据。 同时 Etcd 各节点中的通信是通过 Raft 一致性算法来处理的。
有很多大型开源项目的底层都基于 Etcd，举几个比较有名的工业级项目:kubernetes、 CoreDNS、ROOK&hellip;&hellip;</p>
<h3 id="etcd-的场景">Etcd 的场景</h3>
<ul>
<li>服务发现。(可以把服务存储到某个 prefix 开头的 key中，然后消费端或者服务信息以调用， 同时消费者也可以通过 watch 获得 key 的变化)</li>
<li>消息分布和订阅</li>
<li>分布式锁</li>
<li>Leader 选举</li>
<li>分布式队列</li>
<li>负载均衡</li>
<li>&hellip;&hellip;</li>
</ul>
<h3 id="和-redis-的区别">和 redis 的区别</h3>
<p>面试的时候可能有面试官喜欢问，</p>
<ul>
<li>redis 的数据类型更丰富(string, hash, set ,zset, list)，etcd 仅仅就是 key-val。</li>
<li>etcd 的底层是 Raft 算法，可以保证数据的强一致性。而 redis 数据复制上是主备异步复制，只能最终一致性。</li>
<li>读写性能上，因为 etcd 保证强一致性，所以会比 redis 差。</li>
<li>存储方面，etcd 使用的是持久化存储boltdb，而 redis 的方案是可持久化的 aof/rdb
-&hellip;&hellip;</li>
</ul>
<h3 id="环境与说明">环境与说明</h3>
<p>直接下载编译好的二进制文件也好，还是自己下载源码编译运行，先开启一个单节点服务就行。我本地使用 goreman 搭建了三个实例。
<img src="https://image.syst.top/image/etcd/peer.png" alt="image">
这里稍微说明一下:<code>PEER ADDRS</code> 指的是向其他 <code>etcd server</code> 暴露的通信地址,比如上图 <code>name=infra1</code> 要调用 <code>infra2</code>，
调用的就是 <code>http://127.0.0.1:22380</code>。 而 <code>CLIENT ADDRS</code> 是对客户端暴露的地址。比如接下来我们的客户端连接的是 <code>infra1</code>，使用的就是 <code>http://127.0.0.1:2379</code>。</p>
<p>目前网上的教程大多使用编译好的 etcdctl 这样的二进制文件，通过命令行来进行操作,简单直观。比如:
<img src="https://image.syst.top/image/etcd/etcd-ctl.png" alt="image"></p>
<p>但是也会导致一个问题，你并不知道客户端底层是如何运行的，这中间又涉及了哪些接口，对应的数据结构是什么样的。 所以为了一步步深入 etcd，我们从代码层面操作 etcd 客户端。</p>
<p>以下是本篇文章涉及到的全部代码,下面我们开始分块讲解.</p>
<h3 id="初始化-etcd-客户端">初始化 etcd 客户端</h3>
<p>我们先初始化一个 etcd 客户端</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">cli</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化etcd 客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析etcd的地址，编程[]string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个 etcd 的客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cli</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="put-操作">put 操作</h3>
<p>命令行 <code>etcdctl put key val</code> 对应操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 设置key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>
</span></span><span class="line"><span class="cl">	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>除了简单的设置，我们还有一种租约模式，也就是设置一个key的有效期，在有效期之内可以进行续租，如果没续租到期就过期。 对应的命令行是分两段:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">etcdctl</span> <span class="nx">lease</span> <span class="nx">grant</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl"><span class="c1">// lease 326978bac638650a granted with TTL(200s)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">etcdctl</span> <span class="nx">put</span> <span class="nx">hello</span> <span class="nx">world</span> <span class="o">--</span><span class="nx">lease</span><span class="p">=</span><span class="mi">326978</span><span class="nx">bac638650a</span>
</span></span></code></pre></div><p>对应操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 设置会过期的key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKeyLease</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ttl</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个租约对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">lease</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">Lease</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lease</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">NewLease</span><span class="p">(</span><span class="nx">cli</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">leaseResp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseGrantResponse</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 根据时间，生成一个租约
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">leaseResp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">lease</span><span class="p">.</span><span class="nf">Grant</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">ttl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 租约 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseResp</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>etcd 的租约模式，简单的说， 当 Lease server 收到 client 请求，比如上面创建一个有效期200秒的请求，会通过 Raft
模块完成日志同步， 随后 Apply 模块的 Grant 接口执行日志条目内容。这是后续我们要研究的，这里略微提一下。</p>
<p>首先你得创建一个 Lease(租约)，获取到一个 Lease 唯一id，然后 put 的时候带上这个 id。当一个 key 指定一个 Lease 的时候，
底层最终是会把这个 key 关联到 Lease 的内存集合中。所以本质上，一个 Lease 可以 关联 n 个 key。而我们平常使用的缓存 key 设置过期时间，一般是把 key 和过期时间一对一绑定。</p>
<p>可能有人还要问，Lease 到期了是如何删除掉关联的 key？</p>
<p>其实原理说起来也很简单。Lease 在底层存储的结构是堆。由一个异步的 G 专门负责的去淘汰过期的 Lease。定时从最小堆中取出已经到期的 Lease。 然后删除 Lease 以及 删除通过 LeaseId 关联上此 Lease 的
key 列表。后面我们分析源码的时候专门讨论这块。</p>
<p>这里我还要说一点，你可以看到，不管是 put 一个普通的 key，还是一个带有租约的 key，调用的都是同一个方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 普通的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 租约
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseResp</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="c1">// 源码里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">OpOption</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseID</span> <span class="nx">LeaseID</span><span class="p">)</span> <span class="nx">OpOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">op</span> <span class="o">*</span><span class="nx">Op</span><span class="p">)</span> <span class="p">{</span> <span class="nx">op</span><span class="p">.</span><span class="nx">leaseID</span> <span class="p">=</span> <span class="nx">leaseID</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">op</span> <span class="o">*</span><span class="nx">Op</span><span class="p">)</span> <span class="nf">applyOpts</span><span class="p">(</span><span class="nx">opts</span> <span class="p">[]</span><span class="nx">OpOption</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">opt</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>看出来了吗？一个很常见的设计模式，装饰器。</p>
<h3 id="get-操作">Get 操作</h3>
<p>命令行 <code>etcdctl get key</code> 对应操作,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">GetKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;获取 key 失败 :%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key %v 的值是：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们都知道，etcd从 v3 开始，底层实现了 MVCC 机制。所以在 etcd 中的 key 是存在多个历史版本的。
我们会在命令行中 <code>etcdctl get hello --rev=?</code>,比如
<img src="https://image.syst.top/image/etcd/rev-1.png" alt="image">
可以看到，不同版本的 key(&ldquo;hello&rdquo;)的值是不一样的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 获取指定版本的key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">version</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithRev</span><span class="p">(</span><span class="nx">version</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;删除 key:%v 失败:%v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;请求key:%v,请求版本:%v,获取结果：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</span></span></code></pre></div><p>一样的套路。我们也可以运行这段代码演示一下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">src</span><span class="p">.</span><span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">src</span><span class="p">.</span><span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
</span></span></code></pre></div><p><img src="https://image.syst.top/image/etcd/rev-2.png" alt="image">
其他参数暂时忽略，主要看 Kvs 里面的结果。</p>
<h3 id="watch-操作">Watch 操作</h3>
<p>命令行 <code>./etcdctl watch hello</code></p>
<p>为了避免客户端的反复轮询， etcd 提供了 event 机制。客户端可以订阅一系列的 event ，用于 watch 某些 key 。
当这些被 watch 的 key 更新时， etcd 就会通知客户端。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 监听key 变动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WatchKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">watch</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">WatchChan</span>
</span></span><span class="line"><span class="cl">	<span class="nx">watch</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Watch</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">res</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">watch</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key:%v变动通知：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;值:%+v\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">res</span><span class="p">.</span><span class="nx">Events</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以从上面这段代码看出，watch 是通过 channel 的方式来进行通知的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 开启一个 G
</span></span></span><span class="line"><span class="cl"><span class="c1">//	go src.WatchKey(&#34;hello&#34;)
</span></span></span></code></pre></div><p>然后我们运行这段程序，在命令行上操作 hello 这个 key，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">.</span><span class="o">/</span><span class="nx">etcdctl</span> <span class="nx">lease</span> <span class="nx">grant</span> <span class="mi">30</span>
</span></span><span class="line"><span class="cl"><span class="nx">lease</span> <span class="mi">326978</span><span class="nx">bac638651e</span> <span class="nx">granted</span> <span class="nx">with</span> <span class="nf">TTL</span><span class="p">(</span><span class="mi">30</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="o">/</span><span class="nx">etcdctl</span> <span class="nx">put</span> <span class="nx">hello</span> <span class="nx">world</span><span class="o">-</span><span class="nx">age</span> <span class="o">--</span><span class="nx">lease</span><span class="p">=</span><span class="mi">326978</span><span class="nx">bac638651e</span>
</span></span></code></pre></div><p><img src="https://image.syst.top/image/etcd/watch.png" alt="image">
可以看到接收到两个事件，一个是 put，一个是租约到期 delete。</p>
<h3 id="总结">总结</h3>
<p>以下是这篇文章全部代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">src</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;flag&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">cli</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化etcd 客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析etcd的地址，编程[]string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个 etcd 的客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cli</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 设置key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>
</span></span><span class="line"><span class="cl">	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 设置会过期的key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKeyLease</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ttl</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个租约对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">lease</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">Lease</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lease</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">NewLease</span><span class="p">(</span><span class="nx">cli</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">leaseResp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseGrantResponse</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 根据时间，生成一个租约
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">leaseResp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">lease</span><span class="p">.</span><span class="nf">Grant</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">ttl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 租约 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseResp</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 获取key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">GetKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;获取 key 失败 :%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key %v 的值是：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 获取指定版本的key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">version</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithRev</span><span class="p">(</span><span class="nx">version</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;删除 key:%v 失败:%v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;请求key:%v,请求版本:%v,获取结果：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 删除key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">DeleteKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">DeleteResponse</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;删除 key:%v 失败:%v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%+v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 监听key 变动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WatchKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">watch</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">WatchChan</span>
</span></span><span class="line"><span class="cl">	<span class="nx">watch</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Watch</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithRev</span><span class="p">(</span><span class="mi">21</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">res</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">watch</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key:%v变动通知：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;值:%+v\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">res</span><span class="p">.</span><span class="nx">Events</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这篇文章主要介绍了etcd这个分布式存储工具，包括它的应用场景以及实战基本的操作。
上面其实还有很多的实例没有写出来，一个是因为懒，没必要一个个演示一遍，另一个原因是留给你们自行实现。
我们以这个为开始，一步步敲开 etcd 的大门。</p>
]]></content>
		</item>
		
		<item>
			<title>etcd 实战基础篇(二) </title>
			<link>https://www.syst.top/posts/go/etcd-2021-04-15/</link>
			<pubDate>Sat, 10 Apr 2021 09:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/etcd-2021-04-15/</guid>
			<description>上一篇我们主要介绍了 etcd 使用场景以及最基础性的一些操作(put、get、watch)。 这一篇我们接着实战etcd其他业务场景。
基于 etcd 的分布式锁 基于 etcd 实现一个分布式锁特别简单。etcd 提供了开箱即用的包 concurrency，几行代码就实现一个分布式锁。
package src import ( &amp;#34;context&amp;#34; &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/coreos/etcd/clientv3&amp;#34; &amp;#34;github.com/coreos/etcd/clientv3/concurrency&amp;#34; &amp;#34;log&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;time&amp;#34; ) var addr = flag.String(&amp;#34;addr&amp;#34;, &amp;#34;http://127.0.0.1:2379&amp;#34;, &amp;#34;etcd address&amp;#34;) // 初始化etcd客户端 func initEtcdClient() *clientv3.Client { var client *clientv3.Client var err error // 解析etcd的地址，编程[]string 	endpoints := strings.Split(*addr, &amp;#34;,&amp;#34;) // 创建一个 etcd 的客户端 	client, err = clientv3.New(clientv3.Config{Endpoints: endpoints, DialTimeout: 5 * time.Second}) if err != nil { fmt.</description>
			<content type="html"><![CDATA[<p>上一篇我们主要介绍了 etcd 使用场景以及最基础性的一些操作(put、get、watch)。 这一篇我们接着实战etcd其他业务场景。</p>
<h3 id="基于-etcd-的分布式锁">基于 etcd 的分布式锁</h3>
<p>基于 etcd 实现一个分布式锁特别简单。etcd 提供了开箱即用的包 <code>concurrency</code>，几行代码就实现一个分布式锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">src</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;flag&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/coreos/etcd/clientv3/concurrency&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化etcd客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">initEtcdClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析etcd的地址，编程[]string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个 etcd 的客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">client</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Lock</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">lockName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个 session,如果程序宕机奔溃，etcd可以知道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewSession</span><span class="p">(</span><span class="nx">client</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个etcd  locker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">locker</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewLocker</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;id：%v 尝试获取锁%v&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">locker</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;id:%v取得锁%v&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 模拟业务耗时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">300</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">locker</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;id:%v释放锁%v&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们再写个脚本运行，看看结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;etcd-test/src&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">lockName</span> <span class="p">=</span> <span class="s">&#34;locker-test&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">src</span><span class="p">.</span><span class="nf">Lock</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们发起了10个并发抢同一个 key 锁的命令。运行结果如下，
<img src="https://image.syst.top/image/etcd/lock.png" alt="image"></p>
<p>从图片可以看到，同一时刻一定只有一个 G 得到锁，一个 G 获取到一个锁的前提一定是当前 key 未被锁。</p>
<p>有人要问了，当一个锁解开时，之前未获取到锁而发生等待的客户端谁先获取到这把锁？ 这个问题，我们后续分析原理的时候再揭晓。</p>
<p>说到分布式锁，不得不提起 redis。它有一个看似安全实际一点都不安全的分布式锁。它的命令模式是</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">set</span> <span class="nx">key</span> <span class="nx">value</span> <span class="p">[</span><span class="nx">EX</span> <span class="nx">seconds</span><span class="p">]</span> <span class="p">[</span><span class="nx">PX</span> <span class="nx">milliseconds</span><span class="p">]</span> <span class="p">[</span><span class="nx">NX</span><span class="p">|</span><span class="nx">XX</span><span class="p">]</span>
</span></span></code></pre></div><p>这其中，介绍两个关键的属性:</p>
<ul>
<li>EX 标示设置过期时间，单位是秒。</li>
<li>NX 表示 当对应的 key 不存在时，才创建。</li>
</ul>
<p>我们在使用 redis 做分布式锁的时候会这么写。(代码用了包 <code>https://github.com/go-redis/redis</code>)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">RedisLock</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rdb</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Addr</span><span class="p">:</span>     <span class="s">&#34;127.0.0.1:6379&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Password</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">DB</span><span class="p">:</span>       <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 尝试获取锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">rdb</span><span class="p">.</span><span class="nf">SetNX</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="s">&#34;value&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">res</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 尝试获取锁失败\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 获取到锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">//模拟业务耗时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 释放锁，时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rdb</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">rdb</span><span class="p">.</span><span class="nf">SetNX</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="s">&#34;value&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span></code></pre></div><p>我们规定锁的过期时间是2秒，下面有一句 <code>time.Sleep(1 * time.Second) </code> 用来模拟处理业务的耗时。业务处理结束，我们删除 key <code>rdb.Del(ctx, &quot;key&quot;)</code> 。</p>
<p>我们写个简单的脚本，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nf">RedisLock</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们开启十个 G 并发的调用 <code>RedisLock</code> 函数。每次调用，函数内部都会新建一个 redis 客户端，本质上是10个客户端。</p>
<p>运行这段程序，</p>
<p><img src="https://image.syst.top/image/redis/lock-1.png" alt="image"></p>
<p>从图中看出，同一时刻只有一个客户端获取到锁，并且在一秒的任务处理后，释放了锁，好像没太大的问题。</p>
<p>那么，我再写一个简单的例子。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/go-redis/redis/v8&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ctx</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">rdb</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Client</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ExampleLock</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">timeSleep</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rdb</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Addr</span><span class="p">:</span>     <span class="s">&#34;127.0.0.1:6379&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Password</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">DB</span><span class="p">:</span>       <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">timeSleep</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="nx">timeSleep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 尝试获取锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">rdb</span><span class="p">.</span><span class="nf">SetNX</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="s">&#34;value&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">res</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:尝试获取锁失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 获取到锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 释放锁，时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rdb</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们设置锁的过期时间是 3 秒，而获取锁之后的任务处理时间为 7 秒。</p>
<p>然后我们开启两个 G。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span></code></pre></div><p>其中第二行数字5，从代码中可以看出，是指启动 G 后过5秒去获取锁。</p>
<p>这段代码整体流程是这样的:G(1) 获取到锁后，设置的锁持有时间是3秒，由于任务执行需要7秒的时间，因此在3秒过后锁会自动释放。
G(2) 可以在第5秒的时候获取到锁，然后它执行任务也得7秒。最后，G(1)在获取锁后7秒执行释放锁的操作，G(2)同理。</p>
<p><img src="https://image.syst.top/image/redis/lock-2.png" alt="image"></p>
<p>发现问题了吗？</p>
<p>G(1) 的锁在3秒后已经自动释放了。但是在任务处理结束后又执行了解锁的操作,可此时这个锁是 G(2) 的呀。</p>
<p>那么接下来由于 G(1) 误解了 G(2) 的锁，如果此时有其他的 G，那么就可以获取到锁。</p>
<p>等 G(2) 任务执行结束，同理又会误解其他 G 的锁，这是一个恶性循环。
这也是掘金一篇由 redis 分布式锁造成茅台超卖重大事故的原因之一。</p>
<p>至于其他的，可以自行查看这篇文章[1]。</p>
<h3 id="基于-etcd-的分布式队列">基于 etcd 的分布式队列</h3>
<p>对队列更多的理论知识就不加以介绍了。我们都知道，队列是一种先进先出的数据结构，一般也只有入队和出队两种操作。
我们常常在单机的应用中使用到队列。</p>
<p>那么，如何实现一个分布式的队列呢?。</p>
<p>我们可以使用 etcd 开箱即用的工具，在 <code>etcd</code> 底层 <code>recipe</code> 包里结构 <code>Queue</code>，实现了一个多读多写的分布式队列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Queue</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Client</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span>    <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">keyPrefix</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewQueue</span><span class="p">(</span><span class="nx">client</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">keyPrefix</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Queue</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">Queue</span><span class="p">)</span> <span class="nf">Dequeue</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">Queue</span><span class="p">)</span> <span class="nf">Enqueue</span><span class="p">(</span><span class="nx">val</span> <span class="kt">string</span><span class="p">)</span>
</span></span></code></pre></div><p>我们基于此包可以很方便的实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">src</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">recipe</span> <span class="s">&#34;github.com/coreos/etcd/contrib/recipes&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化etcd客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">initEtcdClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析etcd的地址，编程[]string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个 etcd 的客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">client</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Push</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;push err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}(</span><span class="nx">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Pop</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;接收值:%v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在 <code>push</code> 中，我们开启3轮发送值入队，每次发送10个，发送一轮休息2秒。
在 <code>pop</code> 中，通过死循环获取队列中的值。</p>
<p>运行脚本程序如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;etcd-test/src&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">key</span> <span class="o">:=</span> <span class="s">&#34;test-queue&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们使用两个 <code>G</code> 代表 分别运行 <code>push</code> 和 <code>pop</code> 操作。
同时为了达到运行效果，我们先运行 <code>pop</code> 等待有入队的元素。
运行结果动画如下,</p>
<p><img src="https://image.syst.top/image/etcd/queue.gif" alt="image"></p>
<p><code>etcd</code> 还提供了优先级的分布式的队列。和上面的用法相似。只是在入队的时候，不仅仅需要提供一个值，还需要提供一个整数，来表示当前 <code>push</code> 值的优先级。数值越小，优先级越高。</p>
<p>我们改动一下上述的代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">src</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">recipe</span> <span class="s">&#34;github.com/coreos/etcd/contrib/recipes&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化etcd客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">initEtcdClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析etcd的地址，编程[]string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个 etcd 的客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">client</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">PriorityPush</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewPriorityQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">item</span><span class="p">),</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;push err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">PriorityPop</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewPriorityQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;接收值:%v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然后以下是我们的测试代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;etcd-test/src&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">key</span> <span class="o">:=</span> <span class="s">&#34;test-queue&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">src</span><span class="p">.</span><span class="nf">PriorityPush</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">src</span><span class="p">.</span><span class="nf">PriorityPop</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们把0到9的数并发的 <code>push</code> 到队列中，对应的优先级整数值就是它本身，<code>push</code> 完毕，我们运行 <code>PriorityPop</code> 函数，看最终结果显示就是从0到9。</p>
<p><img src="https://image.syst.top/image/etcd/queue-2.gif" alt="image"></p>
<h3 id="总结">总结</h3>
<p>这篇文章主要介绍了如何使用 etcd 实现分布式锁以及分布式队列。其他etcd的场景，可以自行实践。</p>
<h3 id="附录">附录</h3>
<p>[1]
<a href="https://juejin.cn/post/6854573212831842311">https://juejin.cn/post/6854573212831842311</a></p>
]]></content>
		</item>
		
		<item>
			<title>使用 Go 每分钟处理百万请求 </title>
			<link>https://www.syst.top/posts/go/handle-million-requests/</link>
			<pubDate>Mon, 05 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/handle-million-requests/</guid>
			<description>介绍 偶然间看到一篇写于15年的文章，说实话，标题确实吸引了我，不过看了几遍之后，确实精彩。 关于这篇文章，我就不直接翻译了。 项目的需求就是 客户端发送请求，服务端接收请求处理数据(原文是把资源上传至 Amazon S3 资源中)。本质上就是这样, 我稍微改动了原文的业务代码，但是并不影响核心模块。在第一版中，每收到一个 Request,开启一个 G 进行处理，快速响应，很常规的操作。
代码如下
初版 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) type Payload struct { // 传啥不重要 } func (p *Payload) UpdateToS3() error { //存储逻辑,模拟操作耗时 	time.Sleep(500 * time.Millisecond) fmt.Println(&amp;#34;上传成功&amp;#34;) return nil } func payloadHandler(w http.ResponseWriter, r *http.Request) { // 业务过滤 	// 请求body解析...... 	var p Payload go p.UpdateToS3() w.Write([]byte(&amp;#34;操作成功&amp;#34;)) } func main() { http.HandleFunc(&amp;#34;/payload&amp;#34;, payloadHandler) log.Fatal(http.ListenAndServe(&amp;#34;:8099&amp;#34;, nil)) } 这样操作存在什么问题呢？一般情况下，没什么问题。但是如果是高并发的场景下，不对G数进行控制，你的 CPU 使用率暴涨，内存占用暴涨，直至程序奔溃。</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>偶然间看到一篇写于15年的文章，说实话，标题确实吸引了我，不过看了几遍之后，确实精彩。 关于这篇文章，我就不直接翻译了。 项目的需求就是 客户端发送请求，服务端接收请求处理数据(原文是把资源上传至 Amazon S3 资源中)。本质上就是这样,
<img src="https://image.syst.top/image/handle-million.png" alt="image"></p>
<p>我稍微改动了原文的业务代码，但是并不影响核心模块。在第一版中，每收到一个 Request,开启一个 G 进行处理，快速响应，很常规的操作。</p>
<p>代码如下</p>
<h3 id="初版">初版</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Payload</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 传啥不重要
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Payload</span><span class="p">)</span> <span class="nf">UpdateToS3</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//存储逻辑,模拟操作耗时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;上传成功&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 业务过滤
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 请求body解析......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Payload</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">p</span><span class="p">.</span><span class="nf">UpdateToS3</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/payload&#34;</span><span class="p">,</span> <span class="nx">payloadHandler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8099&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样操作存在什么问题呢？一般情况下，没什么问题。但是如果是高并发的场景下，不对G数进行控制，你的 CPU 使用率暴涨，内存占用暴涨，直至程序奔溃。</p>
<p>如果此操作落地至数据库，例如mysql,那么相应的，你数据库的服务器磁盘IO、网络带宽
、CPU负载、内存消耗都会达到非常高的情况，一并奔溃。所以，一旦程序中出现不可控的事物，往往是危险的信号。</p>
<h3 id="中版">中版</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">MaxQueue</span> <span class="p">=</span> <span class="mi">400</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">Queue</span> <span class="kd">chan</span> <span class="nx">Payload</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Queue</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Payload</span><span class="p">,</span> <span class="nx">MaxQueue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Payload</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 传啥不重要
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Payload</span><span class="p">)</span> <span class="nf">UpdateToS3</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//存储逻辑,模拟操作耗时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;上传成功&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 业务过滤
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 请求body解析......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Payload</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//go p.UpdateToS3()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Queue</span> <span class="o">&lt;-</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 处理任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">StartProcessor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">payload</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">Queue</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">payload</span><span class="p">.</span><span class="nf">UpdateToS3</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/payload&#34;</span><span class="p">,</span> <span class="nx">payloadHandler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//单独开一个g接收与处理任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nf">StartProcessor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8099&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这一版借助带 buffered 的 channel 来完成这个功能，这样控制住了无限制的G，但是依然没有解决问题。</p>
<p>处理请求是一个同步的操作，每次只会处理一个任务，然而高并发下请求进来的速度远远超过了处理的速度。这种情况，一旦 channel
满了之后， 后续的请求将会被阻塞等地啊。然后你会发现，响应的时间会大幅度的开始增加， 甚至不再有任何的响应。</p>
<h3 id="终版">终版</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MaxWorker</span> <span class="p">=</span> <span class="mi">100</span> <span class="c1">//随便设置值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MaxQueue</span>  <span class="p">=</span> <span class="mi">200</span> <span class="c1">// 随便设置值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 一个可以发送工作请求的缓冲 channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">JobQueue</span> <span class="kd">chan</span> <span class="nx">Job</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">JobQueue</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">MaxQueue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Payload</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Job</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">PayLoad</span> <span class="nx">Payload</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Worker</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">WorkerPool</span> <span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span>
</span></span><span class="line"><span class="cl">	<span class="nx">JobChannel</span> <span class="kd">chan</span> <span class="nx">Job</span>
</span></span><span class="line"><span class="cl">	<span class="nx">quit</span>       <span class="kd">chan</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewWorker</span><span class="p">(</span><span class="nx">workerPool</span> <span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span><span class="p">)</span> <span class="nx">Worker</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">Worker</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">WorkerPool</span><span class="p">:</span> <span class="nx">workerPool</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">JobChannel</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">quit</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Start 方法开启一个 worker 循环，监听退出 channel，可按需停止这个循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="nx">Worker</span><span class="p">)</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 将当前的 worker 注册到 worker 队列中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">w</span><span class="p">.</span><span class="nx">WorkerPool</span> <span class="o">&lt;-</span> <span class="nx">w</span><span class="p">.</span><span class="nx">JobChannel</span>
</span></span><span class="line"><span class="cl">			<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="nx">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">w</span><span class="p">.</span><span class="nx">JobChannel</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 	真正业务的地方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">//	模拟操作耗时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;上传成功:%v\n&#34;</span><span class="p">,</span> <span class="nx">job</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">w</span><span class="p">.</span><span class="nx">quit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="nx">Worker</span><span class="p">)</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nx">quit</span> <span class="o">&lt;-</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Dispatcher</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 注册到 dispatcher 的 worker channel 池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">WorkerPool</span> <span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewDispatcher</span><span class="p">(</span><span class="nx">maxWorkers</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Dispatcher</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pool</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">maxWorkers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Dispatcher</span><span class="p">{</span><span class="nx">WorkerPool</span><span class="p">:</span> <span class="nx">pool</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 开始运行 n 个 worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">MaxWorker</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">worker</span> <span class="o">:=</span> <span class="nf">NewWorker</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">worker</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">d</span><span class="p">.</span><span class="nf">dispatch</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">dispatch</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">JobQueue</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">job</span> <span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 尝试获取一个可用的 worker job channel，阻塞直到有可用的 worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 分发任务到 worker job channel 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">&lt;-</span> <span class="nx">job</span>
</span></span><span class="line"><span class="cl">			<span class="p">}(</span><span class="nx">job</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 接收请求，把任务筛入JobQueue。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">work</span> <span class="o">:=</span> <span class="nx">Job</span><span class="p">{</span><span class="nx">PayLoad</span><span class="p">:</span> <span class="nx">Payload</span><span class="p">{}}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">JobQueue</span> <span class="o">&lt;-</span> <span class="nx">work</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 通过调度器创建worker，监听来自 JobQueue的任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">NewDispatcher</span><span class="p">(</span><span class="nx">MaxWorker</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/payload&#34;</span><span class="p">,</span> <span class="nx">payloadHandler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8099&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最终采用的是两级 channel，一级是将用户请求数据放入到 chan Job 中，这个 channel job 相当于待处理的任务队列。</p>
<p>另一级用来存放可以处理任务的 work 缓存队列，类型为 chan chan Job。调度器把待处理的任务放入一个空闲的缓存队列当中，work 会一直处理它的缓存队列。通过这种方式，实现了一个 worker 池。大致画了一个图帮助理解
<img src="https://image.syst.top/image/work-pool.png" alt="image"></p>
<p>首先我们在接收到一个请求后，创建 Job 任务，把它放入到任务队列中等待 work 池处理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">work</span> <span class="o">:=</span> <span class="nx">Job</span><span class="p">{</span><span class="nx">PayLoad</span><span class="p">:</span> <span class="nx">Payload</span><span class="p">{}}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">JobQueue</span> <span class="o">&lt;-</span> <span class="nx">work</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>调度器初始化work池后，在 dispatch 中，一旦我们接收到 JobQueue 的任务，就去尝试获取一个可用的 worker，分发任务给 worker 的 job channel 中。 注意这个过程不是同步的，而是每接收到一个 job，就开启一个 G 去处理。这样可以保证 JobQueue 不需要进行阻塞，对应的往 JobQueue 理论上也不需要阻塞地写入任务。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 开始运行 n 个 worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">MaxWorker</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">worker</span> <span class="o">:=</span> <span class="nf">NewWorker</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">worker</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">d</span><span class="p">.</span><span class="nf">dispatch</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">dispatch</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">JobQueue</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">job</span> <span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 尝试获取一个可用的 worker job channel，阻塞直到有可用的 worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 分发任务到 worker job channel 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">&lt;-</span> <span class="nx">job</span>
</span></span><span class="line"><span class="cl">			<span class="p">}(</span><span class="nx">job</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里&quot;不可控&quot;的 G 和上面还是又所不同的。仅仅极短时间内处于阻塞读 Chan 状态， 当有空闲的 worker 被唤醒，然后分发任务，整个生命周期远远短于上面的操作。</p>
<p>最后，强烈建议看一下原文，原文地址在：http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/</p>
<h3 id="最终方案">最终方案</h3>
]]></content>
		</item>
		
	</channel>
</rss>
