<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>是不是很酷</title>
    <link>https://www.syst.top/</link>
    <description>Recent content on 是不是很酷</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 19 Aug 2023 19:34:52 +0800</lastBuildDate><atom:link href="https://www.syst.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>杭州随机公交之旅</title>
      <link>https://www.syst.top/lives/hangzhou/</link>
      <pubDate>Sat, 19 Aug 2023 19:34:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/hangzhou/</guid>
      <description>图片拍摄于2023-04-27 京都
上周刷X的时候看到一个老哥blog，注意到一篇文章[1]，当时觉得很有趣，随即把这篇文章加入pocket。
周末想起这篇文章，是时候把今天的命运交给杭州公交了，开启命运公交之旅。（ps.主要还是太闲了
挑战规则很简单，从任意的公交站出发，乘坐第一辆进站的公交车，行驶五站后下车，然后继续刚才的逻辑。经过几轮的随机公交大法，看看最终到了哪里。
当然，还是需要跟程序一样，对特定情况来点特殊的处理。
  遇到不足五站的，直接在终点站下车
  遇到全部车辆的终点站，可以附近换站
  如果来的第一辆是前一次乘坐的车次，不上车
  其他不做干预。如果发现线路要回环了，不做干预。一直死循环的概率也极低，堪比中彩票。
除此之外，我给自己限制了八轮车次。也就是说如果一切顺利，结束的时候应该坐了40站的公交车🥹。
但是因为可能会碰到不足五站的情况，所以真实情况你懂的😉。
出发前，我的疑问是最大能跨过几个区？看了地图以及我的八轮限制，结论是跨过两个区最多了：余杭》拱墅》西湖。
我还想着会不会终点在西湖附近，这样结束之后就近去西湖逛逛好了。前几轮过去我也是这么想的，直到后面拐点公交出现，和西湖就彻底无缘了。
接下来就是朴实无华的流水账了。
一开始打算从家门口的公交站开始的，不过那条路线比较单一，是条专线，加上肚子也饿了，所以先到附近商场吃了个饭，然后在商城对面坐上了第一辆车。
第一轮是k389线路的公交车，因为住在近郊，出发行驶的方向当然是进城的方向🤣。
k389一路并没有转变方向，符合进城的预期。坐了五站来到了铭雅苑，金家渡附近。
刚拍完照片，k281就来了，直接上车。
第二轮 k281开始转方向了，五个站转了几个弯，我已经分不清方向了。最终到达花园桥。
因为自己定的规则限制，不能乘坐上次的车次，所以没得选了，只能是503了。这辆车等的太久太久了。
第三轮503五站到郭家厍下车后，这时候已经从余杭区跨到拱墅区了。
然后，戏剧性的一幕发生了，
好家伙，这个公交站只有k503专线，完全不给随机性机会啊。
这时候我有两种选择，一种是随机选择一个方向，走到附近的公交站，然后等待第一辆车进站，上车。
另一种原地等k503，在思考了片刻之后，我选择因为特殊性，而破坏上面的规则，这本身也是一种随机命运。(圆回来了
然后开始新一轮漫长的等待～。
有趣的是，中途一个边上的大妈问我等什么车，我回答k503后，大妈说我看你就是从k503下来的，一时语塞&amp;hellip;&amp;hellip;
第四轮继续k503之旅，这一波到了拱宸桥站，已经靠近拱墅的核心区了，再往上靠靠感觉靠西湖有戏。
应该是在高架下面，路很窄，也是刚拍完照，马上就来公交了。
第五轮k1203坐了半天发现一站都没到达，站起来查看了一下，发现这辆公交两站就到终点站大关北站了。然后几个转弯，已经察觉到偏离了🥹。
第六轮k183在大关北上车后，发现这轮有点凑巧，五站刚好到终点站，拱北小区。上车的时候已经开始小雨了，终点站下了车，看到另一辆车来了，上车后司机拦住了我，说是终点站，不能乘车😅。此时雨已经变成了暴雨，只能先行躲雨了。
躲雨的时候发现开麻将馆的人都是人才，好一个仙雀会～
等雨停了，第七轮上了k61，最后到达了平安桥。
第八轮上的k57，最后本次挑战的终点位于拱墅区的马家门站。
还好给自己做了轮次的限制，要是这个方向一直下去，好家伙，我觉得我能到德清。
八轮总耗时2小时13分钟，其中包括躲雨以及等车的间隙。总乘站数37站，总距离划算约等于26公里。
感觉第五轮是个拐点，因为第五轮上的车拐个弯往西湖反方向开了，后续第六轮没有挽救回来，开始往拱墅区边缘驶去，就再也没有机会了。
所以最后，八轮只跨了一个区:拱墅区。
杭州的公交车挺好的，所以回去的时候我坐了地铁。先在终点马家门站滴滴到附近的地铁，然后乘坐地铁五个站就又回到出发点了。所以这两个多钟头我在干嘛？
如果我选择坐公交回来，相同的条件下，我增加几个变数，
  允许选择出发的位置
  允许中途有两次决定车次的机会
  不知道这种情况下，坐公交车能不到家附近😂
最后，附上整体路程，可以查看具体的方向，主打的就是随缘。
[1]https://nano.ac/posts/b56e5c40/
 本文使用 文章同步助手 同步
 </description>
    </item>
    
    <item>
      <title>socks5结合抓包详解</title>
      <link>https://www.syst.top/posts/go/socks5/</link>
      <pubDate>Thu, 29 Jun 2023 15:20:00 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/socks5/</guid>
      <description>SOCKS5（Socket Secure 5）是一种网络协议，用于在客户端和代理服务器之间进行通信。它是SOCKS协议的第五个版本，SOCKS5协议支持TCP和UDP协议，并提供了认证和加密的功能。
SOCKS5协议广泛用于代理服务器、xx上网、匿名访问、负载均衡等场景。它提供了一种通用的、灵活的代理解决方案，可以在各种网络环境和应用中使用。
RFC 1928是关于SOCKS5的协议文档。
协议解析
SOCKS5工作在应用层和传输层之间，首先客户端需要和代理服务器进行tcp连接。
连接完成后，客户端和代理服务器之间进行协商确定认证方式。
具体就是客户端发送认证方法请求，
 VER字段占1个字节，表示SOCKS协议的版本号，目前为5（即SOCKS5）。 NMETHODS字段占1个字节，表示客户端支持的认证方法数量。 METHODS字段占N个字节，表示客户端支持的认证方法列表。每个字节代表一种认证方法，取值范围为1到255，对应不同的认证方式。  代理服务器在收到客户端消息，从客户端提供的METHODS字段中选择一种支持的认证方法，并将该方法的标识填充到METHOD字段中。代理服务器通过这个应答消息告知客户端选择的认证方法。
目前的METHOD包含以下几个值：
 X&#39;00&amp;rsquo;：NO AUTHENTICATION REQUIRED。表示客户端无需进行任何认证，可以直接进行连接或操作。 X&#39;01&amp;rsquo;：GSSAPI。表示使用GSSAPI（Generic Security Services Application Program Interface）进行认证。 X&#39;02&amp;rsquo;：USERNAME/PASSWORD。表示客户端需要使用用户名和密码进行认证。 X&#39;03&amp;rsquo;到X&#39;7F&amp;rsquo;：由IANA（Internet Assigned Numbers Authority）分配的认证方法。这些方法可能具有特定的定义和用途，可以根据具体的分配情况来确定其含义。 X&#39;80&amp;rsquo;到X&amp;rsquo;FE&amp;rsquo;：保留给私有方法（RESERVED FOR PRIVATE METHODS）。这些方法可能由特定实现或组织自定义，不在通用的认证方法范围内。 X&amp;rsquo;FF&amp;rsquo;：无可接受的方法（NO ACCEPTABLE METHODS）。表示代理服务器无法接受客户端提供的任何认证方法，无法进行连接或操作。  如果返回的方法是X &amp;lsquo;FF&amp;rsquo;，意味着失败了，那么客户端需要关闭连接。
一旦协商完毕，客户端会发送请求的详细信息，主要包括实际要请求的目的地址和端口号。
其中各字段含义如下：
 VER：协议版本，固定为X&#39;05&amp;rsquo;。 CMD：连接命令，指定客户端的操作类型。常见的取值有：  X&#39;01&amp;rsquo;：CONNECT。 X&#39;02&amp;rsquo;：BIND。 X&#39;03&amp;rsquo;：UDP。   RSV：保留字段，固定为X&#39;00&amp;rsquo;。 ATYP：目标地址类型，指定DST.ADDR字段的类型。常见的取值有：  X&#39;01&amp;rsquo;：IPv4地址。 X&#39;03&amp;rsquo;：域名。 X&#39;04&amp;rsquo;：IPv6地址。   DST.ADDR：目标地址，根据ATYP字段的类型来确定具体的格式。 DST.PORT：目标端口，表示客户端要连接的目标服务器的端口号。  代理服务器收到请求后，会发起到DST.ADDR:PORT的连接，并响应客户端结果，
其中的值有：
REP:
 X&#39;00&amp;rsquo; 成功 X&#39;01&amp;rsquo; SOCKS服务器故障 X&#39;02&amp;rsquo; 连接不符合规则 X&#39;03&amp;rsquo; 网络不可达 X&#39;04&amp;rsquo; 主机不可达 X&#39;05&amp;rsquo; 连接被拒绝 X&#39;06&amp;rsquo; TTL 过期 X&#39;07&amp;rsquo; 命令不支持 X&#39;08&amp;rsquo; 地址类型不支持 X&#39;09&amp;rsquo; to X&amp;rsquo;FF&amp;rsquo; 未分配  RSV：预留位，必须设置成X&#39;00&amp;rsquo;。</description>
    </item>
    
    <item>
      <title>easyio:最小化的netpoll实现</title>
      <link>https://www.syst.top/posts/go/easyio/</link>
      <pubDate>Sat, 03 Jun 2023 17:06:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/easyio/</guid>
      <description>目前Go圈有很多款异步的网络框架:
 https://github.com/tidwall/evio https://github.com/lesismal/nbio https://github.com/panjf2000/gnet https://github.com/cloudwego/netpoll &amp;hellip;&amp;hellip;.  排名不分先后。
这里面最早的实现是evio。evio也存在一些问题，之前也写过evio文章介绍过。 其他比如nbio和gnet也写过一些源码分析。
为什么会出现这些框架？之前也提到过，由于标准库netpoll的一些特性:
 一个conn一个goroutine导致利用率低 用户无法感知conn状态 &amp;hellip;..  这些框架在应用层上做了很多优化，比如:Worker Pool,Buffer,Ring Buffer,NoCopy&amp;hellip;&amp;hellip;。
都分析了好几篇的代码了，那么咋么说也得自己动手搞一个来达成学习目的。
没错，这就是easyio的由来。
它是一个最小化的IO框架，只实现最核心的部分，加起来不超过500行代码。
也没有用户端上层应用的优化，且目前只实现了linux的epoll，以及只能运行tcp协议。
大概结构如下，具体可以看代码～～，
简单的demo，
服务端:
package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;syscall&amp;#34; &amp;#34;github.com/wuqinqiang/easyio&amp;#34; ) var _ easyio.EventHandler = (*Handler)(nil) type Handler struct{} type EasyioKey struct{} type Message struct{ Msg string } var CtxKey EasyioKey func (h Handler) OnOpen(c easyio.Conn) context.Context { return context.WithValue(context.Background(), CtxKey, Message{Msg: &amp;#34;helloword&amp;#34;}) } func (h Handler) OnRead(ctx context.</description>
    </item>
    
    <item>
      <title>日本游记</title>
      <link>https://www.syst.top/lives/japan/</link>
      <pubDate>Tue, 02 May 2023 10:23:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/japan/</guid>
      <description>很久之前就想去日本了。所以在放开之后，果断办理了签证，调休了五一前一周的年假，怀着愉悦的心情开启了个人旅。
其实我应该再早一点，要是四月初过去，还能赶上樱花季。
我并没有做完整的规划，觉得到时候看地图随心走就行。因为我超级想去镰仓，所以前三天的行程是确定的。
第一天落地大阪，第二天一早就乘着Jr pass去镰仓了。镰仓很美，高校前一群女子学校的学生穿着统一的日式校服在车站前等车的那一幕也很美。
去的前两天大多阴天加大风，在要离开的第三天，放晴了，然后看到了对面的富士山。
镰仓的两个晚上，我是提前在Airbnb定的民宿：传统的两层楼，房子前面有个小院子，一楼拿来出租，楼上房东一家自住。
我定的那个房间一晚大概34刀。
在日本进别人家第一件事就是拖鞋。房东很nice，进门就开始和我介绍，虽然英语中夹杂着日语，但是通过动作比划，沟通还是可以的。
离开的时候还在Airbnb上给了我一个好评价，当然我也给了他一个好评。
镰仓看过后，就开始往回走了。
先在京都停留了一天。早上到京都后，由于日本住宿登记时间都是下午3点之后，所以先把行李暂时放在车站行李柜。
这里吐槽下，日本行李柜是没有扫二维码存储的，需要塞硬币。我记得小箱子大概700日币一次，记住，是存一次。
因为在没有投币之前，钥匙是挂在柜子上拔不下来的，当你塞完硬币后，你就可以关门拔钥匙了。如果你再拿着钥匙开门，重新想锁柜门的话，请再投一次硬币，别问我是咋么知道的😂。
京都主要去了二年坂，三年坂以及边上的清水寺。
满眼都是和服，而且那天人实在是太多了。
从京都离开的第二天去了奈良，当然去的奈良公园。
剩下的三天都住在大阪了。去了心斋桥，通天阁，日本第一高楼阿倍野HARUKAS，俯瞰了大阪这座城市。
回来的前一天，突然想起，来日本竟然没泡温泉，于是从大阪出发，坐了两个多小时的Jr pass，去了日本比较古老的温泉:白滨的崎之湯。
图片是网络上公开的崎之湯照片，泡温泉是不允许拍照的。我泡的时候，还没有其他人，靠近海边的位置，海浪能冲你脸上，爱了。
总之，这是一次不错的个人日本游，也留下一些印象。
首先日本地铁非常复杂，有各种字母开头的线路。到达的第一天，实在是搞晕了，主要是不太确定自己的方向，所以转乘的时候都得问一下乘务员。也正是因为它的复杂，造就了出行超级方便，靠着Google Maps 完全没有压力。
日本人的敬语非常多，不管是见面还是离别会说非常多的敬语，而且感觉都需要弯腰，于是，我也学会了弯腰。
日本街道普遍干净，虽然少不了有一些垃圾，但是大部分街面都比较干净。路边大部分是没有垃圾桶的，你吃东西的垃圾还得自己拿在手上。
日本虽然电子支付也比较普及，但是也有很多需要用现金的地方，然后你就会发现，回来的时候多了好多硬币。
我在回来前一晚还用了32个10元硬币买了两瓶饮料，这种情况下，还剩这么多。
另外，到达的那一天，我换了一张日本的卡，拆卡，开机，我习惯性想打开科学上网，那一刻，很想抽自己一巴掌。</description>
    </item>
    
    <item>
      <title>nbio原理解析</title>
      <link>https://www.syst.top/posts/go/nbio/</link>
      <pubDate>Thu, 23 Feb 2023 23:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/nbio/</guid>
      <description>之前更新的一系列，好久没更新了，差点烂尾，我不允许这样的事情在我身上发生(虽然已经烂尾好几次了😭)。
在上一篇文章中，我们探讨了基于 epoll 的 Go Netpoll 框架的早期实现——evio。我们还指出了它存在的一些问题。在本篇文章中，我们将继续深入分析另一个高性能的网络编程框架：nbio。
nbio项目里也包含了在nbio之上构建的nbhttp，这个不在我们讨论范围。
nbio同样采用了经典的Reactor模式，事实上，Go语言中的许多异步网络框架都是基于这种模式设计的。
老规矩，先运行nbio程序代码，
Server:
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/lesismal/nbio&amp;#34; ) func main() { g := nbio.NewGopher(nbio.Config{ Network: &amp;#34;tcp&amp;#34;, Addrs: []string{&amp;#34;:8888&amp;#34;}, MaxWriteBufferSize: 6 * 1024 * 1024, }) g.OnData(func(c *nbio.Conn, data []byte) { c.Write(append([]byte{}, data...)) }) err := g.Start() if err != nil { fmt.Printf(&amp;#34;nbio.Start failed: %v\n&amp;#34;, err) return } defer g.Stop() g.Wait() } 使用nbio.NewGopher()函数创建一个新的Engine实例。传入nbio.Config结构体来配置 Engine 实例，包括：
 Network: 使用的网络类型，这里是tcp。 Addrs: 服务器要监听的地址和端口，这里是 &amp;ldquo;:8888&amp;rdquo;（即监听本机的8888端口）。 MaxWriteBufferSize: 写缓冲区的最大大小，这里设置为 6MB。  其他配置可以自行查看。然后使用g.</description>
    </item>
    
    <item>
      <title>27岁有感而发</title>
      <link>https://www.syst.top/lives/every-thing-is-ok/</link>
      <pubDate>Thu, 23 Feb 2023 22:10:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/every-thing-is-ok/</guid>
      <description>迎来了27岁生日，又向互联网年龄警戒线迈出了坚实的一步。
参加工作的第五年。工作前两年半我是乐观的，没有疫情、职业生涯初期、信息闭塞，每天都是技术知识进账的一天。
这一年多我是悲观的，吸进了太多负面信息。
这种情况很像投资，当市场火热时我们往往会过于乐观，忽略风险，采取过度激进的策略；当市场低迷时我们又会过于悲观，胆怯不前。
这两天看到一个开源项目的作者去年在issue上的公告。ps.这个项目挺酷的啊。
不认识作者。从字里行间猜测作者应该是从一线城市回四五线老家，找不到对口的工作，又迫于生计，只得另寻谋生之路。
不过老哥跨度实在是大，从程序员-&amp;gt;外卖小哥-&amp;gt;出纳，终于是把写代码变成真正的爱好。
其实大家都是一样的。从业于互联网，离开一二线城市，几乎是找不到工作的。远程或许是一种答案，如果运气还不错的话。
都说35岁是互联网的天花板，我也曾深夜躺在床上，脑子里预演自己四处求职碰壁的场景。
每每预演到最后，我在想，我需要做什么来终止这一切呢？
作为程序员，我想过两条路，
在学历一般，过往经历普通的情况下，想在35岁依然保持自己职场的核心竞争力，只有一条途径，积极参与开源项目，成为一个领域的专家。从一次pr，成为contributor开始。
这里的开源项目指Apache，CNCF等顶级组织下的开源项目，或者自己通过能力创造出一个备受关注的开源项目。这样的话github就是你的简历，和学历背景无关。
如果未来规划里没有打工这个概念，那就业余去思考，调研，开发自己的产品。推上的一些&amp;quot;成功人士&amp;quot;就是这样的，为自己打工。
这两项都不容易，所以大部分都是普通人。我也并没有什么经验可以传授，因为我和你们一样，一样的普通。
但是可以分享一些学习到的时间管理。
每个人每天的时间花费其实就是四个格子。
我们每天的时间是固定的。你在一个格子上花的时间越多，意味着花在其他格子的时间就减少了。假如你是你们组的消防员，大部分的时间都花在重要紧急、不重要紧急的格子上，你就没有时间花费在重要不紧急的事情上。如果你将更多时间用于规划未来开展一些前瞻性的任务，那么后续就能减少频繁救火的时间。
他们的区别在于思考，一个人如果停止思考，那就和机器没什么区别。
如果一件事每次都需要通过人工紧急处理，那就用程序替代它。
另外，不要成为推荐算法下的傀儡，不要活在自己的信息茧房。
这几年AI真的来了。
从代码神器Copilot，到现在火爆的ChatGPT、Notion AI，再到市面上各种画图、设计的AI工具，用户只需要简单调整参数就得到想要的东西。
ChatGPT是我每天都使用的产品。开了几个固定的窗口，用来日常翻译，写代码，交流idea，咨询问题&amp;hellip;..。
想象你是一名稍微有点经验的程序员，你可以给出你的场景和它讨论方案，让它出设计，划分模块，核心代码逻辑的编写。
又或者你可以直接给出你的代码，让它分析设计是否合理，给出指导意见，并编写一定的单元测试。
想象一下你现在在构思一款产品，脑子里有了初步的原型想法，你把你的想法告诉ChatGPT，可能return回来的时候又多了一些你没考虑的方方面面。
想象你是一名稍有经验的设计师，你正在根据产品设计原型UI，这时候你打开一些AI设计工具，简单的修改了一些参数，你可能就得到了你想要的设计。
这不很有趣嘛。
ChatGPT能不能取代掉业务程序员？
我觉得是有可能的。做业务方面，我觉得只要有足够的上下文，它是能完全理解需求的。对于需求的变更，同样的道理。
至于说屎山难维护的问题，当投喂了足够的需求上下文，哪里还需要维护屎山啊，直接自动重构新版本了。但是话说，屎山级别的项目，难的就是上下文，因为根本不存在一份稍微完整的项目文档。
当然ChatGPT 也不是万能的，它也会出错。有时候它会给你一些错误的答案，有时候它的回复可能看似全面，实则全是废话。在一些边界问题的处理上，它也会经常犯错，需要你多次提醒。
它的背后是不是还需要存在一套干预系统。有没有一种可能，它的干预系统是另一套ChatGPT。就像我们提交代码，组内成员到组Leader的Code Review。Leader上面还有Leader，一直到尽头，好小子，原来是一个睿智的光头人类啊。
有没有一种可能，未来会出现 AI 大一体，每个人都可以与 AI 建立某种形式的联系。基于特定的X传输协议，AI 可以实时读取人的意图。
举个例子，当你正在改造一个项目并形成方案时，AI 可以实时同步你的想法，理解并改进你的方案。然后将这些信息反馈给你，达成共识，最终由 AI 自动完成。这一切都是自然而然地实现，一切尽在无言中。
或许在未来的某年，ChatGPT 会成为别人口中的“iPhone 4”。</description>
    </item>
    
    <item>
      <title>HelloWord一个go开发的学习英语单词工具</title>
      <link>https://www.syst.top/posts/go/helloword/</link>
      <pubDate>Tue, 21 Feb 2023 18:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/helloword/</guid>
      <description>图片拍摄于2023年02月19日 杭州玉鸟集
背景 Hello Word是我在背单词过程中产生的一个想法。
在学习英语时，词汇量是非常重要的。但是仅仅死记硬背单词，没有语境感，效率是很低的。
虽然一些应用程序可以根据单词的多个词义为单词组成一小段句子，稍微增强语境感。但是单词仍然过于零散。
因此，我们是否可以将每天背诵的多个单词组合成一段小短文，以便复习这一批单词呢？这就是Hello Word的初衷。
当然，ChatGPT API暂时是实现这个想法的工具。 除此之外，程序还配套了几个周边小游戏。
单词短语推送器 指定单词数量，随机选择单词，生成一段小短文，推送到用户指定平台。
这个脚本有以下可选项：
 files：默认导入 CET4.txt 单词文件，你可以通过逗号同时导入多个单词文件，它们都存储在 library 文件夹下。 spec：表示推送频率设置，默认为每小时生成一个新的短语，具体时间规则使用的是 robif/cron 库，请参考该库的文档自行设置。 word-number：表示生成一次短语使用的单词数量，默认为 5 个，最多不超过 10 个  效果
单词选择规则，
 默认:随机 最近最少推送(todo)  单词游戏 单词接龙 这是一个单词接龙游戏，游戏开始时系统会随机选择一个单词。玩家需要以该单词的最后一个字母为开头输入一个新单词，接着程序又以玩家输入单词的最后一个字母为开头输出新单词。游戏会持续进行，直到有一方出现错误。
在一局游戏中，每个单词只能被使用一次。
使用
效果
后续规划
 单词正确性校验，是否是合法的英语单词(todo) 超时控制，用户每个回合指定时间内未输出，游戏结束(todo) 错误机会，一局游戏可以错误次数(todo)  其他游戏 单词拼写(todo)、单词填空(todo) 项目地址在: https://github.com/wuqinqiang/helloword
觉得不错可以点个star，感兴趣可以一起开发。</description>
    </item>
    
    <item>
      <title>发现conc并发库一个有趣的问题</title>
      <link>https://www.syst.top/posts/go/conc/</link>
      <pubDate>Tue, 10 Jan 2023 18:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/conc/</guid>
      <description>上周看到一个新库conc，
 better structured concurrency for go
 这个库的目标是，
 更难出现goroutine泄漏 优雅处理panic 使并发的代码更易读  我们一条条细说。
Make it harder to leak goroutines goroutine泄漏还是很常见的。
日常我们使用go的时候直接go func开启一个goroutine，写上对应的逻辑，g会进入到某个p的本地队列，最终由p绑定的m执行这个goroutine。
你能保证一个goroutine在某个时刻一定会结束它的生命周期吗？
搜了下著名开源项目etcd，goroutine leak还真不少。
看其中一个简单的泄漏bug。
done是一个无缓冲的chan，一开始接收动作在最下面，因为中间还有一些没展开的代码可能会导致程序不会执行到&amp;lt;-done，然后goroutine就会发生泄漏，解决方法就是通过defer保证一定会执行&amp;lt;-done。
那么conc是如何做的？
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/sourcegraph/conc&amp;#34; ) func main() { var wg conc.WaitGroup wg.Go(func() { fmt.Println(&amp;#34;g1&amp;#34;) }) wg.Go(func() { fmt.Println(&amp;#34;g2&amp;#34;) }) wg.Wait() } ps:这个结构是不是超级熟悉。
conc的理念是程序中的每一个goroutine由一个owner创建，归属于owner。一个owner确保它拥有的所有goroutine正常退出，这里的owner也就是conc.WaitGroup。
但是这真的能像他说的那样Make it harder to leak goroutines吗？
goroutine的泄漏问题取决于用户对goroutine能正确退出的逻辑保证，和你如何封装没关系吧？
在我看来conc和标准库的sync.WaitGroup一样，等待所有goroutine执行完毕，可以检测到这个行为。
要是goroutine里面含有泄漏的bug，该泄漏还得泄漏，Wait该等待还得老实等待。
Handle panics gracefully 如果直接使用go func,那么可能每一个goroutine都得写上recover，所以一般我们在使用goroutine的时候，都是自己封装一个GoSafe函数。这样就可以在里面统一捕获panic，然后打包调用栈一些信息，进一步处理。
conc里面因为每个goroutine有owner概念，所以是由owner捕获goroutine的panic。</description>
    </item>
    
    <item>
      <title>evio原理解析～有彩蛋</title>
      <link>https://www.syst.top/posts/go/evio/</link>
      <pubDate>Fri, 06 Jan 2023 19:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/evio/</guid>
      <description>之前分析过go自带的netpoll，以及自建的网络框架gnet。
当然这类框架还有:evio、gev、nbio、cloudwego/netpoll(字节的)。
为什么会出现这么多自建框架?
我觉得逃不过三点，
  自带的netpoll满足不了一些特殊场景。
  其他实现设计存在局限性，存在优化空间。
  程序员都喜欢自己造轮子。
  另外，这类框架都是基于syscall epoll实现的事件驱动框架。主要区别我觉得在于，
 对连接conn的管理 对读写数据管理  带着这些问题，我打算把这些框架都看一遍。学习里面优秀的设计以及对比他们的不同点，可以的话，做个整体的性能测试。
这几个框架中，evio是最早的开源实现，开源于2017年。
有意思的是，看到几篇文章说evio存在当loopWrite在内核缓冲区满，无法一次写入时，会出现写入数据丢失的bug。
仔细阅读了代码，evio并不存在这个bug。也不存在是作者后来修复了这个bug，而是evio本身不存在这个bug。
下面会说明。
原理解析 根据代码画了个简易架构图说明evio架构。
简单解释一下，evio启动的时候可以指定loops个数，即多少个epoll实例。同时可以启动多个监听地址，比如图中监听了两个端口。
程序会把每个Listener fd加入到每个epoll并注册这些fd的读事件。每个epoll会开启一个goroutine等待事件到来。
当客户端发起对应端口连接，程序会根据策略选择一个epoll，并把conn fd 也加入到此epoll并注册读写事件。
当一个conn fd读事件ready，那么对应的epoll会被唤醒，然后执行相应的操作。
以上就是整理的流程，接下来我们来深入一些细节。
在此之前，根据上面所描述的，需要先提几个问题，
 当一个新的客户端连接到来时，会发生什么？ 读写数据是如何流动的？ 同一个epoll里多个fd读写事件ready，程序是如何处理的？  看完下面，再回来回答这三个问题。
代码细节 运行一个简单demo，
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/tidwall/evio&amp;#34; &amp;#34;log&amp;#34; ) func main() { var events evio.Events events.NumLoops = 3 events.Serving = func(srv evio.Server) (action evio.Action) { log.</description>
    </item>
    
    <item>
      <title>资源推荐</title>
      <link>https://www.syst.top/lives/source/</link>
      <pubDate>Sat, 24 Dec 2022 18:30:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/source/</guid>
      <description>今天推荐一下平常使用到的资源。
CS自学 如果你像我一样不是科班出身的，没有系统学习过CS课程，那么这个网址很适合你。里面大多数是国外顶级大学CS相关的公开课。有些可能你已经看过书籍了，只是拿来垫桌脚了，比如深入理解计算机系统😂。这些CS课程其实和书中的章节是对应的。所以一个技巧是先对着书预习，然后再看视频。当然，书中的题目也可以适当的做下，要是能输出就更好了。这是一个漫长的过程，希望你能耐得住寂寞～
架构 我之前看过的两本书籍感觉还不错：&amp;laquo;软件架构设计&amp;raquo; 和 &amp;laquo;凤凰架构&amp;raquo; 。这两本都是国人写的，我们看起来可能更加贴切。
也有一些关于架构的网站。
 system-design system-design-primer bytebytego system-design-interview  当然，这些系统设计大概都是从高层次的角度来分析设计的，并不会涉及过多的细节。很多细节也需要在对应场景才能对应分析吧，细节是魔鬼。
区块链 最近几年挺火的一个话题，虽然你可能并没有从事相关工作，但是并不妨碍你去了解它，这样好歹别人跟你吹牛的时候，你不会被他忽悠。然后你就知道大多数web3项目本质上还是一个中心化的项目。大家拿着&amp;quot;去中心化&amp;quot;,”可匿名性“的地址，在中心化的平台上进行交易，你还能说这是匿名的吗？
关于区块链的视频，我推荐一个对程序员来说入门首选的视频。
北大肖臻的&amp;laquo;区块链技术与应用&amp;raquo;。
工具类 随便介绍两个吧。
Data Structure Visualizations 这个项目可以把常见的数据结构和算法以动画的的形式展示出来。
maigret 这个项目有点牛逼，输入一个id，就能把互联网上你的相关账户全部扒出来。
grammarly 这个大部分人应该都知道，平时比如写issues或者代码注释的时候，像我英语不好的人，想要确认有没有英语语法错误或者单词拼写错误，甚至是标点符号，靠它纠正了。
wakatime 这个工具可以统计你最近一段时间内编码时间，还有一些时间分配。goland 和 vscode 都有插件。</description>
    </item>
    
  </channel>
</rss>
