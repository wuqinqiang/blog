<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>是不是很酷</title>
    <link>https://www.syst.top/</link>
    <description>Recent content on 是不是很酷</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 23 Feb 2023 23:23:51 +0800</lastBuildDate><atom:link href="https://www.syst.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Myfriends</title>
      <link>https://www.syst.top/friends/friends/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.syst.top/friends/friends/</guid>
      <description></description>
    </item>
    
    <item>
      <title>nbio原理解析</title>
      <link>https://www.syst.top/posts/go/nbio/</link>
      <pubDate>Thu, 23 Feb 2023 23:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/nbio/</guid>
      <description>之前更新的一系列，好久没更新了，差点烂尾，我不允许这样的事情在我身上发生(虽然已经烂尾好几次了😭)。
上一篇文章我们介绍了evio，它应该是最早基于epoll实现的Go Netpoll框架，我们也提到它存在的一些问题，这篇文章我们继续分析其他的实现框架: nbio。
nbio项目里也包含了在nbio之上构建的nbhttp，这个不在我们讨论范围。
nbio使用的也是经典的Reactor模式，go的这几个异步网络框架都是Reactor模式。
老规矩，先运行nbio程序代码，
Server:
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/lesismal/nbio&amp;#34; ) func main() { g := nbio.NewGopher(nbio.Config{ Network: &amp;#34;tcp&amp;#34;, Addrs: []string{&amp;#34;:8888&amp;#34;}, MaxWriteBufferSize: 6 * 1024 * 1024, }) g.OnData(func(c *nbio.Conn, data []byte) { c.Write(append([]byte{}, data...)) }) err := g.Start() if err != nil { fmt.Printf(&amp;#34;nbio.Start failed: %v\n&amp;#34;, err) return } defer g.Stop() g.Wait() } 使用nbio.NewGopher()函数创建一个新的Engine实例。传入nbio.Config结构体来配置 Engine 实例，包括：
 Network: 使用的网络类型，这里是tcp。 Addrs: 服务器要监听的地址和端口，这里是 &amp;ldquo;:8888&amp;rdquo;（即监听本机的8888端口）。 MaxWriteBufferSize: 写缓冲区的最大大小，这里设置为 6MB。  其他配置可以自行查看。然后使用g.</description>
    </item>
    
    <item>
      <title>27岁有感而发</title>
      <link>https://www.syst.top/lives/every-thing-is-ok/</link>
      <pubDate>Thu, 23 Feb 2023 22:10:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/every-thing-is-ok/</guid>
      <description>迎来了27岁生日，又向互联网年龄警戒线迈出了坚实的一步。
参加工作的第五年。工作前两年半我是乐观的，没有疫情、职业生涯初期、信息闭塞，每天都是技术知识进账的一天。
这一年多我是悲观的，吸进了太多负面信息。
这种情况很像投资，当市场火热时我们往往会过于乐观，忽略风险，采取过度激进的策略；当市场低迷时我们又会过于悲观，胆怯不前。
这两天看到一个开源项目的作者去年在issue上的公告。ps.这个项目挺酷的啊。
不认识作者。从字里行间猜测作者应该是从一线城市回四五线老家，找不到对口的工作，又迫于生计，只得另寻谋生之路。
不过老哥跨度实在是大，从程序员-&amp;gt;外卖小哥-&amp;gt;出纳，终于是把写代码变成真正的爱好。
其实大家都是一样的。从业于互联网，离开一二线城市，几乎是找不到工作的。远程或许是一种答案，如果运气还不错的话。
都说35岁是互联网的天花板，我也曾深夜躺在床上，脑子里预演自己四处求职碰壁的场景。
每每预演到最后，我在想，我需要做什么来终止这一切呢？
作为程序员，我想过两条路，
在学历一般，过往经历普通的情况下，想在35岁依然保持自己职场的核心竞争力，只有一条途径，积极参与开源项目，成为一个领域的专家。从一次pr，成为contributor开始。
这里的开源项目指Apache，CNCF等顶级组织下的开源项目，或者自己通过能力创造出一个备受关注的开源项目。这样的话github就是你的简历，和学历背景无关。
如果未来规划里没有打工这个概念，那就业余去思考，调研，开发自己的产品。推上的一些&amp;quot;成功人士&amp;quot;就是这样的，为自己打工。
这两项都不容易，所以大部分都是普通人。我也并没有什么经验可以传授，因为我和你们一样，一样的普通。
但是可以分享一些学习到的时间管理。
每个人每天的时间花费其实就是四个格子。
我们每天的时间是固定的。你在一个格子上花的时间越多，意味着花在其他格子的时间就减少了。假如你是你们组的消防员，大部分的时间都花在重要紧急、不重要紧急的格子上，你就没有时间花费在重要不紧急的事情上。如果你将更多时间用于规划未来开展一些前瞻性的任务，那么后续就能减少频繁救火的时间。
他们的区别在于思考，一个人如果停止思考，那就和机器没什么区别。
如果一件事每次都需要通过人工紧急处理，那就用程序替代它。
另外，不要成为推荐算法下的傀儡，不要活在自己的信息茧房。
这几年AI真的来了。
从代码神器Copilot，到现在火爆的ChatGPT、Notion AI，再到市面上各种画图、设计的AI工具，用户只需要简单调整参数就得到想要的东西。
ChatGPT是我每天都使用的产品。开了几个固定的窗口，用来日常翻译，写代码，交流idea，咨询问题&amp;hellip;..。
想象你是一名稍微有点经验的程序员，你可以给出你的场景和它讨论方案，让它出设计，划分模块，核心代码逻辑的编写。
又或者你可以直接给出你的代码，让它分析设计是否合理，给出指导意见，并编写一定的单元测试。
想象一下你现在在构思一款产品，脑子里有了初步的原型想法，你把你的想法告诉ChatGPT，可能return回来的时候又多了一些你没考虑的方方面面。
想象你是一名稍有经验的设计师，你正在根据产品设计原型UI，这时候你打开一些AI设计工具，简单的修改了一些参数，你可能就得到了你想要的设计。
这不很有趣嘛。
ChatGPT能不能取代掉业务程序员？
我觉得是有可能的。做业务方面，我觉得只要有足够的上下文，它是能完全理解需求的。对于需求的变更，同样的道理。
至于说屎山难维护的问题，当投喂了足够的需求上下文，哪里还需要维护屎山啊，直接自动重构新版本了。但是话说，屎山级别的项目，难的就是上下文，因为根本不存在一份稍微完整的项目文档。
当然ChatGPT 也不是万能的，它也会出错。有时候它会给你一些错误的答案，有时候它的回复可能看似全面，实则全是废话。在一些边界问题的处理上，它也会经常犯错，需要你多次提醒。
它的背后是不是还需要存在一套干预系统。有没有一种可能，它的干预系统是另一套ChatGPT。就像我们提交代码，组内成员到组Leader的Code Review。Leader上面还有Leader，一直到尽头，好小子，原来是一个睿智的光头人类啊。
有没有一种可能，未来会出现 AI 大一体，每个人都可以与 AI 建立某种形式的联系。基于特定的X传输协议，AI 可以实时读取人的意图。
举个例子，当你正在改造一个项目并形成方案时，AI 可以实时同步你的想法，理解并改进你的方案。然后将这些信息反馈给你，达成共识，最终由 AI 自动完成。这一切都是自然而然地实现，一切尽在无言中。
或许在未来的某年，ChatGPT 会成为别人口中的“iPhone 4”。</description>
    </item>
    
    <item>
      <title>HelloWord一个go开发的学习英语单词工具</title>
      <link>https://www.syst.top/posts/go/helloword/</link>
      <pubDate>Tue, 21 Feb 2023 18:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/helloword/</guid>
      <description>图片拍摄于2023年02月19日 杭州玉鸟集
背景 Hello Word是我在背单词过程中产生的一个想法。
在学习英语时，词汇量是非常重要的。但是仅仅死记硬背单词，没有语境感，效率是很低的。
虽然一些应用程序可以根据单词的多个词义为单词组成一小段句子，稍微增强语境感。但是单词仍然过于零散。
因此，我们是否可以将每天背诵的多个单词组合成一段小短文，以便复习这一批单词呢？这就是Hello Word的初衷。
当然，ChatGPT API暂时是实现这个想法的工具。 除此之外，程序还配套了几个周边小游戏。
单词短语推送器 指定单词数量，随机选择单词，生成一段小短文，推送到用户指定平台。
这个脚本有以下可选项：
 files：默认导入 CET4.txt 单词文件，你可以通过逗号同时导入多个单词文件，它们都存储在 library 文件夹下。 spec：表示推送频率设置，默认为每小时生成一个新的短语，具体时间规则使用的是 robif/cron 库，请参考该库的文档自行设置。 word-number：表示生成一次短语使用的单词数量，默认为 5 个，最多不超过 10 个  效果
单词选择规则，
 默认:随机 最近最少推送(todo)  单词游戏 单词接龙 这是一个单词接龙游戏，游戏开始时系统会随机选择一个单词。玩家需要以该单词的最后一个字母为开头输入一个新单词，接着程序又以玩家输入单词的最后一个字母为开头输出新单词。游戏会持续进行，直到有一方出现错误。
在一局游戏中，每个单词只能被使用一次。
使用
效果
后续规划
 单词正确性校验，是否是合法的英语单词(todo) 超时控制，用户每个回合指定时间内未输出，游戏结束(todo) 错误机会，一局游戏可以错误次数(todo)  其他游戏 单词拼写(todo)、单词填空(todo) 项目地址在: https://github.com/wuqinqiang/helloword
觉得不错可以点个star，感兴趣可以一起开发。</description>
    </item>
    
    <item>
      <title>发现conc并发库一个有趣的问题</title>
      <link>https://www.syst.top/posts/go/conc/</link>
      <pubDate>Tue, 10 Jan 2023 18:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/conc/</guid>
      <description>上周看到一个新库conc，
 better structured concurrency for go
 这个库的目标是，
 更难出现goroutine泄漏 优雅处理panic 使并发的代码更易读  我们一条条细说。
Make it harder to leak goroutines goroutine泄漏还是很常见的。
日常我们使用go的时候直接go func开启一个goroutine，写上对应的逻辑，g会进入到某个p的本地队列，最终由p绑定的m执行这个goroutine。
你能保证一个goroutine在某个时刻一定会结束它的生命周期吗？
搜了下著名开源项目etcd，goroutine leak还真不少。
看其中一个简单的泄漏bug。
done是一个无缓冲的chan，一开始接收动作在最下面，因为中间还有一些没展开的代码可能会导致程序不会执行到&amp;lt;-done，然后goroutine就会发生泄漏，解决方法就是通过defer保证一定会执行&amp;lt;-done。
那么conc是如何做的？
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/sourcegraph/conc&amp;#34; ) func main() { var wg conc.WaitGroup wg.Go(func() { fmt.Println(&amp;#34;g1&amp;#34;) }) wg.Go(func() { fmt.Println(&amp;#34;g2&amp;#34;) }) wg.Wait() } ps:这个结构是不是超级熟悉。
conc的理念是程序中的每一个goroutine由一个owner创建，归属于owner。一个owner确保它拥有的所有goroutine正常退出，这里的owner也就是conc.WaitGroup。
但是这真的能像他说的那样Make it harder to leak goroutines吗？
goroutine的泄漏问题取决于用户对goroutine能正确退出的逻辑保证，和你如何封装没关系吧？
在我看来conc和标准库的sync.WaitGroup一样，等待所有goroutine执行完毕，可以检测到这个行为。
要是goroutine里面含有泄漏的bug，该泄漏还得泄漏，Wait该等待还得老实等待。
Handle panics gracefully 如果直接使用go func,那么可能每一个goroutine都得写上recover，所以一般我们在使用goroutine的时候，都是自己封装一个GoSafe函数。这样就可以在里面统一捕获panic，然后打包调用栈一些信息，进一步处理。
conc里面因为每个goroutine有owner概念，所以是由owner捕获goroutine的panic。</description>
    </item>
    
    <item>
      <title>evio原理解析～有彩蛋</title>
      <link>https://www.syst.top/posts/go/evio/</link>
      <pubDate>Fri, 06 Jan 2023 19:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/evio/</guid>
      <description>之前分析过go自带的netpoll，以及自建的网络框架gnet。
当然这类框架还有:evio、gev、nbio、cloudwego/netpoll(字节的)。
为什么会出现这么多自建框架?
我觉得逃不过三点，
  自带的netpoll满足不了一些特殊场景。
  其他实现设计存在局限性，存在优化空间。
  程序员都喜欢自己造轮子。
  另外，这类框架都是基于syscall epoll实现的事件驱动框架。主要区别我觉得在于，
 对连接conn的管理 对读写数据管理  带着这些问题，我打算把这些框架都看一遍。学习里面优秀的设计以及对比他们的不同点，可以的话，做个整体的性能测试。
这几个框架中，evio是最早的开源实现，开源于2017年。
有意思的是，看到几篇文章说evio存在当loopWrite在内核缓冲区满，无法一次写入时，会出现写入数据丢失的bug。
仔细阅读了代码，evio并不存在这个bug。也不存在是作者后来修复了这个bug，而是evio本身不存在这个bug。
下面会说明。
原理解析 根据代码画了个简易架构图说明evio架构。
简单解释一下，evio启动的时候可以指定loops个数，即多少个epoll实例。同时可以启动多个监听地址，比如图中监听了两个端口。
程序会把每个Listener fd加入到每个epoll并注册这些fd的读事件。每个epoll会开启一个goroutine等待事件到来。
当客户端发起对应端口连接，程序会根据策略选择一个epoll，并把conn fd 也加入到此epoll并注册读写事件。
当一个conn fd读事件ready，那么对应的epoll会被唤醒，然后执行相应的操作。
以上就是整理的流程，接下来我们来深入一些细节。
在此之前，根据上面所描述的，需要先提几个问题，
 当一个新的客户端连接到来时，会发生什么？ 读写数据是如何流动的？ 同一个epoll里多个fd读写事件ready，程序是如何处理的？  看完下面，再回来回答这三个问题。
代码细节 运行一个简单demo，
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/tidwall/evio&amp;#34; &amp;#34;log&amp;#34; ) func main() { var events evio.Events events.NumLoops = 3 events.Serving = func(srv evio.Server) (action evio.Action) { log.</description>
    </item>
    
    <item>
      <title>资源推荐</title>
      <link>https://www.syst.top/lives/source/</link>
      <pubDate>Sat, 24 Dec 2022 18:30:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/source/</guid>
      <description>今天推荐一下平常使用到的资源。
CS自学 如果你像我一样不是科班出身的，没有系统学习过CS课程，那么这个网址很适合你。里面大多数是国外顶级大学CS相关的公开课。有些可能你已经看过书籍了，只是拿来垫桌脚了，比如深入理解计算机系统😂。这些CS课程其实和书中的章节是对应的。所以一个技巧是先对着书预习，然后再看视频。当然，书中的题目也可以适当的做下，要是能输出就更好了。这是一个漫长的过程，希望你能耐得住寂寞～
架构 我之前看过的两本书籍感觉还不错：&amp;laquo;软件架构设计&amp;raquo; 和 &amp;laquo;凤凰架构&amp;raquo; 。这两本都是国人写的，我们看起来可能更加贴切。
也有一些关于架构的网站。
 system-design system-design-primer bytebytego system-design-interview  当然，这些系统设计大概都是从高层次的角度来分析设计的，并不会涉及过多的细节。很多细节也需要在对应场景才能对应分析吧，细节是魔鬼。
区块链 最近几年挺火的一个话题，虽然你可能并没有从事相关工作，但是并不妨碍你去了解它，这样好歹别人跟你吹牛的时候，你不会被他忽悠。然后你就知道大多数web3项目本质上还是一个中心化的项目。大家拿着&amp;quot;去中心化&amp;quot;,”可匿名性“的地址，在中心化的平台上进行交易，你还能说这是匿名的吗？
关于区块链的视频，我推荐一个对程序员来说入门首选的视频。
北大肖臻的&amp;laquo;区块链技术与应用&amp;raquo;。
工具类 随便介绍两个吧。
Data Structure Visualizations 这个项目可以把常见的数据结构和算法以动画的的形式展示出来。
maigret 这个项目有点牛逼，输入一个id，就能把互联网上你的相关账户全部扒出来。
grammarly 这个大部分人应该都知道，平时比如写issues或者代码注释的时候，像我英语不好的人，想要确认有没有英语语法错误或者单词拼写错误，甚至是标点符号，靠它纠正了。
wakatime 这个工具可以统计你最近一段时间内编码时间，还有一些时间分配。goland 和 vscode 都有插件。</description>
    </item>
    
    <item>
      <title>easycar更新日记</title>
      <link>https://www.syst.top/posts/go/easycar2/</link>
      <pubDate>Sun, 06 Nov 2022 10:11:22 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/easycar2/</guid>
      <description>开篇 又拖更了一个多月，在思考人生的意义。
上一次介绍了新开发的一个分布式的事务框架easycar，这篇就当是对easycar的更新日记了。
服务注册与发现
由于easycar底层基于gRPC, 通过自定义Resolver接口还是很容易实现的。
负载均衡
客户端负载均衡，目前支持
  round-robin
  random
  power of 2 random choice
  consistent hash
  ip-hash
  least-load
  架构图
上次提到，参与的一组分布式事务可能部分操作存在先后顺序的问题。
我举了个例子，我们需要保证必须先执行account扣减余额和stock扣减库存服务成功后，才能创建订单order的服务。同时account和stock服务并不需要保证他们的执行顺序。下图，
以这个例子，那么实际在easycar中整个流程，
成功
失败
在easycar中，client负责和easycar(TC)端交互。主要负责注册分支，触发执行分布式事务以及查看状态等。
它并不会和RM产生联系。也就是说它不会负责去请求RM的第一阶段，这是和其他平台不同的一点。
TC全程接管和更新RM状态。
分支状态
项目地址:
Easycar: https://github.com/wuqinqiang/easycar
Client-go: https://github.com/easycar/client-go
Examples： https://github.com/easycar/examples</description>
    </item>
    
    <item>
      <title>一个用go实现的分布式事务框架</title>
      <link>https://www.syst.top/posts/go/easycar/</link>
      <pubDate>Mon, 12 Sep 2022 18:11:22 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/easycar/</guid>
      <description>开篇 对分布式事务一直感兴趣，之前一直被其他事情(懒)耽搁了，最近终于动手了。
easycar是什么 easycar 是一个用go实现的支持两阶段提交协议的分布式事务框架。目前还只支持TCC,SAGA 模式，其他模式待开发。
在介绍easycar 之前，先简单介绍几个角色。
Transaction Coordinator(TC) 负责全局事务的管理，所有参与分布式事务的分支都会注册到coordinator，回给每个分布式事务分配一个唯一id，
当然还包括驱动全局 begin / commit /abort(我喜欢称rollback)。
Transaction Manager (TM) 有些时候也叫 Transaction Client，当然不同的实现也许都会换个名字，但是职责都大差不差。
一般通过TM对每个参与的RM发起一阶段的请求，如果一阶段的RM全部成功，那么TM会向TC发起commit请求，否则发起rollback。
Resource Manager(RM) 用户维度的角色，管理本地事务处理的资源。其实你可以这么理解，假设你的订单服务部分接口参与了分布式事务，无论是第一阶段TM调用接口，还是TC第二阶段调用接口，你的订单服务都会去负责本地的事务修改。
那么 easycar 上述角色有什么不同吗？
有的。既然TC负责的就是全局事务的管理，那么我把职责都给了它。即由TC像每个参与的RM发起一阶段的请求，然后再根据一阶段的结果，发起二阶段的请求。由TC接管整个分布式事务的生命周期。
是的，我弱化了上面TM的能力。在我眼里，TM本质上就是一个客户端。客户端只需要做一些数据封装，简便化操作即可。所以即使没有客户端，其他语言的用户也可以直接通过http请求easycar服务接口。
所以理论上，大部分模式下，不需要客户端也是可以直接使用easycar服务的。
支持协议和事务模式同时混用 参与分布式事务的服务往往由不同的多个部门维护，或者部分新老项目交错，可能无法保证服务的协议是一致的。
另外，不同的服务所采用的事务模式具体是由：业务场景以及构造的成本来决定的。所以参与分布式事务之间所使用的事务模式不一定是统一的。
在这些基础上，easycar支持协议混用(目前支持http和原生的grpc服务)，支持部分事务模式混用(目前支持TCC,Saga)。
支持并发执行 假如现在有 order，account以及stock三个服务。
由这三个服务组成一个分布式事务。 当用户下单时，需要经过这三个服务中内部一些接口(account 扣钱，stock减库存，order 创建订单)。
如果只是同步执行第一阶段，那么第一阶段总执行时间= (account+stock+order)。
很多场景下，分布式事务之间并不会存在执行依赖先后的关系。所以多个子事务一阶段可以同时并发执行。
流程就像这样：
上图我们需要保证创建订单前必须先执行account扣减余额和stock扣减库存服务，才能创建订单order的服务。同时account和stock服务并不需要保证他们的执行顺序。
那么我们一阶段总执行耗时可以粗略=max(account,stock)+order。
因此，easycar是支持分层并发执行的。 对参与的RM通过设置的权重做分层，同一层的RM可以并发调用，一层处理完毕再接下一层。在这个基础上，当某个RM发生调用错误时，那么后面一层也不会执行了，整个分布式事务需要回滚。
异常处理 分布式事务中会出现一些问题，比如
  空补偿： Cancel请求到来时，Try还没有执行，这时候这样的请求我们不能执行，理应直接返回。
  悬挂： Try执行时，Cancel已执行完成，不能执行，直接返回。
  幂等： 所有操作的接口都存在这个问题。
  这些问题需要用户自己去解决，框架不会自动帮你处理。
在我看来，这些问题本身就是服务的必要工作，而不是通过外部服务来帮你保证。
换句话说，前端说它参数做了校验，难道后端就不校验接口了吗？</description>
    </item>
    
    <item>
      <title>婚姻</title>
      <link>https://www.syst.top/lives/hunyin/</link>
      <pubDate>Sun, 19 Jun 2022 21:01:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/hunyin/</guid>
      <description>这也算不定期更新的日常。
对我来说好遥远的话题啊。
高中的前桌和我说国庆要结婚了，真替她感到高兴。
发小的婚礼和她是同一天。
好在前桌是嫁人，女方正餐是中午。发小是娶媳妇，正餐是晚上，两边正餐都赶的上，一点都不误吃席。
村里同阶段的发小挺多了的，没结婚的就更多了。以至于每次我们都会互相调侃对方啥时让兄弟们吃席。
这两年断断续续参加了几次同学朋友发小的婚礼，每次都会有不一样的体验。
尽管他们的面容千姿百态，但是脸上写满的笑容都一样的藏不住。
难道，只有婚姻才能让他们开怀大笑吗？
可是，每每和他们接触的时候，并没有看出婚姻对他们进行的自身&amp;quot;改造&amp;quot;，以至于我一度怀疑婚姻的可选性。
因此，我曾经开玩笑似的问一个朋友，
结婚后有什么区别。
朋友的回答是没啥区别。
咋么能没啥区别呢。
噢，他一定是在敷衍我。
说实话，我确实无法体会婚姻意味着什么。家庭、责任、义务&amp;hellip;&amp;hellip;，这些都是别人口中说的，和我没什么关系。
但是随着年纪的增大，环境因素的干扰(主要是爸妈，每每和我聊天的时候都会不经意间的暗示)，我不得不开始考虑这个问题。
之前一个朋友和她男朋友同居了。她就一个婚前同居的问题和我有过讨论，她觉得就应该有婚前同居的行为，才能深入了解对方balabala&amp;hellip;..
我猜是她和另外的人关于这个问题发生了争执，所以才来问问我。
我哪懂这些啊。
但是我心里很清楚，她的本质并不是和我讨论这个问题的对错，而是来寻求我的肯定。
她需要别人去认可她的做法，以寻求内心的平静。
所以我只是在她发表自己想法的同时点头说嗯，仅此而已。
现在，她也快结婚了。
至于我，首先得new个对象。</description>
    </item>
    
  </channel>
</rss>
