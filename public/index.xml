<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>记得</title>
    <link>https://www.syst.top/</link>
    <description>Recent content on 记得</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 16 Apr 2022 20:24:52 +0800</lastBuildDate><atom:link href="https://www.syst.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Myfriends</title>
      <link>https://www.syst.top/friends/friends/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.syst.top/friends/friends/</guid>
      <description></description>
    </item>
    
    <item>
      <title>不定期更新的日常</title>
      <link>https://www.syst.top/lives/2022-04-16/</link>
      <pubDate>Sat, 16 Apr 2022 20:24:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/2022-04-16/</guid>
      <description>这个系列也好久没更新了，那就随便聊聊吧。
这段时间我在做什么？
总结下来就是，学英语、冥想、练习打字。
英语 英语这件事，还是特别重要的，在我心目中的分量排第一。
我记得刚参加工作那会，当时连qiang都没翻过，红到不能在红。
那时候只会百度，csdn常伴我身。遇到英文报错(哪来的中文啊)，只会把那一段连根复制到百度搜索，只要有答案出来，还思考个啥，使出cv大法。
跑通了:作者牛逼。
跑不通:傻逼作者。
更别提去官方文档查阅资料，去issues上看问题了。
当时凡事都先百度，xxx咋么、zzz如何&amp;hellip;&amp;hellip;。
虽然现在看的都是官网文档，偶尔看一些国外的技术文章以及感兴趣方向的论文，但是技术性的资料常常也带有些许垂直领域的标签。很多词都是一些专业通用术语，可能第一次你不知道，查询了一次，下次你就知道啥意思，看的多了，行业内的词汇量也就差不多了。
和日常英语还是有一丢丢不同的，
毕竟生活中的英语，单词范围更大，句子中还带有梗在里面，看不懂也听不懂，就像外国人看不懂中文一个道理。
我的英语确实不咋地。所以需要下功夫。不过还好，我觉得语言这方面，如果肯花精力，去刻意练习，提高英语水平也只是时间的问题。
不过得需要找到适合自己的最佳方式。
首先，语言学习我们都分为听、说、读、写对吧。如果你直接靠背单词入手，对于每一个单词，你得听它的发音，知道它的单词拼写，还得知道它的意思，最后自己要说出来。这就意味着相当于你一次性的去学习听、说、读、写这四个部分，还是基于没有上下文的环境下，效果就不用多说了吧。
我在油管看到Tinyfool老师的频道，他的观点是建立以听力为主导的英语学习的方式。
首先一定得先听懂别人在讲什么，你听懂了，会不会说是另一回事，至少你可以通过肢体语言回应对方。(我想了想等你已经听得懂别人说什么的时候，理论上多少能说一点)
但是如果你连听都听不懂别人说什么，你咋通过你的器官做出回应？靠fuck嘛？
所以听这是前置条件，我也十分认可。不然我实在想不通为啥国内英语考试第一部分一定是听力。
我现在的做法是，找到自己喜欢的一个播客，每一篇四分钟左右的语音，我会先听一遍，一般能听懂它的主题是啥，大概说了啥，有哪里是完全没听懂的。然后再看一遍原文，记录生词，看下完全没听懂的地方是在说啥，最后再重新听一遍。
要是第一遍连主题都没听懂的，一般就是完全不涉及的领域，全是领域专用词。
不知道你们都是如何学习英语的，希望留言区能分享，或者给点意见。
冥想 一年前的时候看过一点书，有尝试过，后面中断了。
前几周逛西溪的时候，老远看到一个小姐姐在那打坐冥想，我去的时候她已经在了，我站在远处呆了十几分钟，小姐姐一动不动，似乎进入状态。后面我就走了，很想问一句，她是睡着了吗？
回来的时候，自己当天就重新拾起冥想了。我是从一开始的5分钟到7分钟到10分钟到现在15分钟。
我的做法也很简单，每天固定时间(去除一切外部干扰，环境要安静),定个时间，就坐在床上，然后闭眼进入状态，我的注意力都在我的呼吸上。
冥想的一个困难点从我的感受来看在于注意力。在这短短的几分钟，你的注意力可能会转移到不同的场景中，我认为这是一种主观意识发生改变。所以当你的注意力发生转移，你需要的是立刻把它拉回来。
这段时间感受下来，冥想对我好处主要两点，
 获取内心的平静。 累的时候，花个十分钟左右的冥想，能让我恢复状态。  以上只是我对冥想浅浅的认知。
打字 啥？打字？
不怕你们笑话，我打字不是使用的标准指法，可能多少会有点影响，所以我想把它标准化。
别说，因为习惯的问题，短时间还真不好改，正在慢慢尝试改变。我主要在typingclub这个网站上，每天练习半个小时。
好了，这期的不定期更新的日常到这里就结束。欢迎一起讨论。</description>
    </item>
    
    <item>
      <title>Go netpoll大解析</title>
      <link>https://www.syst.top/posts/go/netpoll/</link>
      <pubDate>Thu, 14 Apr 2022 10:23:51 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/netpoll/</guid>
      <description>开篇 之前简单看过一点go原生netpoll，没注意太多细节。最近从头到尾看了一遍，特写篇文章记录下。文章很长，请耐心看完，一定有所收获。
用户空间和内核空间 在linux中，经常能看到两个词语:User space(用户空间)和Kernel space (内核空间)。
简单的说， Kernel space是linux内核运行的空间，User space是用户程序运行的空间。它们之间是相互隔离的。
现代操作系统都是采用虚拟存储器。那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。空间分配如下图所示：
Kernel space可以调用系统的一切资源。User space 不能直接调用系统资源，在 Linux系统中，所有的系统资源管理都是在内核空间中完成的。比如读写磁盘文件、分配回收内存、从网络接口读写数据等等。应用程序无法直接进行这样的操作，但是用户程序可以通过内核提供的接口来完成这样的任务。比如像下面这样，
应用程序要读取磁盘上的一个文件，它可以向内核发起一个 “系统调用” 告诉内核：”我要读取磁盘上的某某文件”。其实就是通过一个特殊的指令让进程从用户态进入到内核态，在内核空间中，CPU 可以执行任何的指令，当然也包括从磁盘上读取数据。具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并且拿到了想要的数据，继续往下执行用户空间执行逻辑。
这样的话，一旦涉及到对I/O的处理，就必然会涉及到在用户态和内核态之间来回切换。
io模型 网上有太多关于I/O模型的文章，看着看着有可能就跑偏了，所以我还是从 &amp;laquo;UNIX 网络编程&amp;raquo; 中总结的5中I/O模型说起吧。
Unix可用的5种I/O模型。
 阻塞I/O 非阻塞I/O I/O复用 信号驱动式I/O(SIGIO) 异步I/O(POSIX的aio_系列函数)  阻塞I/O 阻塞式I/O下，进程调用recvfrom，直到数据到达且被复制到应用程序的缓冲区中或者发生错误才返回，在整个过程进程都是被阻塞的。
非阻塞I/O 从图中可以看出，前三次调用recvfrom中没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用程序缓冲区，于是recvfrom成功返回。
当一个应用程序像这样对一个非阻塞描述符循环调用recvfrom时，我们通常称为轮询(polling)，持续轮询内核，以这种方式查看某个操作是否就绪。
I/O多路复用 有了I/O多路复用(I/O multiplexing)，我们就可以调用 select 或者 poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。
上面这句话难理解是吧，说白了这里指的是，在第一步中，我们只是阻塞在select调用上，直到数据报套接字变为可读，返回可读条件，这里并没有发生I/O事件，所以说这一步，并没有阻塞在真正的I/O系统调用上。
其他两种就不过多介绍了。
还有一点，我们会经常提到同步I/O和异步I/O。
POSIX 把这两种术语定义如下:
 同步I/O操作(synchronous I/O opetation) 导致请求进程被阻塞，直到I/O操作完成。 异步I/O(asynchronous opetation) 不导致请求进程被阻塞。  基于上面的定义，
异步I/O的关键在于第二步的recrfrom是否会阻塞住用户进程，如果不阻塞，那它就是异步I/O。从上面汇总图中可以看出，只有异步I/O满足POSIX中对异步I/O的定义。
Go netpoller Go netpoller 底层就是对I/O多路复用的封装。不同平台对I/O多路复用有不同的实现方式。比如Linux的select、poll和epoll(具体差别不是很明白可以看这篇)。在MacOS则是kqueue,而Windows是基于异步I/O实现的icop&amp;hellip;&amp;hellip;，基于这些背景，Go针对不同的平台调用实现了多版本的netpoller。
下面我们通过一个demo开始讲解。
很简单一个demo，开启一个tcp服务。然后每来一个连接，就启动一个g去处理连接。处理完毕，关闭连接。
而且我们使用的是同步的模式去编写异步的逻辑，一个连接对应一个g处理，极其简单和易于理解。go标准库中的http.server也是这么干的。</description>
    </item>
    
    <item>
      <title>《软件架构设计》读书笔记</title>
      <link>https://www.syst.top/readings/go-concurrency-2021-04-20/</link>
      <pubDate>Sat, 19 Mar 2022 08:42:10 +0800</pubDate>
      
      <guid>https://www.syst.top/readings/go-concurrency-2021-04-20/</guid>
      <description>之前说过，会分享一些看书笔记。 前段时间，大佬同事推荐了一本书，书名叫《软件架构设计:大型网站技术架构与业务架构融合之道》,特做一些笔记分享。
这本书整体分为五个部分。
 什么是架构 计算机功底 技术架构之道 业务架构之道 从架构得到技术管理  围绕这五个部分总计17章节。
接下来，我会分享部分我感兴趣的章节。
第一部分：什么是架构？ 一句话:架构是针对所有重要问题做出的重要决策。
不同公司或者相同公司在不同的阶段所面临的问题不同，架构自然也会有所不同。
个人认为，不存在称之为完美的架构，只会存在最适合的。面对的场景，着重的目的不同，那么相应的决策也会不同(有点废话)。
架构的分类。 作者从技术的角度，把软件从底向上分层，做了架构的分类。
第一层:基础架构 基础架构指的是云平台、操作系统、网络、存储、数据库和编译等。
第二层:中间件和大数据平台 中间件，例如分布式服务中间件、消息中间件、数据库中间件、缓存中间件等。
第三层:业务系统架构  通用软件系统。例如常用办公软件、播放器。 离线业务。比如各种基于数据的离线计算、数据挖掘。 大型在线系统。比如电商、广告、搜索、推荐、ERP或者CRM等。  整体就像这样, 从上面你也可以看出，只有大厂这三层都有。像小公司可能只有第三层，或者小量的第二层。 印象里，我前司是没有第一层的，第二层是有的。
一般情况下，每一层都会有专门的人去干活。比如第二层会有专门的中间件部门， 对应又分为几个组，每个组负责对应的中间件开发。
业务部门在第三层，一般情况下，他们只负责业务的curd，如果有场景需要用到一些中间件时， 这时候通常会去找负责中间件的人对接，使用他们的sdk等。(ps:好不好用那就是另外一回事了)
还有一个有意思点，作者在书中提到架构的道与术。
什么是架构的道?
抽象点说，对于技术问题，主要是指高并发、高可用和一致性方面。对于业务问题，主要指业务需求分析和建模。 那么，我们在面对这些问题的时候， 是通过大量的业务系统实践，在实践基础上进行的思考和总结，进而提炼出的一些方法论，这就是道。
更具体的的说，比如，
 数据库如何分库分表？ 分库分表的时机如何确定？ 缓存一致性问题如何解决？ 如何拆分服务？ &amp;hellip;&amp;hellip;  等等问题，这些问题解决方案并不是凭空出现的，而是通过大量的实践落地进而总结产生的一套解决方案核心思路。
所以道很多时候是&amp;quot;虚&amp;quot;的东西，越虚意味着就越抽象，如果两个人在讨论某个问题，而对一些专业理论的认知还未处于同一水平上，那听起来就只能离谱了。
所以要讲道之前，得先有术。术就是指对应具体的语言，框架或者中间件使用姿势。这些都是比较具体的东西，实操性强，方面大家理解。
架构的道和术，都不能偏废，一方面需要不断实践(术)，在实践中深入原理。进而把实践的东西抽象，总结出来，形成方法论(道)。 不断的用道来指导新的术，在新的术中再总结出新的道，如此循环往复。
以上是第一部分内容。
第二部分：计算机功底 主要讲解的是术。计算机功底、语言、框架、网络、数据库、操作系统等。
印象最深刻的是框架那一章。作者提到，熟悉一个框架之后，更多的是应该去关注它的缺点，而不是优点。更应该关注它不能做什么，而不是它能做什么。 它不能做什么往往是别的框架的改进点。
细想，如果你不关注它不能做什么，在你们拍板决定使用框架时，做了一半发现， 核心的一块需求它支持不了，这时候只能欲哭无泪了。
第三部分：技术架构之道 主要讲解的是道。 里面分为:
 高并发问题 高可用与稳定性 事务一致性 多副本一致性 CAP理论  因为这一部分主要是关于道方面的，所以很多地方是抽象化的。读者在读这一部分时候，针对一些问题的解决方案，需要自行去思考部分细节。</description>
    </item>
    
    <item>
      <title>一个用go实现的有限状态机 </title>
      <link>https://www.syst.top/posts/go/easyfsm/</link>
      <pubDate>Sun, 06 Mar 2022 17:37:22 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/easyfsm/</guid>
      <description>easyfsm 之前看过新亮老哥的go-fsm-order，感觉还不错。最近在迁移项目的时候，发现有多处业务存在一些状态的流转，所以就基于go-fsm-order做了重改，让它可以在不同的业务场景下使用。
为什么不使用looplab/fsm，star挺多的啊。
不是特别喜欢，每次实例化fsm都需要重新传递对应events(虽然我们可以统一封装)，我更期望在项目启动时把此项目涉及到不同业务状态机流转注册到fsm，对应:不同业务-&amp;gt;[状态]-&amp;gt;[事件]-&amp;gt;处理事件主体(包含handler、params、hooks、observers等)。
当你开始进行状态流转时，只需要
fsm:=NewFsm(&amp;#34;业务名称&amp;#34;,&amp;#34;当前状态&amp;#34;) currentState,err:=fsm.Call(&amp;#34;事件名称&amp;#34;,&amp;#34;对应事件所需参数可选项&amp;#34;) 为什么需要区分业务？
因为绝大多数业务的状态值都是从数据库中获取的，比如订单表的订单状态，商品表中的商品状态，有可能值是相同的。
同一个业务同一属性对应状态值表达单一，不同业务下属性状态可能会出现值相同，但所表达的含义是不同的。
整体设计:
简单解释一下：
 业务:比如有商品状态业务、订单状态业务&amp;hellip;.. 状态：订单待付款、待发货&amp;hellip;. 事件：对应状态仅可达事件集合。比如待付款状态的可达事件仅有:支付事件和取消事件(取决于自己的业务) 执行事件主体：执行自定义的事件函数,如果有需要，还可以自定义执行事件前后hook，事件订阅者(比如支付事件发生后，异步通知用户等)  使用姿势 go get -u github.com/wuqinqiang/easyfsm 首先自定义业务、状态、事件。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/wuqinqiang/easyfsm&amp;#34; ) var ( // 业务 	businessName easyfsm.BusinessName = &amp;#34;order&amp;#34; // 对应状态 	initState easyfsm.State = 1 // 初始化 	paidState easyfsm.State = 2 // 已付款 	canceled easyfsm.State = 3 // 已取消  //对应事件 	paymentOrderEvent easyfsm.EventName = &amp;#34;paymentOrderEvent&amp;#34; cancelOrderEvent easyfsm.</description>
    </item>
    
    <item>
      <title>你还不体验泛型吗</title>
      <link>https://www.syst.top/posts/go/generics/</link>
      <pubDate>Sun, 02 Jan 2022 18:32:00 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/generics/</guid>
      <description>介绍 之前有看过官方发布的一些泛型文章，但是自己没动手玩过。还有没有没玩过的，那么最后一班车了。
不管学什么入门先从官网拿例子。
这段代码很简单，定义两个函数，计算对应传入的map值的和。两个函数最大的不同在于函数参数类型有所不同，一个map的值类型为int64,一个为float64，对应返回参数也有所不同。
在没有泛型的情况下，每种类型都不得不重新定义一个函数。
有人可能会说，上面的代码你可以这样写在一个函数里，
你确认这真的好吗？
泛型函数 但是，有了泛型之后，那就简单多了。
上面这段代码中，
定义了一个新函数SumIntsOrFloats，该函数声明两个类型参数 [K comparable, V int64 | float64]。其中K指定了类型必须为可比较(即可以用作比较符 == 和 !=)。因为 go中规定map的key必须是可比较类型。
比如，我们不能这样声明一个map。
所以这里的K就不能使用any关键字。
另一个V参数指定了一个约束，该约束由int64和float64组成，使用 | 指定了联合类型。
所以这里m参数为map[K]V类型，K,V即为参数类型指定的类型。
那么，如果你传入的map值的类型为其他类型。比如下面这种就不行了。
类型约束 上面看到的是我们在方法上对参数做一些约束。当然我们也可以直接声明类型约束。
上面的代码声明了一个Number用做类型约束的接口类型。在接口里声明int64和float64联合类型。
在SumNumbers中如果约束类型为int64或者 float64，那么只需要使用Number类型约束即可，就不用每个不同函数写 int64 | float64，达到代码复用的效果。
但是如果我这样，
我们把map中的值类型调整为自定义的otherInt64类型，otherInt64的基础类型也是int64。但是，这段代码编译会报错。
原因是 int64 约束会将其限制为只能是该类型，也就是只能是 int64，不能是基于此类型定义的其他类型。
如果想使用otherInt64咋么办，很简单，只需要一个～符号，
使用带～xxtype会将其限制为基础类型为xxtype的所有类型。
应用 上面只是简单介绍了一下使用姿势，那么哪些场景下可以使用泛型呢？
比如日常开发中，像slice、map、channel的一些处理函数，可能逻辑相同但是类型不同导致copy多个不同函数，这时候可以用泛型解决。比如，
还有一些行为方面的。比如 go 中的排序，通过泛型，不需要每一个结构都实现(Len，Less，Swap)三个方法，而是抽象出依赖于三个方法的行为。那么想要实现排序只需要依赖定义的这个抽象就行了。
其他方面的应用可以自行体验。
总结 这篇文章主要带你们体验下泛型的基本使用，以及对应的类型约束，最后还简单实验了两个泛型的场景demo，感兴趣的可以自行体验。更多内容，欢迎留言区域交流。
附录  https://go.dev/doc/tutorial/generics https://teivah.medium.com/when-to-use-generics-in-go-36d49c1aeda https://github.com/mattn/go-generics-example  </description>
    </item>
    
    <item>
      <title>就当是年终总结吧</title>
      <link>https://www.syst.top/lives/bulaoqishi/</link>
      <pubDate>Thu, 23 Dec 2021 23:18:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/bulaoqishi/</guid>
      <description>图片拍摄于2021年12月04日
有点可怕，转眼又一年了。
还剩一天年假，今天趁着2021年的最后一周把年假给调了，顺便动动手指写下这篇文章。
既然是年终总结，那么理所当然，随意写了，你们也随意看看就行了。
今年有靠公众号赚到钱吗？
没有。一毛没挣。
唯一开通流量主赚几个鸡腿的机会，我嫌体验差也没开通，接广告就更不可能了，我的公众号不足以让正经一点的广告商找上门。
自己倒是给粉丝送书的时候搭进去点钱，不过，我开心就好。
另外，我现在的认知不足以让我通过公众号赚到钱。
为什么要提上面这句话？
我发现这两年听到的最多的一句话是:人只能赚到自己认知内的钱，即使现在赚到了超过认知外的xxx，后面也会xxx。
我不知道这句话的出处在哪，只是每每看到别人写东西的时候都会带上这句话。
我觉得这句话太过绝对了。在我看来，任何人都有可能赚到超出自己认知范围的钱。
希望坚信这句话的人能在下面反驳我，但是不要骂我，
上面是一段小插曲。
今年收获了什么？
毕业来杭州也三年了，真的太快了。之前一直想留在杭州，年初在家人的帮助下，还是在杭州安了一个小家，也算是实现了一个小小的需求吧。
公众号勉勉强强上路了，年初公众号定下的目前完成度不到40%，也是疯狂被打脸。
但是这其实也是意料之中的事情。回想起年初定下公众号目标的时候过于随意，而且那时候我就抱有大概率完成不了的念头。
还没开打，就否定自己，这能不输吗？
我们常听说：不要给自己设上限。
我现在加一句：不要给自己设下限。
所以它其实就是：永远不要给自己设限。
除了公众号这块，其他年初定下的目前都完成了。
但是在我看来，有些虽然完成了，但是质量堪忧。所以接下来对下一年的todolist，要求会再高点，最好能带有一些实际的量化指标。
工作上，也算是完整接触golang的一年。在用golang的同时，也去看了底层的一些源码，对自己使用的东西更加有把握了。
今年来了一些同事，加上之前的一些同事。有那么一段时间，试着去观察同事身上一些优秀品质。毕竟每个人都是独一无二的，也有属于自己的闪光点。
那么我们就需要试着在他们身上寻找那些我们所不具备的品质，试着学习他们的一些思维模式以及做事情的方式、技巧等，来弥补自己身上的空缺。
无知并不可怕，可怕的是无知却不自知，无知却傲慢，无知却偏见。
我觉得，我应该时刻提醒自己这句话。
另外，我之前有产生过一些错误的想法。可能觉得自己离35岁还远，进而觉得危机离我还远。
以至于在某些行为上，会放低对自我的要求，不太注重细节。现在想想，这种想法，是极其可怕的。
你们都知道细节决定成败，我想说的是，细节也能形成习惯。
当你在一件事的细节上敷衍了事，那么后面相同的事你也会习惯性地这样处理，久而久之，这就是你的习惯。
这和篮球中投篮动作有点相似，打过球的人都知道，想想你现在的投篮姿势，是不是就是你开始打球那段时间产生的姿势，然后这个姿势就被定型了，很难再进行投篮的转变。
即使你说你中途通过训练调整过来了，可是，那段时间是不是非常痛苦？
最后，看书方面，今年看的书并不是很多，但是很杂。有时候会几本书切着看，我不知道你们有没有这个习惯。
虽然也给自己做了一些读书笔记，但整体来看，看的还是太少了，明年争取看完每本书都写一篇读书笔记供大家参考。跪求各位大佬留言区留下你们看过的好书，我去啃啃。
本篇到这里也就结束了。唉，没钱人的一年，往往就是这么的朴实无华且枯燥</description>
    </item>
    
    <item>
      <title>不定期的一些思考</title>
      <link>https://www.syst.top/lives/think/</link>
      <pubDate>Thu, 23 Dec 2021 22:23:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/think/</guid>
      <description>不要觉得一件事情简单，自我感觉没有挑战，而无动于衷。你所谓的简单，在很多时候只是你并没有去深度思考事情的本质。
即使是简单的curd工作，你有没有想过，当前你的设计是否满足未来产品形态的变动？一改就头痛？还是写出来的代码测试用例都难写？
你有没有这样的时刻？
当别人带着一个问题来寻找你进行解决方案。你思考一番，在这个问题的基础上加以补丁，你自以为解决了这个问题，直到后面补丁也越来越多。
你有没有想过，其实，很多时候，出发点就错了。我们都把目光直接切入这个问题的解决方案，也就是所谓的补丁(我并不是说我们不解决问题)，而是，是不是忽略了去思考为什么会出现这样的问题？是不是一开始就错了？
如果一开始就错了，在这个错误的基础上产生错误的问题，我们应该直接揪出源头，然后干掉它。而不是在错误的基础上疯狂的给错误的问题打上错误的补丁。
和别人沟通的时候，当别人发表完自己的意见和观点，你开口的第一句是不是:
&amp;ldquo;不是这样的&amp;rdquo;。
你喜欢用否定句来当场否定别人，直接当场浇灭对方。
如果改成 &amp;ldquo;好的，我明白你意思了。但是我想了下，xxxx&amp;rdquo; 类似这样，沟通的效果会不会更加理想？</description>
    </item>
    
    <item>
      <title>那些用Go实现的分布式事务框架</title>
      <link>https://www.syst.top/posts/go/transaction/</link>
      <pubDate>Wed, 08 Dec 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/transaction/</guid>
      <description>开篇 不知不觉竟然一个月没更新了，人一旦懒下来只会越来越懒。
最近对分布式事务产生了一些兴趣，查阅了一些文章以及论文。这篇文章主要介绍我看的两个项目，不涉及一些理论知识。
 阿里开源版本的Seata，主要看了Go实现的seata-golang(落后java版) 以及前段时间很多公众号都发的dtm。  Seata简介 Seata是由阿里开源的分布式事务服务，目前为用户提供了AT、TCC、SAGA、XA的事务模式，整体采用的是两阶段提交协议。Go版的seata-golang 目前好像只实现了mysql的AT、TCC模式，作者现在不咋更新了。
Seata 有几个核心角色：
 TC(Transaction Coordinator) -事务协调者。(维护全局和分支事务的状态，驱动全局事务提交或回滚) TM(Transaction Manager)-事务管理器。(定义全局事务的范围：开始全局事务、提交或回滚全局事务。) RM(Resource Manager)-资源管理器。(管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚)  当然这样看，可能还不是很理解，我拿一张官网的图加以解释。
从上图中可以看出，这三个角色所负责的工作如下，
TC
 维护全局和分支事务状态，需要进行存储。 当一个分布式事务处理结束，需要通知到每个RM是commit还是rollback。  TM
 向TC请求开启一个分布式事务，得到一个全局唯一的分布式id。 根据每个参与分布式事务的RM一阶段的反馈，决定二阶段向TC请求此次分布式事务是commit还是rollback(绝大部分场景下，一阶段任一RM失败，本次分布式事务失败)  RM
说的白一点就是管理参与分布式事务的各个服务(比如经典下单场景中涉及到的:订单服务、库存服务、营销服务等)
ps:个人感觉，这里的RM有点类似微服务中的中间处理层(专业术语他们管这叫bff-&amp;gt;backend for fronted)。
  一阶段 prepare 行为(主动)：每个RM调用 自定义 的 prepare 逻辑。
  二阶段 commit 行为(被动触发)：如果本次分布式事务第一阶段全部RM成功，TC处理完自身状态变更后，调用各个RM自定义 的 commit 逻辑。(一阶段RM全部成功)
  二阶段 rollback 行为(被动触发)：如果本次分布式事务第一阶段任一RM失败，TC处理完自身状态变更后，调用各个RM自定义 的 rollback 逻辑。(一阶段任意RM失败)
  好了。下面可以看看seata-golang 实现的一些细节了，seata-golang 底层采用gRPC进行通信。
seata-golang 我们先看RM部分结构。</description>
    </item>
    
    <item>
      <title>那些用Go实现的分布式事务框架(2)</title>
      <link>https://www.syst.top/posts/go/transaction2/</link>
      <pubDate>Wed, 08 Dec 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/transaction2/</guid>
      <description>开篇 上一篇我们主要介绍的是seata-golang。一个对标seata的go语言实现，当然版本还是落后Java版很多的。
这次我们来介绍一下另一个go实现的分布式事务:dtm。
首先来看下dtm整体架构图(来源官网)。
再来看之前的seata架构图。
从架构上来看，大差不差。
seata中的TC对标dam的TM。
RM两边意思一致。
seata中的TM对标dtm事务SDK。作用都是一样:第一阶段开启一个全局事务,执行各RM分支事务，第二阶段根据RM第一阶段执行结果，决定调用TC(seata)|TM(dtm) commit或者rollback。
架构上，个人感觉只是因为模块名称以及图画不一样的差别。
当然在实现细节上还是有很大差别的。
我们先简单介绍下DTM各个模块。
TM TM 层在代码中是没有具体的主体结构的，开始都是函数之前的调用。
启动TM实际上开启了两个服务，http以及grpc这两个服务。
// StartSvr StartSvr func StartSvr() { app := common.GetGinApp() app = httpMetrics(app) addRoute(app) dtmimp.Logf(&amp;#34;dtmsvr listen at: %d&amp;#34;, common.DtmHttpPort) go app.Run(fmt.Sprintf(&amp;#34;:%d&amp;#34;, common.DtmHttpPort)) lis, err := net.Listen(&amp;#34;tcp&amp;#34;, fmt.Sprintf(&amp;#34;:%d&amp;#34;, common.DtmGrpcPort)) dtmimp.FatalIfError(err) s := grpc.NewServer( grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer( grpc.UnaryServerInterceptor(grpcMetrics), grpc.UnaryServerInterceptor(dtmgimp.GrpcServerLog)), )) dtmgimp.RegisterDtmServer(s, &amp;amp;dtmServer{}) dtmimp.Logf(&amp;#34;grpc listening at %v&amp;#34;, lis.Addr()) go func() { err := s.Serve(lis) dtmimp.FatalIfError(err) }() go updateBranchAsync() // 省略代码 } http路由，</description>
    </item>
    
  </channel>
</rss>
